# GCC

GCC 是 Linux 下的编译工具集，是 GNU Compiler Collection 的缩写，包含 gcc、g++ 等编译器。这个工具集不仅包含编译器，还包含其他工具集，例如 ar、nm 等。

GCC 工具集不仅能编译 C/C++ 语言，其他例如 Objective-C、Pascal、Fortran、Java、Ada 等语言均能进行编译。GCC 在可以根据不同的硬件平台进行编译，即能进行交叉编译，在 A 平台上编译 B 平台的程序，支持常见的 X86、ARM、PowerPC、mips 等，以及 Linux、Windows 等软件平台。

## 安装 GCC

```
# 安装软件必须要有管理员权限
# ubuntu
$ sudo apt update   		# 更新本地的软件下载列表, 得到最新的下载地址
$ sudo apt install gcc g++	# 通过下载列表中提供的地址下载安装包, 并安装

# centos
$ sudo yum update   		# 更新本地的软件下载列表, 得到最新的下载地址
$ sudo yum install gcc g++	# 通过下载列表中提供的地址下载安装包, 并安装


# 查看 gcc 版本
$ gcc -v
$ gcc --version

# 查看 g++ 版本
$ g++ -v
$ g++ --version
```

## gcc 工作流程

GCC 编译器对程序的编译下图所示，分为 4 个阶段：预处理（预编译）、编译和优化、汇编和链接。GCC 的编译器可以将这 4 个步骤合并成一个。 先介绍一个每个步骤都分别做了写什么事儿:

![img](https://img.herrluk.icu/typoraPicture/2022-12-01-19:39:26.jpg)

1. 预处理：在这个阶段主要做了三件事: 

- 展开头文件 
- 宏替换 
- 去掉注释行

这个阶段需要 GCC 调用*预处理器*来完成，最终*得到的还是源文件*，但是***文本格式***

2. 编译：这个阶段需要 GCC 调用*编译器*对文件进行编译，最终得到一个***汇编文件***

3. 汇编：这个阶段需要 GCC 调用*汇编器*对文件进行汇编，最终得到一个***二进制文件***

4. 链接：这个阶段需要 GCC 调用*链接器*对程序需要*调用的库进行链接*，最终得到一个*可执行的二进制文件*

| 文件名后缀 | 说明                       | gcc 参数 |
| ---------- | -------------------------- | -------- |
| .c         | 源文件                     | 无       |
| .i         | 预处理后的C 文件           | -E       |
| .s         | 编译后得到的汇编程序源文件 | -S       |
| .o         | 汇编后得到的二进制文件     | -c       |

汇编后生成可执行文件不需要任何参数：`gcc test.o -o test`

在 Linux 下使用 GCC 编译器编译单个文件十分简单，直接使用 gcc 命令后面加上要编译的 C 语言的源文件，GCC 会自动生成*文件名为 a.out 的可执行文件*（也可以通过*参数 -o 指定生成的文件名*），也就是*通过一个简单的命令上边提到的 4 个步骤就全部执行完毕了*。

但是如果想要单步执行也是没问题的， 下边基于这段示例程序给大家演示一下。

假设程序对应的源文件名为 test.c



> 第一步：对源文件进行预处理，需要使用的 gcc 参数为 -E

```
#预处理, -o 指定生成的文件名
$ gcc -E test.c -o test.i
```

> 第二步：编译预处理之后的文件，需要使用的 gcc 参数为 -S

```
# 2. 编译, 得到汇编文件
$ gcc -S test.i -o test.s
```

> 第三步：对得到的汇编文件进行汇编，使用的gcc 参数为 `-c`

```
# 3. 汇编
$ gcc -c test.s -o test.o
```

> 第四步：将得到的二进制文件和标准库进制链接，得到可执行的二进制文件，***不需要任何参数***

```
# 4. 链接
$ gcc test.o -o test
```


最后再次强调，在使用 gcc 编译程序的时候可以通过参数控制内部自动执行几个步骤，***之前的步骤会自动执行***：

```
# 参数 -c 是进行文件的汇编, 汇编之前的两步会自动执行
$ gcc test.c -c -o app.o

# 该命令是直接进行链接生成可执行程序, 链接之前的三步会自动执行
$ gcc test.c -o app    

```

## gcc常用参数

下面的表格中列出了常用的一些 gcc 参数，*这些参数在 gcc命令中没有位置要求*，只需要编译程序的时候将需要的参数指定出来即可

| gcc 编译选项                             | 选项的意义                                                   |
| ---------------------------------------- | ------------------------------------------------------------ |
| -E                                       | 预处理指定的源文件，不进行编译                               |
| -S                                       | 编译指定的源文件，但是不进行汇编                             |
| -c                                       | 编译、汇编指定的源文件，但是不进行链接                       |
| [file2] -o [file1]*或*-o [file1] [file2] | 将文件 file2 编译成文件 file1                                |
| -I directory (大写的 i)                  | 指定 include 包含文件的搜索目录                              |
| -g                                       | 在编译的时候，生成调试信息，该程序可以被调试器调试           |
| -D                                       | 在程序编译的时候，指定一个宏                                 |
| -w                                       | 不生成任何警告信息，不建议使用，有些时候警告就是错误         |
| -Wall                                    | 生成所有警告信息                                             |
| -On                                      | n 的取值范围：0~3。编译器的优化选项的 4 个级别，-O0 表示没有优化，-O1 为缺省值，-O3 优化级别最高 |
| -l                                       | 在程序编译的时候，指定使用的库                               |
| -L                                       | 指定编译的时候，搜索的库的路径。                             |
| -fPIC/fpic                               | 生成与位置无关的代码                                         |
| -shared                                  | 生成共享目标文件。通常用在建立共享库时                       |
| -std                                     | 指定 C 方言，如:-std=c99，gcc 默认的方言是 GNU C             |

### 指定生成的文件名（-o）

> 该参数用于指定原文件通过 gcc 处理之后生成的新文件的名字，有两种写法，原文件可以写在参数 -o 前边后缀写在后边。



```
# 参数 -o的用法 , 原文件 test.c 最终生成的文件名为 app
# test.c 写在 -o 之前
$ gcc test.c -o app

# test.c 写在 -o 之后
$ gcc -o app test.c
```

### 搜索头文件（-l）大写的 i

如果在程序中包含了一些头文件，但是包含的一些头文件在程序预处理的时候因为找不到无法被展开，导致程序编译失败，这时候我们可以在 gcc 命令中添加 `-I` 参数重新指定要引用的头文件路径，保证编译顺利完成。

```
# -I, 指定头文件目录
$ tree
.
├── add.c
├── div.c
├── include
│   └── head.h
├── main.c
├── mult.c
└── sub.c

# 编译当前目录中的所有源文件，得到可执行程序
$ gcc *.c -o calc
main.c:2:18: fatal error: head.h: No such file or directory
compilation terminated.
sub.c:2:18: fatal error: head.h: No such file or directory
compilation terminated.

```

通过编译得到的错误信息可以知道，源文件中包含的头文件无法被找到。通过提供的目录结构可以得知头文件 head.h 在 include 目录中，因此可以在编译的时候重新指定头文件位置，具体操作如下：

```
# 可以在编译的时候重新指定头文件位置 -I 头文件目录
$ gcc *.c -o calc -I ./include
```

### 指定一个宏（-D）

> 在程序中我们可以使用宏定义一个常量，也可以通过宏控制某段代码是否能够被执行。在下面这段程序中第 8 行判断是否定义了一个叫做 `DEBUG` 的宏，如果没有定义第 9 行代码就不会被执行了，通过阅读代码能够知道这个宏是没有在程序中被定义的。
>

```
// test.c
#include <stdio.h>
#define NUMBER  3

int main()
{
    int a = 10;
#ifdef DEBUG
    printf("我是一个程序猿, 我不会爬树...\n");
#endif
    for(int i=0; i<NUMBER; ++i)
    {
        printf("hello, GCC!!!\n");
    }
    return 0;
}
```

> 如果不想在程序中定义这个宏， 但是又想让它存在，通过 gcc 的参数 -D 就可以实现了，***编译器会认为参数后边指定的宏在程序中是存在的。***

```
# 在编译命令中定义这个 DEBUG 宏, 
$ gcc test.c -o app -D DEBUG

# 执行生成的程序， 可以看到程序第9行的输出
$ ./app 
我是一个程序猿, 我不会爬树...
hello, GCC!!!
hello, GCC!!!
hello, GCC!!!
```

> -D 参数的应用场景: 
>
> 在发布程序的时候，一般都会要求将程序中所有的 log 输出去掉，如果不去掉会影响程序的执行效率，很显然删除这些打印 log 的源代码是一件很麻烦的事情，解决方案是这样的：  
>
> ***将所有的打印 log 的代码都写到一个宏判定中***，可以模仿上边的例子 
>
> - 在编译程序的时候指定 -D 就会有 log 输出 
> - 在编译程序的时候不指定 -D, log 就不会输出

## 多文件编译

> GCC 可以自动编译链接多个文件，不管是目标文件还是源文件，都可以使用同一个命令编译到一个可执行文件中。
>

### 准备工作

> 首先将程序编译之前需要的代码准备出来，例如一个项目包含 3 个文件，文件 string.h , string.c 中有一个函数 strLength 用于计算字符串的长度，而在 main.c 中调用这个函数将计算的结果显示出来。
>

- 头文件：


```
#ifndef _STRING_H_
#define _STRING_H_
int strLength(char *string);
#endif // _STRING_H_
```

- 源文件 `string.c`


```
#include "string.h"

int strLength(char *string){
	int len = 0;
	while(*string++ != '\0') 	// 当*string 的值为'\0'时, 停止计算
    {
        len++;
    }
	return len; 	// 返回字符串长度
}
```

- 源文件 `main.c`


```
#include <stdio.h>
#include "string.h"

int main(void){
	char *src = "Hello, I'am Monkey·D·Luffy!!!"; 
	printf("string length is: %d\n", strLength(src)); 
	return 0;
}

```

### 编译运行

> 因为头文件是包含在源文件中的，因此在使用 gcc 编译程序的时候不需要指定头文件的名字（在头文件无法被找到的时候需要使用参数 `-I` 指定其具体路径而不是名字）。我们可以通过一个 gcc 命令将多个源文件编译并生成可执行程序，也可以分多步完成这个操作。
>

- 直接链接生成可执行程序:


```
# 直接生成可执行程序 test
$ gcc -o test string.c main.c

# 运行可执行程序
$ ./test
```

- 先将源文件编成目标文件，然后进行链接得到可执行程序


```
# 汇编生成二进制目标文件, 指定了 -c 参数之后, 源文件会自动生成 string.o 和 main.o
$ gcc –c string.c main.c

# 链接目标文件, 生成可执行程序 test
$ gcc –o test string.o main.o

# 运行可执行程序
$ ./test

```

## gcc 与 g++

> 关于对 gcc 和 g++ 很多人的理解都是比较片面的或者是对二者的理解有一些误区，下边从三个方面介绍一下二者的区别:
>

1. 在代码编译阶段（第二个阶段）:

- 后缀为 .c 的，gcc 把它当作是 *C 程序*，而 g++ 当作是 *C++ 程序*

- 后缀为.cpp 的，两者*都会认为是 C++ 程序*，C++ 的语法规则更加严谨一些
- g++ 会调用 gcc，对于 C++ 代码，两者是等价的，也就是说 gcc 和 g++ 都可以编译 C/C++ 代码

2. 在链接阶段（最后一个阶段）:

- gcc 和 g++ 都可以自动链接到标准 C 库
- g++ 可以自动链接到标准 C++ 库，*gcc 如果要链接到标准 C++ 库需要加参数 -lstdc++*

3. 关于 __cplusplus 宏的定义

- g++ 会自动定义__cplusplus 宏，但是这个不影响它去编译 C 程序

- gcc 需要根据文件后缀判断是否需要定义 __cplusplus 宏 （规则参考第一条）

>
> 综上所述：
>
> 1. 不管是 gcc 还是 g++ 都可以编译 C 程序，编译程序的规则和参数都相同
>
> 2. g++ 可以直接编译 C++ 程序， gcc 编译 C++ 程序需要添加额外参数 -lstdc++
> 3. 不管是 gcc 还是 g++ 都可以定义 __cplusplus 宏



```
# 编译 c 程序
$ gcc test.c -o test	# 使用gcc
$ g++ test.c -o test	# 使用g++

# 编译 c++ 程序
$ g++ test.cpp -o test              # 使用g++
$ gcc test.cpp -lstdc++ -o test     # 使用gcc
```

# 动态库和静态库

不管是 Linux 还是 Windows 中的库文件其本质和工作模式都是相同的，只不过在不同的平台上库对应的文件格式和文件后缀不同。

程序中调用的库有两种 *静态库*和*动态库*，不管是哪种库文件本质是还是源文件，只不过是二进制格式只有计算机能够识别，作为一个普通人就无能为力了。  

在项目中使用库一般有两个目的，一个是为了使程序更加简洁不需要在项目中维护太多的源文件，另一方面是为了源代码保密，毕竟不是所有人都想把自己编写的程序开源出来。  

当我们拿到了库文件（动态库、静态库）之后要想使用还必须有这些库中提供的 API 函数的声明，也就是头文件，把这些都添加到项目中，就可以快乐的写代码了。

## 静态库

> 在 Linux 中静态库由程序 `ar` 生成，现在静态库已经不像之前那么普遍了，这主要是由于程序都在使用动态库。关于静态库的命名规则如下:

- 在 Linux 中静态库以 `lib` 作为前缀，以`.a` 作为后缀，*中间是库的名字*，自己指定即可，即: `libxxx.a`

- 在 Windows 中静态库一般以 `lib` 作为前缀，以 `lib` 作为后缀，*中间是库的名字*，自己指定，即: `libxxx.lib`

### 生成静态链接库

> 生成静态库，需要先对源文件进行汇编操作 (使用参数 -c) ，得到二进制格式的目标文件 (.o 格式)，然后在通过 `ar` 工具将目标文件打包就可以得到静态库文件了 (libxxx.a)。  

**使用 ar 工具创建静态库的时候需要三个参数:**  

- `参数c`：创建一个库，不管库是否存在，都将创建。 
- `参数s`：创建目标文件索引，这在创建较大的库时能加快时间。
- `参数r`：在库中插入模块 (替换)。默认新的成员添加在库的结尾处，如果模块名已经在库中存在，则替换同名的模块。

![img](https://img.herrluk.icu/typoraPicture/2022-12-01-20:42:18.png)

**生成静态链接库的具体步骤如下**:

1. 需要将源文件进行汇编，得到 .o 文件，需要使用参数 -c

```
# 执行如下操作, 默认生成二进制的 .o 文件
# -c 参数位置没有要求
$ gcc 源文件(*.c) -c	
```

2. 将得到的 .o 进行打包，得到静态库

```
$ ar rcs 静态库的名字(libxxx.a) 原材料(*.o)
```

3. 发布静态库

```
# 发布静态库
	1. 提供头文件 **.h
	2. 提供制作出来的静态库 libxxx.a
```

### 静态库制作举例

#### 准备测试程序

> 在某个目录中有如下的源文件，用来实现一个简单的计算器:

```
# 目录结构 add.c div.c mult.c sub.c -> 算法的源文件, 函数声明在头文件 head.h
# main.c中是对接口的测试程序, 制作库的时候不需要将 main.c 算进去
.
├── add.c
├── div.c
├── include
│   └── head.h
├── main.c
├── mult.c
└── sub.c
```

加法计算源文件 add.c:

```
#include <stdio.h>
#include "head.h"

int add(int a, int b)
{
    return a+b;
}
```

减法计算源文件 sub.c:

```
#include <stdio.h>
#include "head.h"

int subtract(int a, int b)
{
    return a-b;
}
```

乘法计算源文件 mult.c:

```
#include <stdio.h>
#include "head.h"

int multiply(int a, int b)
{
    return a*b;
}
```

除法计算的源文件 div.c

```
#include <stdio.h>
#include "head.h"

double divide(int a, int b)
{
    return (double)a/b;
}
```

头文件 head.h

```
#ifndef _HEAD_H
#define _HEAD_H
// 加法
int add(int a, int b);
// 减法
int subtract(int a, int b);
// 乘法
int multiply(int a, int b);
// 除法
double divide(int a, int b);
#endif
```

测试文件 main.c

```
#include <stdio.h>
#include "head.h"

int main()
{
    int a = 20;
    int b = 12;
    printf("a = %d, b = %d\n", a, b);
    printf("a + b = %d\n", add(a, b));
    printf("a - b = %d\n", subtract(a, b));
    printf("a * b = %d\n", multiply(a, b));
    printf("a / b = %f\n", divide(a, b));
    return 0;
}
```

#### 生成静态库

> 第一步：将源文件 add.c, div.c, mult.c, sub.c 进行汇编，得到二进制目标文件 add.o, div.o, mult.o, sub.o

```
# 1. 生成.o
$ gcc add.c div.c mult.c sub.c -c
sub.c:2:18: fatal error: head.h: No such file or directory
compilation terminated.

# 提示头文件找不到, 添加参数 -I 重新头文件路径即可
$ gcc add.c div.c mult.c sub.c -c -I ./include/

# 查看目标文件是否已经生成
$ tree
.
├── add.c
├── add.o            # 目标文件
├── div.c
├── div.o            # 目标文件
├── include
│   └── head.h
├── main.c
├── mult.c
├── mult.o           # 目标文件
├── sub.c
└── sub.o            # 目标文件
```

> 第二步：将生成的目标文件通过 ar 工具打包生成静态库

```
# 2. 将生成的目标文件 .o 打包成静态库
$ ar rcs libcalc.a a.o b.o c.o    # a.o b.o c.o在同一个目录中可以写成 *.o

# 查看目录中的文件
$ tree
.
├── add.c
├── add.o
├── div.c
├── div.o
├── include
│   └── `head.h  ===> 和静态库一并发布
├── `libcalc.a   ===> 生成的静态库
├── main.c
├── mult.c
├── mult.o
├── sub.c
└── sub.o
```

> 第三步：***将生成的的静态库 libcalc.a 和库对应的头文件 head.h 一并发布给使用者就可以了。***

```
# 3. 发布静态库
	1. head.h    => 函数声明
	2. libcalc.a => 函数定义(二进制格式)
```

### 静态库的使用

> 当我们得到了一个可用的静态库之后，需要将其放到一个目录中，然后***根据得到的头文件编写测试代码，对静态库中的函数进行调用***。

```
# 1. 首先拿到了发布的静态库
	`head.h` 和 `libcalc.a`
	
# 2. 将静态库, 头文件, 测试程序放到一个目录中准备进行测试
.
├── head.h          # 函数声明
├── libcalc.a       # 函数定义（二进制格式）
└── main.c          # 函数测试

```

> 编译测试程序，得到可执行文件。

```
# 3. 编译测试程序 main.c
$ gcc main.c -o app
/tmp/ccR7Fk49.o: In function `main':
main.c:(.text+0x38): undefined reference to `add'
main.c:(.text+0x58): undefined reference to `subtract'
main.c:(.text+0x78): undefined reference to `multiply'
main.c:(.text+0x98): undefined reference to `divide'
collect2: error: ld returned 1 exit status
```

> 上述错误分析:
>
> 编译的源文件中包含了头文件 head.h, *这个头文件中声明的函数对应的定义（也就是函数体实现）在静态库中，程序在编译的时候没有找到函数实现*，因此提示 undefined reference to xxxx。
>
> 解决方案：***在编译的时将静态库的路径和名字都指定出来***
>
> - -L: 指定库所在的目录 (相对或者绝对路径)
> - -l: 指定库的名字，需要掐头 (lib) 去尾 (.a) 剩下的才是需要的静态库的名字
>
>
> 



```
# 4. 编译的时候指定库信息
	-L: 指定库所在的目录(相对或者绝对路径)
	-l: 指定库的名字, 掐头(lib)去尾(.a) ==> calc
# -L -l, 参数和参数值之间可以有空格, 也可以没有  -L./ -lcalc
$ gcc main.c -o app -L ./ -l calc

# 查看目录信息, 发现可执行程序已经生成了
$ tree
.
├── app   		# 生成的可执行程序
├── head.h
├── libcalc.a
└── main.c
```

## 动态库

> 动态链接库是程序运行时加载的库，当动态链接库正确部署之后，运行的多个程序可以使用同一个加载到内存中的动态库，因此在 Linux 中动态链接库也可称之为共享库。
>
> 动态链接库是目标文件的集合，目标文件在动态链接库中的组织方式是按照特殊方式形成的。库中函数和变量的地址使用的是相对地址（静态库中使用的是绝对地址），其真实地址是在应用程序加载动态库时形成的。

**关于动态库的命名规则如下:**

- 在 Linux 中动态库以 lib 作为前缀，以.so 作为后缀，中间是库的名字自己指定即可，即: libxxx.so

- 在 Windows 中动态库一般以 lib 作为前缀，以 dll 作为后缀，中间是库的名字需要自己指定，即: libxxx.dll

### 生成动态链接库

> 生成动态链接库是直接使用 gcc 命令并且需要添加 -fPIC（-fpic） 以及 -shared 参数。

- -fPIC 或 -fpic 参数的作用是*使得 gcc 生成的代码是与位置无关的，也就是使用相对位置*。
-  -shared参数的作用是*告诉编译器生成一个动态链接库。*

![img](https://img.herrluk.icu/typoraPicture/2022-12-02-16:21:29.png)

***生成动态链接库的具体步骤如下 :***

1. 将源文件进行汇编操作，需要使用参数 -c, 还需要添加额外参数 -fpic /-fPIC

```
# 得到若干个 .o文件
$ gcc 源文件(*.c) -c -fpic
```

2. 将得到的.o 文件打包成动态库，还是使用 gcc, 使用参数 -shared 指定生成动态库 (位置没有要求)

```
$ gcc -shared 与位置无关的目标文件(*.o) -o 动态库(libxxx.so)
```

3. 发布动态库和头文件

```
# 发布
 	1. 提供头文件: xxx.h
 	2. 提供动态库: libxxx.so
```

### 动态库制作举例

在此还是以上面制作静态库使用的实例代码为例来制作动态库，代码目录如下:

```
# 举例, 示例目录如下:
# 目录结构 add.c div.c mult.c sub.c -> 算法的源文件, 函数声明在头文件 head.h
# main.c中是对接口的测试程序, 制作库的时候不需要将 main.c 算进去
.
├── add.c
├── div.c
├── include
│   └── head.h
├── main.c
├── mult.c
└── sub.c
```

> 第一步：使用 gcc 将源文件进行汇编 (参数-c), 生成与位置无关的目标文件，需要使用参数 -fpic或者-fPIC

```
# 1. 将.c汇编得到.o, 需要额外的参数 -fpic/-fPIC
$ gcc add.c div.c mult.c sub.c -c -fpic -I ./include/

# 查看目录文件信息, 检查是否生成了目标文件
$ tree
.
├── add.c
├── add.o                # 生成的目标文件
├── div.c
├── div.o                # 生成的目标文件
├── include
│   └── head.h
├── main.c
├── mult.c
├── mult.o               # 生成的目标文件
├── sub.c
└── sub.o                # 生成的目标文件
```

> 第二步：使用 gcc 将得到的目标文件打包生成动态库，需要使用参数 -shared

```
# 2. 将得到 .o 打包成动态库, 使用gcc , 参数 -shared
$ gcc -shared add.o div.o mult.o sub.o -o libcalc.so  

# 检查目录中是否生成了动态库
$ tree
.
├── add.c
├── add.o
├── div.c
├── div.o
├── include
│   └── `head.h   ===> 和动态库一起发布
├── `libcalc.so   ===> 生成的动态库
├── main.c
├── mult.c
├── mult.o
├── sub.c
└── sub.o
```

> 第三步：发布生成的动态库和相关的头文件

```
# 3. 发布库文件和头文件
	1. head.h
	2. libcalc.so
```

### 动态库的使用

> 当我们得到了一个可用的动态库之后，需要将其放到一个目录中，然后根据得到的头文件编写测试代码，对动态库中的函数进行调用。

```
# 1. 拿到发布的动态库
	`head.h   libcalc.so
# 2. 基于头文件编写测试程序, 测试动态库中提供的接口是否可用
	`main.c`
# 示例目录:
.
├── head.h          ==> 函数声明
├── libcalc.so      ==> 函数定义
└── main.c          ==> 函数测试
```

> 编译测试程序

```
# 3. 编译测试程序
$ gcc main.c -o app
/tmp/ccwlUpVy.o: In function `main':
main.c:(.text+0x38): undefined reference to `add'
main.c:(.text+0x58): undefined reference to `subtract'
main.c:(.text+0x78): undefined reference to `multiply'
main.c:(.text+0x98): undefined reference to `divide'
collect2: error: ld returned 1 exit status
```

> 错误原因:
>
> 和使用静态库一样，在编译的时候需要指定库相关的信息: 库的路径 -L 和 库的名字 -l

添加库信息相关参数，重新编译测试代码:

```
# 在编译的时候指定动态库相关的信息: 库的路径 -L, 库的名字 -l
$ gcc main.c -o app -L./ -lcalc

# 查看是否生成了可执行程序
$ tree
.
├── app 			# 生成的可执行程序
├── head.h
├── libcalc.so
└── main.c

# 执行生成的可执行程序, 错误提示 ==> 可执行程序执行的时候找不到动态库
$ ./app 
./app: error while loading shared libraries: libcalc.so: cannot open shared object file: No such file or directory
```

> 关于整个操作过程的报告：
>
>  gcc 通过指定的动态库信息生成了可执行程序，但是可执行程序运行却提示无法加载到动态库。



### 解决动态库无法加载的问题

#### 库的工作原理

##### 静态库如何被加载

- 在程序编译的最后一个阶段也就是链接阶段，提供的静态库会被打包到可执行程序中。当可执行程序被执行，静态库中的代码也会一并被加载到内存中，因此不会出现静态库找不到无法被加载的问题。


##### 动态库如何被加载

1. 在程序编译的最后一个阶段也就是链接阶段：


- 在 gcc 命令中虽然指定了库路径 (使用参数 -L ), 但是这个路径并没有记录到可执行程序中，只是检查了这个路径下的库文件是否存在。

- 同样对应的动态库文件也没有被打包到可执行程序中，只是在可执行程序中记录了库的名字。

2. 可执行程序被执行起来之后:

- 程序执行的时候会先检测需要的动态库是否可以被加载，加载不到就会提示上边的错误信息
- *当动态库中的函数在程序中被调用了, 这个时候动态库才加载到内存，如果不被调用就不加载*
- 动态库的检测和内存加载操作都是由动态连接器来完成的

#### 动态链接器

> 动态链接器是一个独立于应用程序的进程，属于操作系统，当用户的程序需要加载动态库的时候动态连接器就开始工作了，很显然动态连接器根本就不知道用户通过 gcc 编译程序的时候通过参数 -L 指定的路径。
>
> 那么动态链接器是如何搜索某一个动态库的呢，在它内部有一个默认的搜索顺序，按照优先级从高到低的顺序分别是：

1. 可执行文件内部的 DT_RPATH 段

2. 系统的环境变量 LD_LIBRARY_PATH

3. 系统动态库的缓存文件 /etc/ld.so.cache

4. 存储动态库 / 静态库的系统目录 /lib/, /usr/lib 等


按照以上四个顺序，依次搜索，找到之后结束遍历，最终还是没找到，动态连接器就会提示动态库找不到的错误信息。

#### 解决方案

> 可执行程序生成之后，根据动态链接器的搜索路径，我们可以提供三种解决方案，我们只需要将动态库的路径放到对应的环境变量或者系统配置文件中，同样也可以将动态库拷贝到系统库目录（或者是将动态库的软链接文件放到这些系统库目录中）。
>

##### 方案 1: 

将库路径添加到环境变量 LD_LIBRARY_PATH 中

1. 找到相关的配置文件

- 用户级别: ~/.bashrc —> 设置对当前用户有效
- 系统级别: /etc/profile —> 设置对所有用户有效

2. 使用 vim 打开配置文件，在文件最后添加这样一句话

```
# 自己把路径写进去就行了
export LIBRARY_PATH=$LIBRARY_PATH:动态库的绝对路径
```

3. 让修改的配置文件生效

- 修改了用户级别的配置文件，关闭当前终端，打开一个新的终端配置就生效了

- 修改了系统级别的配置文件，注销或关闭系统，再开机配置就生效了

- 不想执行上边的操作，可以执行一个命令让配置重新被加载：

```
# 修改的是哪一个就执行对应的那个命令
# source 可以简写为一个 . , 作用是让文件内容被重新加载
$ source ~/.bashrc          (. ~/.bashrc)
$ source /etc/profile       (. /etc/profile)
```

***source 可以简写为一个 . , 作用是让文件内容被重新加载***

##### 方案 2: 

更新 `/etc/ld.so.cache` 文件：

1. 找到动态库所在的绝对路径（不包括库的名字）比如：`/home/robin/Library/`

2. 使用 vim 修改 `/etc/ld.so.conf` 这个文件，将上边的路径添加到文件中 (独自占一行)


```
# 1. 打开文件
$ sudo vim /etc/ld.so.conf

# 2. 添加动态库路径, 并保存退出
```

3. 更新 /etc/ld.so.conf 中的数据到 /etc/ld.so.cache 中

```
# 必须使用管理员权限执行这个命令
$ sudo ldconfig   
```

##### 方案 3: 

拷贝动态库文件到系统库目录 /lib/ 或者 /usr/lib 中 (或者将库的软链接文件放进去)

```
# 库拷贝
sudo cp /xxx/xxx/libxxx.so /usr/lib

# 创建软连接
sudo ln -s /xxx/xxx/libxxx.so /usr/lib/libxxx.so
```

#### 验证

> 在启动可执行程序之前，或者在设置了动态库路径之后，我们可以通过一个命令检测程序能不能够通过动态链接器加载到对应的动态库，这个命令叫做 *ldd*

```
# 语法:
$ ldd 可执行程序名

# 举例:
$ ldd app
	linux-vdso.so.1 =>  (0x00007ffe8fbd6000)
    libcalc.so => /home/robin/Linux/3Day/calc/test/libcalc.so (0x00007f5d85dd4000)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5d85a0a000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f5d85fd6000)  ==> 动态链接器, 操作系统提供
```

## 优缺点

### 静态库

优点：

- 静态库被打包到应用程序中加载速度快

- 发布程序无需提供静态库，移植方便

缺点：

- 相同的库文件数据可能在内存中被加载多份，消耗系统资源，浪费内存

- 库文件更新需要重新编译项目文件，生成新的可执行程序，浪费时间。

![img](https://img.herrluk.icu/typoraPicture/2022-12-02-16:43:31.png)

### 动态库

优点：

- 可实现不同进程间的资源共享

- 动态库升级简单，只需要替换库文件，无需重新编译应用程序
- 程序猿可以控制何时加载动态库，不调用库函数动态库不会被加载

缺点：

- 加载速度比静态库慢，以现在计算机的性能可以忽略

- 发布程序需要提供依赖的动态库

![img](https://img.herrluk.icu/typoraPicture/2022-12-02-16:43:25.png)




# Makefile

使用 GCC 的命令行进行程序编译在单个文件下是比较方便的，当工程中的文件逐渐增多，甚至变得十分庞大的时候，使用 GCC 命令编译就会变得力不从心。这种情况下我们需要借助项目构造工具 make 帮助我们完成这个艰巨的任务。 make 是一个命令工具，是一个解释 makefile 中指令的命令工具，一般来说，大多数的 IDE 都有这个命令，比如：Visual C++ 的 nmake，QtCreator 的 qmake 等。

make 工具在构造项目的时候需要加载一个叫做 makefile 的文件，makefile 关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，makefile 定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 makefile 就像一个 Shell 脚本一样，其中也可以执行操作系统的命令。

makefile 带来的好处就是 ——“自动化编译”，一旦写好，只需要一个 make 命令，整个工程完全自动编译，极大的提高了软件开发的效率。

makefile 文件有两种命名方式 makefile 和 Makefile，构建项目的时候在哪个目录下执行构建命令 make 这个目录下的 makefile 文件就会别加载，因此在一个项目中可以有多个 makefile 文件，分别位于不同的项目目录中。

## 规则

Makefile 的框架是由规则构成的。make 命令执行时先在 Makefile 文件中查找各种规则，对各种规则进行解析后运行规则。规则的基本格式为：

```
# 每条规则的语法格式:
target1,target2...: depend1, depend2, ...
	command
	......
	......
```

每条规则由三个部分组成分别是目标(target), 依赖(depend) 和命令(command)。

- 命令(command): 当前这条规则的动作，一般情况下这个动作就是一个 shell 命令

  例如：通过某个命令编译文件、生成库文件、进入目录等。
  动作可以是多个，每个命令前必须有一个Tab缩进并且独占占一行。

- 依赖(depend): 规则所必需的依赖条件，在规则的命令中可以使用这些依赖。

  - 例如：生成可执行文件的目标文件（*.o）可以作为依赖使用

  - 如果规则的命令中不需要任何依赖，那么规则的依赖可以为空

  - 当前规则中的依赖可以是其他规则中的某个目标，这样就形成了规则之间的嵌套
  - 依赖可以根据要执行的命令的实际需求，指定很多个

- 目标(target)： 规则中的目标，这个目标和规则中的命令是对应的

  - 通过执行规则中的命令，可以生成一个和目标同名的文件


  - 规则中可以有多个命令，因此可以通过这多条命令来生成多个目标，所有目标也可以有很多个

  - 通过执行规则中的命令，可以只执行一个动作，不生成任何文件，这样的目标被称为伪目标

关于上面的解释可能有些晦涩，下面通过一个例子来阐述一下:

```
# 举例: 有源文件 a.c b.c c.c head.h, 需要生成可执行程序 app
################# 例1 #################
app:a.c b.c c.c
	gcc a.c b.c c.c -o app

################# 例2 #################
# 有多个目标, 多个依赖, 多个命令
app,app1:a.c b.c c.c d.c
	gcc a.c b.c -o app
	gcc c.c d.c -o app1
	
################# 例3 #################	
# 规则之间的嵌套
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
# a.o 是第一条规则中的依赖
a.o:a.c
	gcc -c a.c
# b.o 是第一条规则中的依赖
b.o:b.c
	gcc -c b.c
# c.o 是第一条规则中的依赖
c.o:c.c
	gcc -c c.c
```

## 工作原理

在此主要为大家剖析一下通过提供的 makefile 文件，构建工具 make 什么时候编译项目中的所有文件，什么时候只选择更新项目中的某几个文件。另外再研究一下如果 makefile 里边有多个规则它们之间是如何配合工作的，我们基于下边的例子，依次进行讲解。

### 规则的执行

在调用 make 命令编译程序的时候，make 会首先找到 Makefile 文件中的第 1 个规则，分析并执行相关的动作。但是需要注意的是，好多时候要执行的动作（命令）中使用的依赖是不存在的，如果使用的依赖不存在，这个动作也就不会被执行。

对应的解决方案是先将需要的依赖生成出来，我们就可以在 makefile 中添加新的规则，将不存在的依赖作为这个新的规则中的目标，当这条新的规则对应的命令执行完毕，对应的目标就被生成了，同时另一条规则中需要的依赖也就存在了。

这样，makefile 中的某一条规则在需要的时候，就会被其他的规则调用，直到 makefile 中的第一条规则中的所有的依赖全部被生成，第一条规则中的命令就可以基于这些依赖生成对应的目标，make 的任务也就完成了。

```
# makefile
# 规则之间的嵌套
# 规则1
app:a.o b.o c.o
	gcc a.o b.o c.o -o app
# 规则2
a.o:a.c
	gcc -c a.c
# 规则3
b.o:b.c
	gcc -c b.c
# 规则4
c.o:c.c
	gcc -c c.c

```

在这个例子中，如果执行 make 命令就会根据这个 makefile 中的 4 条规则编译这三个源文件。在解析第一条规则的时候发现里边的三个依赖都是不存在的，因此规则对应的命令也就不能被执行。

当依赖不存在的时候，make 就是查找其他的规则，看哪一条规则是用来生成需要的这个依赖的，找到之后就会执行这条规则中的命令。因此规则 2， 规则 3， 规则 4 里的命令会相继被执行，当规则 1 中依赖全部被生成之后对应的命令也就被执行了，因此规则 1 的目标被生成，make 工作结束。

知识点拓展:

如果想要执行 makefile 中非第一条规则对应的命令，那么就不能直接 make, 需要将那条规则的目标也写到 make 的后边，比如只需要执行规则 3 中的命令，就需要: make b.o。