# 0x00 Go语言基础之变量和常量

描述: 变量和常量是编程中必不可少的部分，也是很好理解的一部分。

## 1.标识符和关键字

### 标识符

描述: 在编程语言中标识符就是程序员定义的具有特殊意义的词，比如`变量名、常量名、函数名`等等。 Go语言中标识符由字母数字和\_(下划线）组成，并且只能以字母和_开头。 举几个例子：`abc, _, _123, a123`。

编程语言中常用的三种命名规则，而Go语言推荐使用驼峰法式命名。

```
# 下划线连接
student_name

# 小驼峰法式 (推荐方式)
studentName

# 大驼峰法式
StudentName
```



### 2.关键字

描述: 关键字是指编程语言中预先定义好的具有特殊含义的标识符。 关键字和保留字都不建议用作变量名。

- Go语言中有25个关键字:

```
* var const ：     变量和常量的声明
* var varName type  或者 varName : = value
* package and import: 导入
* func：   用于定义函数和方法
* return ：用于从函数返回
* defer someCode ：在函数退出之前执行
* go :      用于并行
* select    用于选择不同类型的通讯
* interface 用于定义接口
* struct    用于定义抽象数据类型
* break、case、continue、for、fallthrough、else、if、switch、goto、default 流程控制
* chan  用于channel通讯
* type  用于声明自定义类型
* map   用于声明map类型数据
* range 用于读取slice、map、channel数据
```

- 此外 Go语言中还有37个保留字。

```go
# Constants: 
true  false  iota  nil

# Types:    
int  int8  int16  int32  int64  
uint  uint8  uint16  uint32  uint64  uintptr
float32  float64  complex128  complex64
bool  byte  rune  string  error

# Functions:   
make  len  cap  new  append  copy  close  delete
complex  real  imag
panic  recover
```

## 2.变量-Var

 Go语言中的每一个变量都有自己的类型，并且变量必须经过声明才能开始使用。

### 全局变量

函数外定义的变量叫全局变量，以下是全局变量的定义方法。

- 方法1

```
var name type = value
```

- 方法2：注意，全局变量如果采用这个方式定义，那不能在全局范围内赋值，只能在函数体内给这个全局变量赋值

```go
var name type // value will be defaulted to 0, false, "" based on the type

/* 如果定义上面的全局变量，就不能紧接着在下一行通过name=value的方式对变量name做赋值，
比如name = 10，会编译报错：
 syntax error: non-declaration statement outside function body
*/
```

- 方法3

```
var name = value 
```

- 方法4

```go
var (
	v1 int = 10
	v2 bool = true
)
var (
	v5 int   // the value will be defaulted to 0
	v6 bool  // the value will be defaulted to false
)
var (
	v3 = 20
	v4 = false
)
```

- **全局变量允许声明后不使用**，编译不会报错。

### 局部变量

函数内定义的变量叫局部变量。

- 和全局变量的定义相比，多了以下定义方法

  - 方法5

  ```
  name := value
  ```

  - 方法6

    ```
    var name type
    name = value
    ```

- **局部变量定义后必须要被使用，否则编译报错**，报错内容为`declared but not used`。

### 多变量定义：

一次声明和定义多个变量

- 全局变量

  - 方法1

    ```
    var a, b, c int = 1, 2, 3
    ```

  - 方法2

    ```
    var a, b, c bool
    ```

  - 方法3

    ```
    var a, b, c = 1, 2, "str"
    ```

- 局部变量：和全局变量相比，多了以下定义方法

  - 方法4

    ```
    var a, b int
    a, b = 1, 2
    
    var c, d int
    c = 10
    d = 20
    ```

  - 方法5

    ```
    a, b := 1, 2
    a1, b1 := 1, "str"
    ```

### 变量类型及其零值

- 零值：英文叫 zero vaue，没有显式初始化的变量，Go编译器会给一个默认值，也叫零值。

- 数值：所有数值类型的零值都是0

  - 整数，零值是0。byte, rune, uintptr也是整数类型，所以零值也是0。
  - 浮点数，零值是0
  - 复数，零值是0+0i

- bool，零值是false

- 字符串，零值是空串""

- 指针：var a *int，零值是nil

  ```
  num := 100
  var a * int = &num
  ```

- 切片：var a []int，零值是nil

  ```
  var a []int = []int{1,2}
  list := [6]int{1,2} //size为6的数组，前面2个元素是1和2，后面的是默认值0
  ```

- map：var a map[string] int，零值是nil

  ```
  dict := map[string] int{"a":1, "b":2}
  ```

- 函数：var a func(string) int，零值是nil

  ```
  function := func(str string) string {
    return str
  }
  result := function("hello fans")
  fmt.Println("result=", result)
  ```

- channel：var a chan int，通道channel，零值是nil

  ```
  var a chan int = make(chan int)
  var b = make(chan string)
  c := make(chan bool)
  ```

- 接口：var a interface_type，接口interface，零值是nil

  ```
  type Animal interface {
    speak()
  }
  
  type Cat struct {
    name string
    age int
  }
  
  func(cat Cat) speak() {
    fmt.Println("miao...")
  }
  
  // 定义一个接口变量a
  var a Animal = Cat{"gaffe", 1}
  a.speak() // miao...
  ```

- 结构体: var instance StructName，结构体里每个field的零值是对应field的类型的零值

  ```
  type Circle struct {
    radius float64
  }
  
  var c1 Circle
  c1.radius = 10.00
  ```

### 变量声明

> 答: Go语言中的变量需要声明后才能使用，同一作用域内不支持重复声明。

Go语言有四个主要的声明：`变量（var）`、`常量（const）`、`类型（type）`、`函数（func）`

Go语言的变量声明标准格式为：`var 变量名 变量类型`

```
# 单一声明: 变量声明以关键字var开头，变量类型放在变量的后面，行尾无需分号。
var name string
var age int
var isOk bool

# 批量声明: 每声明一个变量就需要写var关键字会比较繁琐，go语言中还支持批量变量声明。
var (
  a string
  b int
  c bool
  d float32
)
```



#### 变量初始化

Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。**Go里不存在未初始化的变量。**每个变量会被初始化成其类型的默认值,或者我们也可在声明变量的时候为其指定初始值。例如：

- 整型和浮点型变量的默认值为0。
- 字符串变量的默认值为空字符串。
- 布尔型变量默认为false。
- 接口和引用类型（切片slice、map、通道、函数、指针）的默认为nil。

变量初始化的标准格式如下：`var 变量名 类型 = 表达式`

```
//# 单一变量初始化
var name string = "WeiyiGeek"
var age int = 18

//# 批量变量初始化
var name, age = "WeiyiGeek", 20
```



**类型推导**
描述: 有时候我们会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化。

```
var name = "WeiyiGeek"
var age = 18
```



**短变量声明**
描述: 在**函数内部**可以使用更简略的`:=`方式声明并初始化变量。

```
func main() {
  count := 10
  username := "WeiyiGeek"
}
```



#### 匿名变量

描述: 在使用多重赋值时，如果想要`忽略某个值`，可以使用`匿名变量（anonymous variable）- 特殊变量`。并且匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。 (`在Lua等编程语言里，匿名变量也被叫做哑元变量。`)

匿名变量用一个`下划线(_)`表示，例如：

```go
func foo() (int, string) {
  return 10, "Q1mi"
}
func main() {
  x, _ := foo()
  _, y := foo()
  fmt.Println("x=", x)
  fmt.Println("y=", y)
}
```

Tips : Go语言中变量必须先声明后使用，而且声明变量`(非全局变量)`后必须使用，如有不使用的变量编译时报错。

Tips ：函数外的每个语句都必须以关键字开始 (`var、const、func`) 等

Tips : `:=`不能使用在函数外。

## 4.常量 - Const

描述:常量是在程序运行期间恒定不变的值，多用于定义程序运行期间不会改变的那些值。常量的声明和变量声明非常类似，只是`把var换成了const`，常量在定义的时候必须赋值。

常量声明初始化格式:

```go
// 单一声明: 声明了pi和e这两个常量之后，在整个程序运行期间它们的值都不能再发生变化了。
const pi = 3.1415
const e = 2.7182

// 批量声明
const (
  pi = 3.1415
  e = 2.7182
)

//多个常量同时定义
const a, b int = 1, 2

// 批量声明（如果省略了值则表示和上面一行的值相同）
// 常量n1、n2、n3的值都是100。
const (
  n1 = 100
  n2
  n3
)
```



#### iota - 常量计数器

描述: iota是go语言的常量计数器，只能在常量的表达式中使用。

Tips : iota在const关键字出现时将被重置为0, const中每新增一行常量声明将使iota计数一次 (`iota可理解为const语句块中的行索引`)。

应用场景: 使用iota能简化定义，在定义枚举时很有用。

下面示例中几个常见的iota示例:

- 定义枚举方法1

  ```go
  const (
    unknown = 0
    male = 1
    female = 2
  )
  ```

- 定义枚举方法2

  ```go
  const (
    unknown = iota // the value of unknown is 0
    male // the value of male is 1
    female // the value of female is 2
  )
  const (
    c1 = iota // the value of c1 is 0
    c2 = iota // the value of c2 is 1
    c3 = iota // the value of c3 is 2
  )
  ```

- 注意事项

  - iota的值是const语句块里的行索引，行索引从0开始
  - const语句块里，如果常量没赋值，那它的值和上面的保持一样，比如下面的例子里class2=0, class6="abc"
  - 某个常量赋值为iota后，**紧随其后**的常量如果没赋值，那后面常量的值是自动+1，比如下面的例子里，class3的值是iota，该行的行索引是2，所以class3=2， class4常量紧随其后没有赋值，那class4=class3+1=3

  ```go
  const (
  	class1 = 0
  	class2 // class2 = 0
  	class3 = iota  //iota is 2, so class3 = 2
  	class4 // class4 = 3
  	class5 = "abc" 
  	class6 // class6 = "abc"
  	class7 = iota // class7 is 6
  )
  ```

- 1.使用`_`跳过某些值

```go
const (
  n1 = iota //0
  n2        //1
  _
  n4        //3
)
```

- 2.iota声明中间插队

```go
const (
  n1 = iota //0
  n2 = 100  //100
  n3 = iota //2
  n4        //3
)
const n5 = iota //0
```

- 3.多个iota定义在一行

```go


const (
  a, b = iota + 1, iota + 2 //1,2
  c, d                      //2,3
  e, f                      //3,4
)
```

接下来的两个常量`c`和`d`未分配任何值，因此它们的值取自先前使用的表达式`iota`，即`iota + 1`。因此，`c`赋值为`iota + 1`即2，`d`赋值为`iota + 2`即3。

- 4.定义数量级 （这里的<<表示左移操作，1<<10表示将1的二进制表示向左移10位，也就是由1变成了10000000000，也就是十进制的1024。同理2<<2表示将2的二进制表示向左移2位，也就是由10变成了1000，也就是十进制的8。）

```go
const (
  _  = iota
  KB = 1 << (10 * iota)
  MB = 1 << (10 * iota)
  GB = 1 << (10 * iota)
  TB = 1 << (10 * iota)
  PB = 1 << (10 * iota)
)
```

------

# 0x01 Go语言基础之基本数据类型

Go 的数据类型分四大类:

基础类型(basic type)：包括数字(number)、字符串(string)和布尔型( boolean)

聚合类型(aggregate type)：数组（array）和结构体( struct）

引用类型(reference type)：引用是一大分类，其中包含多种不同类型，如指针（ pointer)，slice,map，函数( function)，以及通道（channel)

接口类型(interface type)

- **reflect包的`TypeOf`函数或者`fmt.Printf`的`%T`可以用来获取变量的类型**

  ```go
  var b byte = 10
  var c = 'a'
  fmt.Println(reflect.TypeOf(b)) // uint8
  fmt.Println(reflect.TypeOf(c)) // int32
  fmt.Printf("%T\n", c) // int32
  ```

### 1.整型

整型分为以下两个大类： 按长度分为：`int8、int16、int32、int64` 对应的无符号整型：`uint8、uint16、uint32、uint64`

其中，`uint8`就是我们熟知的`byte`型，`int16`对应C语言中的`short`型，`int64`对应C语言中的`long`型。

| 类型   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| uint8  | 无符号 8位整型 (0 到 255)                                    |
| uint16 | 无符号 16位整型 (0 到 65535)                                 |
| uint32 | 无符号 32位整型 (0 到 4294967295)                            |
| uint64 | 无符号 64位整型 (0 到 18446744073709551615)                  |
| int8   | 有符号 8位整型 (-128 到 127)                                 |
| int16  | 有符号 16位整型 (-32768 到 32767)                            |
| int32  | 有符号 32位整型 (-2147483648 到 2147483647)                  |
| int64  | 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) |



#### 特殊整型

| 类型    | 描述                                                   |
| ------- | ------------------------------------------------------ |
| uint    | 32位操作系统上就是`uint32`，64位操作系统上就是`uint64` |
| int     | 32位操作系统上就是`int32`，64位操作系统上就是`int64`   |
| uintptr | 无符号整型，用于存放一个指针                           |

**注意：** 在使用`int`和 `uint`类型时，不能假定它是32位或64位的整型，而是考虑`int`和`uint`可能在不同平台上的差异。

**注意事项：** 获取对象的长度的内建`len()`函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，切片或 map 的元素数量等都可以用`int`来表示。在涉及到二进制传输、读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用`int`和 `uint`。



#### 数字字面量语法（Number literals syntax）

Go1.13版本之后引入了数字字面量语法，这样便于开发者以`二进制、八进制或十六进制浮点数`的格式定义数字，例如：

- `v := 0b00101101`， 代表二进制的 101101，相当于十进制的 45。
- `v := 0o377`，代表八进制的 377，相当于十进制的 255。
- ` v := 0x1p-2`，代表十六进制的 1 除以 2²，也就是 0.25。

而且还允许我们用 `_` 来分隔数字，比如说： `v := 123_456` 表示 v 的值等于 123456。

### 2.浮点型

Go语言支持两种浮点型数：`float32`和`float64`。
这两种浮点型数据格式遵循`IEEE 754`标准：

- `float32` 的浮点数的最大范围约为 `3.4e38`，其常量定义：`math.MaxFloat32`。
- `float64` 的浮点数的最大范围约为 `1.8e308`，其常量定义：`math.MaxFloat64`。

*你应该尽可能地使用 float64，因为 `math` 包中所有有关数学运算的函数都会要求接收这个类型。*

定义时，小数默认为`float64`

简单示例: 打印浮点数时，可以使用`fmt`包配合动词`%f`，代码如下：

```go
package main
import (
    "fmt"
    "math"
)
func main() {
    var floatnumber float64 = 1024.00
  fmt.Printf("数据类型: %T , floatnumber: %.1f\n", floatnumber, floatnumber)
  fmt.Printf("%f,%.2f\n", math.Pi, math.Pi) // 保留小数点后两位
  fmt.Printf("float32的浮点数的最大范围 :%d ~ %f\n", 0, math.MaxFloat32)
  fmt.Printf("float64的浮点数的最大范围 :%d ~ %f\n", 0, math.MaxFloat64)
}
```

执行结果:

```
数据类型: float64 , floatnumber: 1024.0
3.141593,3.14
float32的浮点数的最大范围 :0 ~ 340282346638528859811704183484516925440.000000
float64的浮点数的最大范围 :0 ~ 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.000000
```

小数点前的数字可以省略（`.707`)，后面的也可省去(`1.`)。非常小或非常大的数字最好使用科学记数法表示,此方法在数量级指数前写字母e或E。

浮点值能方便地通过Printf的谓词`%g`输出，该谓词会自动保持足够的精度，并选择简洁的表示方式，但是对于数据表,`%e(有指数)`或`%f(无指数)`的形式可能更合适。这个谓词都能掌控输出宽度和数值精度。

### 3.复数

描述: 复数有实部和虚部，complex64的实部和虚部为32位，complex128的实部和虚部为64位。

例如: complex64和complex128类型变量输出示例

```
var c1 complex64
c1 = 1 + 2i
var c2 complex128
c2 = 2 + 3i
fmt.Println(c1) // (1+2i)
fmt.Println(c2) // (2+3i)
```



### 4.布尔值

Go语言中以`bool`类型进行声明布尔型数据，布尔型数据只有`true（真）`和`false（假）`两个值。

```
fmt.Println("# 4.布尔型示例:")
var flag bool = true
fmt.Printf("数据类型: %T ,任意类型输出: %v", flag, flag)  // 数据类型: bool ,任意类型输出: true
```

**注意：**

1. 布尔类型变量的默认值为`false`。
2. Go 语言中不允许将整型强制转换为布尔型.
3. 布尔型无法参与数值运算，也无法与其他类型进行转换。



## 5.字符串

描述: Go语言中的字符串`以原生数据类型`出现，使用字符串就像使用其他原生数据类型（int、bool、float32、float64 等）一样。
Go 语言里的字符串的内部实现使用`UTF-8`编码。 字符串的值为`双引号(")`中的内容，可以在Go语言的源码中直接添加非ASCII码字符，例如：

```
s1 := "hello"
s2 := "你好"
c1 := 'g'
c2 := 'o'
```

Tips : Go 语言中用双引号包裹的是`字符串`，而单引号包裹的是`字符`。

字符串的第i个字节不一定就是第i个字符，因为**非 ASCII字符的UTF-8码点需要两个字节或多个字节**。

**注意**：string是**immutable**的，不能在初始化string变量后，修改string里的值，除非对string变量重新赋值

- string可以用`+`做字符串拼接

  ```
  // string5.go
  package main
  
  import "fmt"
  
  func main() {
  	a := "ch"
  	b := "ina"
  	c := a + b
  	fmt.Println(c) // china
  }
  ```

### 字符串的遍历

- 字符串里字符的访问可以通过str[index]下标索引或者range迭代的方式进行访问

  ```go
  package main
  
  import "fmt"
  
  func main() {
      str := "abc"
      /*下标访问*/
      size := len(str)
      for i:=0; i<size; i++ {
          fmt.Printf("%d ", str[i])
      }
      fmt.Println()
      
      /*range迭代访问*/
      for _, value := range str {
          fmt.Printf("%d ", value)
      }
      fmt.Println()
  }
  ```

- 不能对string里的某个字符取地址：如果s[i]是字符串s里的第i个字符，那&s[i]这种方式是非法的

  ```go
  // string3.go
  package main
  
  import "fmt"
  
  func main() {
  	str := "abc"
  	/*
  	the following code has compile error:
  	cannot take the address of str[0]
  	*/
  	fmt.Println(&str[0])
  }
  ```

#### 字符串转义符

Go 语言的字符串常见转义符包含回车、换行、单双引号、制表符等，如下表所示。

| 转义符 | 含义                               |
| ------ | ---------------------------------- |
| `\a`   | 警告或响铃                         |
| `\b`   | 退格符                             |
| `\f`   | 换页符                             |
| `\r`   | 回车符（返回行首）                 |
| `\n`   | 换行符（直接跳到下一行的同列位置） |
| `\t`   | 制表符                             |
| `\v`   | 垂直制表符                         |
| `\'`   | 单引号                             |
| `\"`   | 双引号                             |
| `\\`   | 反斜杠                             |

举个例子，我们要打印一个Windows平台下的一个文件路径：

```go
package main
import (
    "fmt"
)
func main() {
  s1 := "'c:\\weiyigeek\\go\\hello'"
    fmt.Println("str :=",s1)
    fmt.Println("str := \"c:\\Code\\weiyigeek\\go.exe\"")
}
```

源码中的字符串也可以包含十六进制或八进制的任意字节。

十六进制的转义字符写成`\xhh`的形式，h是十六进制数字(大小写皆可)，且必须是两位。

八进制的转义字符写成`\ooo`的形式，必须使用三位八进制数字（0～7)，且不能超过`\377`。

这两者都表示单个字节，内容是给定值。

#### 多行字符串

Go语言中要定义一个多行字符串时，就必须使用`反引号`字符：

```
s1 := `第一行
第二行
第三行
`
s2 := `c:\weiyigeek\go\hello`  // 注意点此处没用转义符(\) 也能输出路径

fmt.Println(s1,s2)
```

*Tips: 反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出。*

#### 字符串拼接

1.字符串拼接方式：

```go
var str = "hello" + "world"
str += "haha!"
```

2.拼接操作很长时：可以分行写，***但是要注意加号（+）必须留在上一行***

```go
//正确
var str = "hello" + "world"+
		"hello" + "world"+"hello" + "world"
```

否则会报错：

![image-20220418231049400](https://img.herrluk.icu/typoraPicture/image-20220418231049400-16502946516661.png)

**因为go默认在行尾加上分号（ ; ）当末尾出现加号（+）时，就不加**。

*在循环中使用加号 `+` 拼接字符串并不是最高效的做法，更好的办法是使用函数 `strings.Join()`，有没有更好地办法了？有！使用字节缓冲（`bytes.Buffer`）拼接更加给力！*

#### 字符串的常用操作

| 方法                                | 介绍           |
| ----------------------------------- | -------------- |
| len(str)                            | 求长度         |
| +或fmt.Sprintf                      | 拼接字符串     |
| strings.Split                       | 分割           |
| strings.Contains                    | 判断是否包含   |
| strings.HasPrefix,strings.HasSuffix | 前缀/后缀判断  |
| strings.Index(),strings.LastIndex() | 子串出现的位置 |
| strings.Join(a[]string, sep string) | join操作，拼接 |

- 统计字符串的长度，按字节 `len(str)`

- 字符串遍历，同时处理有中文的问题 `r := []rune(str)`

```go
func main() {
	str2 := "hello北京"
	r := []rune(str2)
	for i := 0; i < len(r); i++ {
		fmt.Printf("字符=%c\n", r[i])
	}
}
```

输出：

```
字符=h
字符=e
字符=l
字符=l
字符=o
字符=北
字符=京

```

- 字符串转整数:	`n, err := strconv.Atoi("12")`（Atoi 的 A 是 ASCII的意思）

```go
func main() {
	n, err := strconv.Atoi("Hello")
	if err != nil {
		fmt.Println("转换错误", err)
	} else {
		fmt.Println("转换成的结果是：", n)
	}
}
```

输出：

```
转换错误 strconv.Atoi: parsing "Hello": invalid syntax
```

- 整数转字符串	`str = strconv.Itoa(12345)`

- 字符串转`[]byte`:	`var bytes = []byte("hello go")`

- `[]byte` 转字符串: `str = string([]byte{97, 98, 99})`

- 10 进制转 2, 8, 16 进制:`str = strconv.FormatInt(123, 2)` // 2-> 8 , 16

- 查找子串是否在指定的字符串中: `strings.Contains("seafood", "foo")` //true

- 统计一个字符串有几个指定的子串 ：` strings.Count("ceheese", "e")`//4

- 不区分大小写的字符串比较(== 是区分字母大小写的): `fmt.Println(strings.EqualFold("abc", "Abc"))` // true

- 返回子串在字符串第一次出现的 index 值，如果没有返回-1 : `strings.Index("NLT_abc", "abc") // 4`

- 返回子串在字符串最后一次出现的 index，如没有返回-1 ：`strings.LastIndex("go golang", "go")`

- 将指定的子串替换成 另外一个子串: 

  `strings.Replace("go go hello", "go", "go 语言", n)` // n 可以指定你希望替换几个，如果` n=-1` 表示全部替换

- 按 照 指 定 的 某 个 字 符 ， 为 分 割 标 识 ， 将 一 个 字 符 串 拆 分 成 字 符 串 数 组 ：`strings.Split("hello,wrold,ok", ",")`

- 将字符串的字母进行大小写的转换: `strings.ToLower("Go")` // go `strings.ToUpper("Go")` // GO

- 16)将字符串左右两边的空格去掉： `strings.TrimSpace(" tn a lone gopher ntrn	")`

- 将字符串左右两边指定的字符去掉 ： `strings.Trim("! hello! ", " !")`	// ["hello"] //将左右两边 ! 和 "  "去掉

- 将字符串左边指定的字符去掉 ：` strings.TrimLeft("! hello! ", " !")`	// ["hello"] //将左边 ! 和 " "去掉

- 将字符串右边指定的字符去掉 ：` strings.TrimRight("! hello! ", " !")`	// ["hello"] //将右边 ! 和 ""去掉

- 判断字符串是否以指定的字符串开头: `strings.HasPrefix("ftp://192.168.10.1", "ftp") `// true

- 判断字符串是否以指定的字符串结束: `strings.HasSuffix("NLT_abc.jpg", "abc") `//false

#### strings 和 strconv 包

作为一种基本数据结构，每种语言都有一些对于字符串的预定义处理函数。Go 中使用 `strings` 包来完成对字符串的主要操作。

##### 4.7.1 前缀和后缀

`HasPrefix` 判断字符串 `s` 是否以 `prefix` 开头：

```go
strings.HasPrefix(s, prefix string) bool
```

`HasSuffix` 判断字符串 `s` 是否以 `suffix` 结尾：

```go
strings.HasSuffix(s, suffix string) bool
```

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    var str string = "This is an example of a string"
    fmt.Printf("T/F? Does the string \"%s\" have prefix %s? ", str, "Th")
    fmt.Printf("%t\n", strings.HasPrefix(str, "Th"))
}
```

输出：

```php
T/F? Does the string "This is an example of a string" have prefix Th? true
```

这个例子同样演示了转义字符 `\` 和格式化字符串的使用。

##### 4.7.2 字符串包含关系

`Contains` 判断字符串 `s` 是否包含 `substr`：

```php
strings.Contains(s, substr string) bool
```

##### 4.7.3 判断子字符串或字符在父字符串中出现的位置（索引）

`Index` 返回字符串 `str` 在字符串 `s` 中的索引（`str` 的第一个字符的索引），-1 表示字符串 `s` 不包含字符串 `str`：

```go
strings.Index(s, str string) int
```

`LastIndex` 返回字符串 `str` 在字符串 `s` 中最后出现位置的索引（`str` 的第一个字符的索引），-1 表示字符串 `s` 不包含字符串 `str`：

```go
strings.LastIndex(s, str string) int
```

如果 `ch` 是非 ASCII 编码的字符，建议使用以下函数来对字符进行定位：

```go
strings.IndexRune(s string, r rune) int
```

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    var str string = "Hi, I'm Marc, Hi."

    fmt.Printf("The position of \"Marc\" is: ")
    fmt.Printf("%d\n", strings.Index(str, "Marc"))

    fmt.Printf("The position of the first instance of \"Hi\" is: ")
    fmt.Printf("%d\n", strings.Index(str, "Hi"))
    fmt.Printf("The position of the last instance of \"Hi\" is: ")
    fmt.Printf("%d\n", strings.LastIndex(str, "Hi"))

    fmt.Printf("The position of \"Burger\" is: ")
    fmt.Printf("%d\n", strings.Index(str, "Burger"))
}
```

输出：

```php
The position of "Marc" is: 8
The position of the first instance of "Hi" is: 0
The position of the last instance of "Hi" is: 14
The position of "Burger" is: -1
```

##### 4.7.4 字符串替换

`Replace` 用于将字符串 `str` 中的前 `n` 个字符串 `old` 替换为字符串 `new`，并返回一个新的字符串，如果 `n = -1` 则替换所有字符串 `old` 为字符串 `new`：

```go
strings.Replace(str, old, new string, n int) string
```

##### 4.7.5 统计字符串出现次数

`Count` 用于计算字符串 `str` 在字符串 `s` 中出现的非重叠次数：

```go
strings.Count(s, str string) int
```

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    var str string = "Hello, how is it going, Hugo?"
    var manyG = "gggggggggg"

    fmt.Printf("Number of H's in %s is: ", str)
    fmt.Printf("%d\n", strings.Count(str, "H"))

    fmt.Printf("Number of double g's in %s is: ", manyG)
    fmt.Printf("%d\n", strings.Count(manyG, "gg"))
}
```

输出：

```php
Number of H's in Hello, how is it going, Hugo? is: 2
Number of double g’s in gggggggggg is: 5
```

##### 4.7.6 重复字符串

`Repeat` 用于重复 `count` 次字符串 `s` 并返回一个新的字符串：

```go
strings.Repeat(s, count int) string
```

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    var origS string = "Hi there! "
    var newS string

    newS = strings.Repeat(origS, 3)
    fmt.Printf("The new repeated string is: %s\n", newS)
}
```

输出：

```php
The new repeated string is: Hi there! Hi there! Hi there!
```

##### 4.7.7 修改字符串大小写

`ToLower` 将字符串中的 Unicode 字符全部转换为相应的小写字符：

```go
strings.ToLower(s) string
```

`ToUpper` 将字符串中的 Unicode 字符全部转换为相应的大写字符：

```go
strings.ToUpper(s) string
```

示例 4.17 [toupper_lower.go](https://learnku.com/docs/the-way-to-go/strings-and-strconv-packages/examples/chapter_4/toupper_lower.go)

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    var orig string = "Hey, how are you George?"
    var lower string
    var upper string

    fmt.Printf("The original string is: %s\n", orig)
    lower = strings.ToLower(orig)
    fmt.Printf("The lowercase string is: %s\n", lower)
    upper = strings.ToUpper(orig)
    fmt.Printf("The uppercase string is: %s\n", upper)
}
```

输出：

```php
The original string is: Hey, how are you George?
The lowercase string is: hey, how are you george?
The uppercase string is: HEY, HOW ARE YOU GEORGE?
```

##### 4.7.8 修剪字符串

你可以使用 `strings.TrimSpace(s)` 来剔除字符串开头和结尾的空白符号；如果你想要剔除指定字符，则可以使用 `strings.Trim(s, "cut")` 来将开头和结尾的 `cut` 去除掉。该函数的第二个参数可以包含任何字符，如果你只想剔除开头或者结尾的字符串，则可以使用 `TrimLeft` 或者 `TrimRight` 来实现。

##### 4.7.9 分割字符串

`strings.Fields(s)` 利用空白作为分隔符将字符串分割为若干块，并返回一个 slice 。如果字符串只包含空白符号，返回一个长度为 0 的 slice 。

`strings.Split(s, sep)` 自定义分割符号对字符串分割，返回 slice 。

因为这 2 个函数都会返回 slice，所以习惯使用 for-range 循环来对其进行处理（第 7.3 节）。

##### 4.7.10 拼接 slice 到字符串

`Join` 用于将元素类型为 string 的 slice 使用分割符号来拼接组成一个字符串：

```go
strings.Join(sl []string, sep string) string
```

示例 4.18 [strings_splitjoin.go](https://learnku.com/docs/the-way-to-go/strings-and-strconv-packages/examples/chapter_4/strings_splitjoin.go)

```go
package main

import (
    "fmt"
    "strings"
)

func main() {
    str := "The quick brown fox jumps over the lazy dog"
    sl := strings.Fields(str)
    fmt.Printf("Splitted in slice: %v\n", sl)
    for _, val := range sl {
        fmt.Printf("%s - ", val)
    }
    fmt.Println()
    str2 := "GO1|The ABC of Go|25"
    sl2 := strings.Split(str2, "|")
    fmt.Printf("Splitted in slice: %v\n", sl2)
    for _, val := range sl2 {
        fmt.Printf("%s - ", val)
    }
    fmt.Println()
    str3 := strings.Join(sl2,";")
    fmt.Printf("sl2 joined by ;: %s\n", str3)
}
```

输出：

```php
Splitted in slice: [The quick brown fox jumps over the lazy dog]
The - quick - brown - fox - jumps - over - the - lazy - dog -
Splitted in slice: [GO1 The ABC of Go 25]
GO1 - The ABC of Go - 25 -
sl2 joined by ;: GO1;The ABC of Go;25
```

其它有关字符串操作的文档请参阅 [官方文档](http://golang.org/pkg/strings/)（ **译者注：国内用户可访问 [该页面](http://docs.studygolang.com/pkg/strings/)** ）。

##### 4.7.11 从字符串中读取内容

函数 `strings.NewReader(str)` 用于生成一个 `Reader` 并读取字符串中的内容，然后返回指向该 `Reader` 的指针，从其它类型读取内容的函数还有：

- `Read()` 从 [] byte 中读取内容。
- `ReadByte()` 和 `ReadRune()` 从字符串中读取下一个 byte 或者 rune。

##### 4.7.12 字符串与其它类型的转换

与字符串相关的类型转换都是通过 `strconv` 包实现的。

该包包含了一些变量用于获取程序运行的操作系统平台下 int 类型所占的位数，如：`strconv.IntSize`。

任何类型 **T** 转换为字符串总是成功的。

针对从数字类型转换到字符串，Go 提供了以下函数：

- `strconv.Itoa(i int) string` 返回数字 i 所表示的字符串类型的十进制数。
- `strconv.FormatFloat(f float64, fmt byte, prec int, bitSize int) string` 将 64 位浮点型的数字转换为字符串，其中 `fmt` 表示格式（其值可以是 `'b'`、`'e'`、`'f'` 或 `'g'`），`prec` 表示精度，`bitSize` 则使用 32 表示 float32，用 64 表示 float64。

将字符串转换为其它类型 **tp** 并不总是可能的，可能会在运行时抛出错误 `parsing "…": invalid argument`。

针对从字符串类型转换为数字类型，Go 提供了以下函数：

- `strconv.Atoi(s string) (i int, err error)` 将字符串转换为 int 型。
- `strconv.ParseFloat(s string, bitSize int) (f float64, err error)` 将字符串转换为 float64 型。

利用多返回值的特性，这些函数会返回 2 个值，第 1 个是转换后的结果（如果转换成功），第 2 个是可能出现的错误，因此，我们一般使用以下形式来进行从字符串到其它类型的转换：

```php
val, err = strconv.Atoi(s)
```

在下面这个示例中，我们忽略可能出现的转换错误：

```go
package main

import (
    "fmt"
    "strconv"
)

func main() {
    var orig string = "666"
    var an int
    var newS string

    fmt.Printf("The size of ints is: %d\n", strconv.IntSize)      

    an, _ = strconv.Atoi(orig)
    fmt.Printf("The integer is: %d\n", an) 
    an = an + 5
    newS = strconv.Itoa(an)
    fmt.Printf("The new string is: %s\n", newS)
}
```

输出：

```php
64 位系统：
The size of ints is: 64
32 位系统：
The size of ints is: 32
The integer is: 666
The new string is: 671
```

在第 5.1 节，我们将会利用 if 语句来对可能出现的错误进行分类处理。

### 6.byte和rune类型

描述: 组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：

```
var a = '中'
var b = 'x'
c := 'a'
```

Go 语言的字符有以下两种：

- `uint8`类型，或者叫 byte 型，代表了`ASCII码`的一个字符（1B）。
- `rune`类型，代表一个 `UTF-8字符`, 并且一个rune字符由一个或多个byte组成（3B~4B）汉字占3B。

Tips : 当需要处理中文、日文或者其他复合字符时，则需要用到`rune`类型。`rune`类型实际是一个`int32`。

Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。

简单示例:

```go
// 遍历字符串
func traversalString() {
  s := "hello沙河"
   // byte 类型
  for i := 0; i < len(s); i++ {
    fmt.Printf("%v(%c) ", s[i], s[i])
  }
  fmt.Println()
  // rune 类型
  for _, r := range s { 
    fmt.Printf("%v(%c) ", r, r)
  }
  fmt.Println()
}
```

结果输出：

```
// byte 类型 (中文乱码)
104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) 

// rune 类型 (中文正常)
104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) 
```

**Q: 为什么出现上述情况?**

答: 因为UTF8编码下`一个中文汉字由3~4个字节`（4*8bit）组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。

Tips : 字符串底层是一个byte数组，所以可以和`[]byte`类型相互转换。字符串是不能修改的字符串是由byte字节组成，所以字符串的长度是byte字节的长度。



### 7.类型转换

描述：Go语言中只有强制类型转换，没有隐式类型转换。该语法只能在两个类型之间支持相互转换的时候使用。

强制类型转换的基本语法如下：

```
T(表达式)  # 其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.
```

Tips : Boolen 类型不能强制转换为整型。



**整型转浮点型**

比如：计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。

```
func sqrtDemo() {
  var a, b = 3, 4
  var c int
  // math.Sqrt() 接收的参数是float64类型，需要强制转换
  c = int(math.Sqrt(float64(a*a + b*b)))
  fmt.Println(c)
}
```

Tips : 在Go语言中不同类型的值不能直接赋值，例如float32类型变量a的值不能直接赋值给floa64类型变量b的值。



**字符串类型转换**

描述: 如果修改字符串，需要先将其转换成`[]rune`或`[]byte`，完成后再转换为`string`。无论哪种转换，`都会重新分配内存，并复制字节数组`。

```go
func changeString() {
  s1 := "big"
  // 强制类型转换
  byteS1 := []byte(s1)
  byteS1[0] = 'p'
  fmt.Println(string(byteS1))

  s2 := "白萝卜"
  runeS2 := []rune(s2)
  runeS2[0] = '红'
  fmt.Println(string(runeS2))
}
```

Tips : 在一个字符串中如果既有中文也存在英文，我们则可以使用`byte[]类型`(1B)来存放ASCII码表示的字符(0~255)，如果是中文则使用`rune[]`(4B)类型来存放或者周转。



### 8.获取用户输入

#### func Scanf

```
func Scanf(format string, a ...interface{}) (n int, err error)
```

Scanf 扫描从标准输入中读取的文本，并将连续由空格分隔的值存储为连续的实参， 其格式由 format 决定。它返回成功扫描的条目数。

#### func Scanln

```
func Scanln(a ...interface{}) (n int, err error)
```

Scanln 类似于 Scan，但它在换行符处停止扫描，且最后的条目之后必须为换行符或 EOF。

# 0x02 Go语言基础之运算符

### 1.分类说明

描述: 与其他编程语言类似 Go 语言内置的运算符有如下几种

- 算术运算符
- 关系运算符
- 逻辑运算符
- 位运算符
- 赋值运算符



### 2.算术运算符

| 运算符 | 描述 |
| ------ | ---- |
| +      | 相加 |
| -      | 相减 |
| *      | 相乘 |
| /      | 相除 |
| %      | 求余 |

**注意：**

 *`++`（自增）和`--`（自减）在**Go语言中是单独的语句，并不是运算符。不能放在等号右边***

取模运算符`%`的行为因编程语言而异。就Go而言,***取模余数的正负号总是与被除数一致***，于是-5%3和-5%-3都得-2。

除法运算(`/`)的行为取决于**操作数是否都为整型**。整数相除，商会舍弃小数部分，于是5.0/4.0得到1.25，而5/4结果是1。

### 3.关系运算符

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| ==     | 检查两个值是否相等，如果相等返回 True 否则返回 False。       |
| !=     | 检查两个值是否不相等，如果不相等返回 True 否则返回 False。   |
| >      | 检查左边值是否大于右边值，如果是返回 True 否则返回 False。   |
| >=     | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 |
| <      | 检查左边值是否小于右边值，如果是返回 True 否则返回 False。   |
| <=     | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 |

Tips : Go 语言是强类型的所以必须相同类型变量才能进行比较。全部基本类型的值（布尔值、数值、字符串）都可以比较，许多其他类型的值是不可比较的，也无法排序。



### 4.逻辑运算符

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| &&     | 逻辑 AND 运算符。 如果两边的操作数都是 True，则为 True，否则为 False。 |
| \|\|   | 逻辑 OR 运算符。 如果两边的操作数有一个 True，则为 True，否则为 False。 |
| !      | 逻辑 NOT 运算符。 如果条件为 True，则为 False，否则为 True。 |

同C语言，布尔值可以由运算符&&(AND)以及|(OR)组合运算，这可能引起***短路行为 ：如果运算左边的操作数已经能直接确定总体结果，则右边的操作数不会计算在内，直接输出结果。***

因为`&&`较`||`优先级更高（助记窍门:`&&`表示逻辑乘法，`||`表示逻辑加法），所以有些形式的条件无须加圆括号。

### 5.位运算符

描述: 位运算符对整数在内存中的二进制位进行操作。

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| &      | 参与运算的两数各对应的二进位相与。 （两位均为1才为1）        |
| \|     | 参与运算的两数各对应的二进位相或。 （两位有一个为1就为1）    |
| ^      | 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 （两位不一样则为1） |
| <<     | 左移n位就是乘以2的n次方。 “a<<b”是把a的各二进位全部左移b位，高位丢弃，低位补0。 |
| >>     | 右移n位就是除以2的n次方。 “a>>b”是把a的各二进位全部右移b位。 |

### 6.赋值运算符

| 运算符 | 描述                                           |
| ------ | ---------------------------------------------- |
| =      | 简单的赋值运算符，将一个表达式的值赋给一个左值 |
| +=     | 相加后再赋值                                   |
| -=     | 相减后再赋值                                   |
| *=     | 相乘后再赋值                                   |
| /=     | 相除后再赋值                                   |
| %=     | 求余后再赋值                                   |
| <<=    | 左移后赋值                                     |
| >>=    | 右移后赋值                                     |
| &=     | 按位与后赋值                                   |
| \|=    | 按位或后赋值                                   |
| ^=     | 按位异或后赋值                                 |

**简单示例:**

```
a += 1  // a = a + 1
a %= 3  // a = a % 3
a <<= 4 // a = a << 4 
a ^= 5  // a = a ^ 5
```

只有**单目运算符**和**赋值运算符**是从右向左运算的。比如先算a+1再赋值给左边的a

# 0x03 Go语言基础之流程控制

Tips : Go语言中最常用的流程控制有`if`和`for`，而`switch`和`goto`主要是为了简化代码、降低重复代码而生的结构，属于扩展类的流程控制。

### 1.if else(分支结构)

#### if条件判断基本写法

描述: Go语言中`if`条件判断的格式如下：

```
if 表达式1 {
  分支1
} else if 表达式2 {
  分支2
} else{
  分支3
}
```

当表达式1的结果为`true`时，执行分支1，否则判断表达式2，如果满足则执行分支2，都不满足时，则执行分支3。 if判断中的`else if`和`else`都是可选的，可以根据实际需要进行选择。

Go语言规定与`if`匹配的左括号`{`必须与`if和表达式`放在同一行，`{`放在其他位置会触发编译错误。 同理，与`else`匹配的`{`也必须与`else`写在同一行，`else`也必须与上一个`if`或`else if`右边的大括号在同一行。

示例1:

```
func ifDemo1() {
  score := 65
  if score >= 90 {
    fmt.Println("A")
  } else if score > 75 {
    fmt.Println("B")
  } else {
    fmt.Println("C") // 输出结果
  }
}
```



#### if条件判断特殊写法

描述: if条件判断还有一种特殊的写法，可以在 if 表达式之前添加一个执行语句，再根据变量值进行判断，举个例子：

示例2：

```
func ifDemo2() {
  score := 88 // 注意变量作用域的影响
  if score := 65; score >= 90 {
    fmt.Println("A", score)
  } else if score > 75 {
    fmt.Println("B", score)
  } else {
    fmt.Println("C", score) // 输出结果
  }
  fmt.Println("score : ", score)
}
```

执行结果:

```
C 65
score :  88
```



**思考题：** 上下两种写法的区别在哪里？

> 答: 上述 示例1 与 示例2 区别在于定义 score 变量位置得不同, 示例1中的score变量在函数代码块中有效, 而示例2中的score变量作用域只在`if...else`代码块中有效。



### 2.for(循环结构)

描述: Go 语言中的所有循环类型均可以使用`for`关键字来完成。

for循环的基本格式如下：

```
for 初始语句;条件表达式;结束语句{
   循环体语句
}
```

条件表达式返回`true`时循环体不停地进行循环，直到条件表达式返回`false`时自动退出循环。

```go
func forDemo() {
  for i := 0; i < 10; i++ {
    fmt.Println(i)
  }
}
```

for循环的初始语句可以被忽略，但是初始语句后的分号必须要写，例如：

```go
func forDemo2() {
  i := 0
  for ; i < 10; i++ {
    fmt.Println(i)
  }
}
```

for循环的初始语句和结束语句都可以省略，例如：

```go
func forDemo3() {
  i := 0
  for i < 10 {
    fmt.Println(i)
    i++
  }
}
```

for无限循环，这种写法类似于其他编程语言中的`while`，在`while`后添加一个条件表达式，满足条件表达式时持续循环，否则结束循环。
例如: for循环可以通过`break`、`goto`、`return`、`panic`语句强制退出循环。

```
for {
  循环体语句
}
```



### 3.for range(键值循环)

描述: Go语言中可以使用`for range`遍历数组、切片、字符串、map 及通道（channel）。

通过`for range`遍历的返回值有以下规律：

- 数组、切片、字符串返回索引和值。
- map返回键和值。
- 通道（channel）只返回通道内的值。

**简单示例:**

```
s1 := "Hello,Go 输出的是中文"
for i, v := range s1 {
  fmt.Printf("Index : %d ,Value : %s , Number : %v \n", i, string(v), v)
}
```

**输出结果:**

```
Index : 0 ,Value : H , Number : 72 
Index : 1 ,Value : e , Number : 101 
Index : 2 ,Value : l , Number : 108 
Index : 3 ,Value : l , Number : 108 
Index : 4 ,Value : o , Number : 111 
Index : 5 ,Value : , , Number : 44 
Index : 6 ,Value : G , Number : 71 
Index : 7 ,Value : o , Number : 111 
Index : 8 ,Value :   , Number : 32 
Index : 9 ,Value : 输 , Number : 36755 
Index : 12 ,Value : 出 , Number : 20986 
Index : 15 ,Value : 的 , Number : 30340 
Index : 18 ,Value : 是 , Number : 26159 
Index : 21 ,Value : 中 , Number : 20013 
Index : 24 ,Value : 文 , Number : 25991 
```



### 4.switch case(选择语句)

描述: 使用`switch`语句可方便地对大量的值进行条件判断，即简化大量判断。

```go
func switchDemo1() {
	finger := 3
	switch finger {
	case 1:
		fmt.Println("大拇指")
	case 2:
		fmt.Println("食指")
	case 3:
		fmt.Println("中指")
	case 4:
		fmt.Println("无名指")
	case 5:
		fmt.Println("小拇指")
	default:
		fmt.Println("无效的输入！")
	}
}
```



Go语言规定每个`switch`只能有一个`default`分支, 但一个分支可以有多个值，多个case值中间使用英文逗号分隔。

```go
func testSwitch3() {
  switch n := 7; n {
  case 1, 3, 5, 7, 9:
    fmt.Println("奇数")
  case 2, 4, 6, 8:
    fmt.Println("偶数")
  default:
    fmt.Println(n)
  }
}
```



**分支还可以使用表达式，这时候switch语句后面不需要再跟判断变量**。例如：

```go
func switchDemo4() {
  age := 30
  switch {
  case age < 25:
    fmt.Println("好好学习吧")
  case age > 25 && age < 35:
    fmt.Println("好好工作吧")
  case age > 60:
    fmt.Println("好好享受吧")
  default:
    fmt.Println("活着真好")
  }
}
```



`fallthrough`语法: **可以执行满足条件的case的下一个case**，是为了兼容C语言中的case设计的（值得学习）。

```go
func switchDemo5() {
  s := "a"
  switch {
  case s == "a":
    fmt.Println("a")
    fallthrough
  case s == "b":
    fmt.Println("b")
  case s == "c":
    fmt.Println("c")
  default:
    fmt.Println("...")
  }
}
```

结果输出:

```
a
b
```

##### switch使用方法 2

```go
switch os := runtime.GOOS; os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
}

// 上面的写法和这个等价
os := runtime.GOOS
switch os {
	case "darwin":
		fmt.Println("OS X.")
	case "linux":
		fmt.Println("Linux.")
	default:
		// freebsd, openbsd,
		// plan9, windows...
		fmt.Printf("%s.\n", os)
}
```



##### switch使用方法4

只适用于`interface`的类型判断，而且`{`要和`switch`在同一行，`{`前面不能有分号`;`

```
package main

import "fmt"

func main() {
	var i interface{} = 10
	switch t := i.(type) {
	case bool:
		fmt.Println("I'm a bool")
	case int:
		fmt.Println("I'm an int")
	default:
		fmt.Printf("Don't know type %T\n", t)
	}
}
```

### 6.break(跳出循环)

描述: `break`语句可以结束`for`、`switch`和`select`的代码块。

`break`语句还可以在语句后面添加标签，表示退出某个标签对应的代码块，标签要求必须定义在对应的`for`、`switch`和 `select`的代码块上。 举个例子：

```
func breakDemo1() {
BREAKDEMO1:
  for i := 0; i < 10; i++ {
    for j := 0; j < 10; j++ {
      if j == 2 {
        break BREAKDEMO1
      }
      fmt.Printf("%v-%v\n", i, j)
    }
  }
  fmt.Println("...")
}
```

### 7.continue(继续下次循环)

描述: `continue`语句可以结束当前循环，开始下一次的循环迭代过程，仅限在`for`循环内使用。

在 `continue`语句后添加标签时，表示开始标签对应的循环。例如：

```
func continueDemo() {
forloop1:
  for i := 0; i < 5; i++ {
    // forloop2:
    for j := 0; j < 5; j++ {
      if i == 2 && j == 2 {
        continue forloop1
      }
      fmt.Printf("%v-%v\n", i, j)
    }
  }
}
```

# 0X04 Go语言基础之数组

### 1.数组定义

基本语法：

```
var 数组名 [元素数量]类型

// 定义一个长度为3元素类型为int的数组a
var a [3]int
```

比如：`var a [5]int`， 数组的长度必须是常量，并且长度是数组类型的一部分。一旦定义，长度不能变。注意: `[5]int`和`[10]int`是不同的类型。

```
var a [3]int
var b [4]int
a = b //不可以这样做，因为此时a和b是不同的类型
```

Tips ：数组可以通过下标进行访问，下标是从`0`开始，最后一个元素下标是：`len-1`，访问越界（下标在合法范围之外），则触发访问越界，会panic。

### 2.数组初始化

数组的初始化也有很多方式。

如果不初始，默认元素都是零值(布尔值: `false`，整型和浮点型都是`0`，字符串:`""`)

##### 1.方法一

初始化数组时可以使用初始化列表来设置数组元素的值。

```
func main() {
	var testArray [3]int                        //数组会初始化为int类型的零值
	var numArray = [3]int{1, 2}                 //使用指定的初始值完成初始化
	var cityArray = [3]string{"北京", "上海", "深圳"} //使用指定的初始值完成初始化
	fmt.Println(testArray)                      //[0 0 0]
	fmt.Println(numArray)                       //[1 2 0]
	fmt.Println(cityArray)                      //[北京 上海 深圳]
}
```

##### 2.方法二

按照上面的方法每次都要确保提供的初始值和数组长度一致，***如果省略号`...`出现在数组长度的位置,那么数组的长度由初始化数组的元素个数决定**。*一般情况下我们可以让编译器**根据初始值的个数自行推断数组的长度**，例如：

```
func main() {
	var testArray [3]int
	var numArray = [...]int{1, 2}
	var cityArray = [...]string{"北京", "上海", "深圳"}
	fmt.Println(testArray)                          //[0 0 0]
	fmt.Println(numArray)                           //[1 2]
	fmt.Printf("type of numArray:%T\n", numArray)   //type of numArray:[2]int
	fmt.Println(cityArray)                          //[北京 上海 深圳]
	fmt.Printf("type of cityArray:%T\n", cityArray) //type of cityArray:[3]string
}
```

**方法三**

我们还可以**使用指定索引值的方式来初始化数组**，例如:

```
func main() {
	a := [...]int{1: 1, 3: 5}
	fmt.Println(a)                  // [0 1 0 5]
	fmt.Printf("type of a:%T\n", a) //type of a:[4]int
}
```

### 3.数组的遍历

遍历数组a有以下两种方法：

```go
func main() {
	var a = [...]string{"北京", "上海", "深圳"}
	// 方法1：for循环遍历
	for i := 0; i < len(a); i++ {
		fmt.Println(a[i])
	}

	// 方法2：for range遍历
	for index, value := range a {
		fmt.Println(index, value)
	}
}
```

### 4.多维数组

Go语言是支持多维数组的，我们这里以二维数组为例（数组中又嵌套数组）。

#### 二维数组的定义

```
func main() {
	a := [3][2]string{
		{"北京", "上海"},
		{"广州", "深圳"},
		{"成都", "重庆"},
	}
	fmt.Println(a) //[[北京 上海] [广州 深圳] [成都 重庆]]
	fmt.Println(a[2][1]) //支持索引取值:重庆
}
```

**注意：** 多维数组**只有第一层**可以使用`...`来让编译器推导数组长度。例如：

```
//支持的写法
a := [...][2]string{
	{"北京", "上海"},
	{"广州", "深圳"},
	{"成都", "重庆"},
}
//不支持多维数组的内层使用...
b := [3][...]string{
	{"北京", "上海"},
	{"广州", "深圳"},
	{"成都", "重庆"},
}
```



#### 二维数组的遍历

```
func main() {
	a := [3][2]string{
		{"北京", "上海"},
		{"广州", "深圳"},
		{"成都", "重庆"},
	}
	
	// 方式1. for range 方式
	for _, v1 := range a {
		for _, v2 := range v1 {
			fmt.Printf("%s\t", v2)
		}
		fmt.Println()
	}
}
```

输出：

```
北京	上海	
广州	深圳	
成都	重庆	
```



### 5.数组是值类型

描述: 数组是值类型，`赋值和传参会复制整个数组`。因此改变副本的值，不会改变本身的值。

```
func modifyArray(x [3]int) {
	x[0] = 100
}

func modifyArray2(x [3][2]int) {
	x[2][0] = 100
}
func main() {
	a := [3]int{10, 20, 30}
	modifyArray(a) //在modify中修改的是a的副本x
	fmt.Println(a) //[10 20 30]
	
	b := [3][2]int{
		{1, 1},
		{1, 1},
		{1, 1},
	}
	modifyArray2(b) //在modify中修改的是b的副本x
	fmt.Println(b)  //[[1 1] [1 1] [1 1]]
}
```

**注意：**

1. 数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。

2. `[n]*T`表示指针数组，`*[n]T`表示数组指针 。

3. **如果花括号 } 在下一行，这里必须有逗号。如果花括号在这一行可以不用逗号**

   ```
   array1 := [2][3]int {
       {0, 1, 2},
       {3, 4, 5}, // 如果花括号}在下一行，这里必须有逗号。如果花括号在这一行可以不用逗号
   }
   ```

# 0X05 Go语言之切片

## 引子

因为数组的长度是固定的并且数组长度属于类型的一部分，所以数组有很多的局限性。 例如：

```go
func arraySum(x [3]int) int{
    sum := 0
    for _, v := range x{
        sum = sum + v
    }
    return sum
}
```

这个求和函数只能接受`[3]int`类型，其他的都不支持。 再比如，

```go
a := [3]int{1, 2, 3}
```

数组a中已经有三个元素了，我们不能再继续往数组a中添加新元素了。

切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。

切片是一个引用类型，它的内部结构包含`地址`、`长度`和`容量`。切片一般用于快速地操作一块数据集合。

- 切片的底层数据结构

  ```go
  type slice struct {
  	array unsafe.Pointer
  	len   int
  	cap   int
  }
  ```

  切片slice是个struct结构体，里面实际有个指针array，类型是unsafe.Pointer，也就是个指针，指向存放数据的数组。

  len是切片的长度，cap是切片的容量。

## 切片的定义

声明切片类型的基本语法如下：看上去像没有长度的数组类型

```go
var name []Type
```

其中，

- name: 表示变量名
- Type: 表示切片中的元素类型

举个例子：

```go
func main() {
	// 声明切片类型
	var a []string              //声明一个字符串切片
	var b = []int{}             //声明一个整型切片并初始化
	var c = []bool{false, true} //声明一个布尔切片并初始化
	var d = []bool{false, true} //声明一个布尔切片并初始化
	fmt.Println(a)              //[]
	fmt.Println(b)              //[]
	fmt.Println(c)              //[false true]
	fmt.Println(a == nil)       //true
	fmt.Println(b == nil)       //false
	fmt.Println(c == nil)       //false
	// fmt.Println(c == d)   //切片是引用类型，不支持直接比较，只能和nil比较
}
```

### 切片的长度和容量

切片拥有自己的长度和容量，我们可以通过使用内置的`len()`函数求长度，使用内置的`cap()`函数求切片的容量。

### 切片表达式

切片表达式从字符串、数组、指向数组或切片的指针构造子字符串或切片。它有两种变体：一种指定low和high两个索引界限值的简单的形式，另一种是除了low和high索引界限值外还指定容量的完整的形式。

#### 简单切片表达式

切片的底层就是一个数组，所以我们可以基于数组通过切片表达式得到切片。 切片表达式中的`low`和`high`表示一个索引范围（左包含，右不包含），也就是下面代码中从数组a中选出`1<=索引值<4`的元素组成切片s，得到的切片`长度=high-low`，容量等于得到的切片的底层数组的容量。

```go
func main() {
	a := [5]int{1, 2, 3, 4, 5}
	s := a[1:3]  // s := a[low:high]
	fmt.Printf("s:%v len(s):%v cap(s):%v\n", s, len(s), cap(s))
}
```

输出：

```bash
s:[2 3] len(s):2 cap(s):4
```

为了方便起见，可以省略切片表达式中的任何索引。省略了`low`则默认为0；省略了`high`则默认为切片操作数的长度:

```go
a[2:]  // 等同于 a[2:len(a)]
a[:3]  // 等同于 a[0:3]
a[:]   // 等同于 a[0:len(a)]
```

**注意：**

对于数组或字符串，如果`0 <= low <= high <= len(a)`，则索引合法，否则就会索引越界（out of range）。

对切片再执行切片表达式时（切片再切片），`high`的上限边界是切片的容量`cap(a)`，而不是长度。**常量索引**必须是非负的，并且可以用int类型的值表示;对于数组或常量字符串，常量索引也必须在有效范围内。如果`low`和`high`两个指标都是常数，它们必须满足`low <= high`。如果索引在运行时超出范围，就会发生运行时`panic`。

```go
func main() {
	a := [5]int{1, 2, 3, 4, 5}
	s := a[1:3]  // s := a[low:high]
	fmt.Printf("s:%v len(s):%v cap(s):%v\n", s, len(s), cap(s))
	s2 := s[3:4]  // 索引的上限是cap(s)而不是len(s)
	fmt.Printf("s2:%v len(s2):%v cap(s2):%v\n", s2, len(s2), cap(s2))
}
```

输出：

```bash
s:[2 3] len(s):2 cap(s):4
s2:[5] len(s2):1 cap(s2):1
```

#### 完整切片表达式

对于数组，指向数组的指针，或切片a(**注意不能是字符串**)支持完整切片表达式：

```go
a[low : high : max]
```

上面的代码会构造与简单切片表达式`a[low: high]`相同类型、相同长度和元素的切片。另外，**它会将得到的结果切片的容量设置为`max-low`**。在完整切片表达式中只有第一个索引值（low）可以省略；它默认为0。

```go
func main() {
	a := [5]int{1, 2, 3, 4, 5}
	t := a[1:3:5]
	fmt.Printf("t:%v len(t):%v cap(t):%v\n", t, len(t), cap(t))
}
```

输出结果：

```bash
t:[2 3] len(t):2 cap(t):4
```

完整切片表达式需要满足的条件是`0 <= low <= high <= max <= cap(a)`，其他条件和简单切片表达式相同。

### 使用make()函数构造切片

我们上面都是基于数组来创建的切片，如果需要动态的创建一个切片，我们就需要使用内置的`make()`函数，格式如下：

```bash
make([]T, size, cap)
```

其中：

- T:切片的元素类型
- size:切片中元素的数量
- cap:切片的容量

举个例子：

```go
func main() {
	a := make([]int, 2, 10)
	fmt.Println(a)      //[0 0]
	fmt.Println(len(a)) //2
	fmt.Println(cap(a)) //10
}
```

上面代码中`a`的内部存储空间已经分配了10个，但实际上只用了2个。 容量并不会影响当前元素的个数，所以`len(a)`返回2，`cap(a)`则返回该切片的容量。

### 切片的本质

切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。

举个例子，现在有一个数组`a := [8]int{0, 1, 2, 3, 4, 5, 6, 7}`，切片`s1 := a[:5]`，相应示意图如下。

![slice_01](https://img.herrluk.icu/typoraPicture/slice_01.png)切片`s2 := a[3:6]`，相应示意图如下：

![slice_02](https://img.herrluk.icu/typoraPicture/slice_02.png)

##### 判断切片是否为空

要检查切片是否为空，**请始终使用`len(s) == 0`来判断，而不应该使用`s == nil`来判断。**

### 切片不能直接比较

切片之间是不能比较的，我们不能使用`==`操作符来判断两个切片是否含有全部相等元素。 切片唯一合法的比较操作是和`nil`比较。 一个`nil`值的切片并没有底层数组，一个`nil`值的切片的长度和容量都是0。但是我们不能说一个长度和容量都是0的切片一定是`nil`，例如下面的示例：

```go
var s1 []int         //len(s1)=0;cap(s1)=0;s1==nil
s2 := []int{}        //len(s2)=0;cap(s2)=0;s2!=nil
s3 := make([]int, 0) //len(s3)=0;cap(s3)=0;s3!=nil
```

所以要判断一个切片是否是空的，要是用`len(s) == 0`来判断，不应该使用`s == nil`来判断。

## 切片的赋值拷贝

下面的代码中演示了**拷贝前后两个变量共享底层数组，对一个切片的修改会影响另一个切片的内容，这点需要特别注意**。

```go
func main() {
	s1 := make([]int, 3) //[0 0 0]
	s2 := s1             //将s1直接赋值给s2，s1和s2共用一个底层数组
	s2[0] = 100
	fmt.Println(s1) //[100 0 0]
	fmt.Println(s2) //[100 0 0]
}
```

## 切片遍历

切片的遍历方式和数组是一致的，支持索引遍历和`for range`遍历。

```go
func main() {
	s := []int{1, 3, 5}

	for i := 0; i < len(s); i++ {
		fmt.Println(i, s[i])
	}

	for index, value := range s {
		fmt.Println(index, value)
	}
}
```

## append()方法为切片添加元素

Go语言的内建函数`append()`可以为切片动态添加元素。 可以一次添加一个元素，可以添加多个元素，***也可以添加另一个切片中的元素（后面加`...`）***。

```go
func main(){
	var s []int
	s = append(s, 1)        // [1]
	s = append(s, 2, 3, 4)  // [1 2 3 4]
	s2 := []int{5, 6, 7}  
	s = append(s, s2...)    // [1 2 3 4 5 6 7]
}
```

**注意：**通过var声明的零值切片可以在`append()`函数直接使用，无需初始化。

```go
var s []int
s = append(s, 1, 2, 3)
```

没有必要像下面的代码一样初始化一个切片再传入`append()`函数使用，

```go
s := []int{}  // 没有必要初始化
s = append(s, 1, 2, 3)

var s = make([]int)  // 没有必要初始化
s = append(s, 1, 2, 3)
```

**每个切片会指向一个底层数组，这个数组的容量够用就添加新增元素。当底层数组不能容纳新增的元素时，切片就会自动按照一定的策略进行“扩容”，此时该切片指向的底层数组就会更换。**

“扩容”操作往往发生在`append()`函数调用时，所以我们通常都需要用原变量接收append函数的返回值。

举个例子：

```go
func main() {
	//append()添加元素和切片扩容
	var numSlice []int
	for i := 0; i < 10; i++ {
		numSlice = append(numSlice, i)
		fmt.Printf("%v  len:%d  cap:%d  ptr:%p\n", numSlice, len(numSlice), cap(numSlice), numSlice)
	}
}
```

输出：

```bash
[0]  len:1  cap:1  ptr:0xc0000a8000
[0 1]  len:2  cap:2  ptr:0xc0000a8040
[0 1 2]  len:3  cap:4  ptr:0xc0000b2020
[0 1 2 3]  len:4  cap:4  ptr:0xc0000b2020
[0 1 2 3 4]  len:5  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5]  len:6  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6]  len:7  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6 7]  len:8  cap:8  ptr:0xc0000b6000
[0 1 2 3 4 5 6 7 8]  len:9  cap:16  ptr:0xc0000b8000
[0 1 2 3 4 5 6 7 8 9]  len:10  cap:16  ptr:0xc0000b8000
```

从上面的结果可以看出：

1. `append()`函数将元素追加到切片的最后并返回该切片。
2. 切片numSlice的容量按照1，2，4，8，16这样的规则自动进行扩容，每次扩容后都是扩容前的2倍。

append()函数还支持一次性追加多个元素。 例如：

```go
var citySlice []string
// 追加一个元素
citySlice = append(citySlice, "北京")
// 追加多个元素
citySlice = append(citySlice, "上海", "广州", "深圳")
// 追加切片
a := []string{"成都", "重庆"}
citySlice = append(citySlice, a...)
fmt.Println(citySlice) //[北京 上海 广州 深圳 成都 重庆]
```

## 切片的扩容策略

可以通过查看`$GOROOT/src/runtime/slice.go`源码，其中扩容相关代码如下：

```go
newcap := old.cap
doublecap := newcap + newcap
if cap > doublecap {
	newcap = cap
} else {
	if old.len < 1024 {
		newcap = doublecap
	} else {
		// Check 0 < newcap to detect overflow
		// and prevent an infinite loop.
		for 0 < newcap && newcap < cap {
			newcap += newcap / 4
		}
		// Set newcap to the requested cap when
		// the newcap calculation overflowed.
		if newcap <= 0 {
			newcap = cap
		}
	}
}
```

从上面的代码可以看出以下内容：

- 首先判断，如果新申请容量（cap）大于2倍的旧容量（old.cap），最终容量（newcap）就是新申请的容量（cap）。
- 否则判断，如果旧切片的长度小于1024，则最终容量(newcap)就是旧容量(old.cap)的两倍，即（newcap=doublecap），
- 否则判断，如果旧切片长度大于等于1024，则最终容量（newcap）从旧容量（old.cap）开始循环增加原来的1/4，即（newcap=old.cap,for {newcap += newcap/4}）直到最终容量（newcap）大于等于新申请的容量(cap)，即（newcap >= cap）
- 如果最终容量（cap）计算值溢出，则最终容量（cap）就是新申请容量（cap）。

需要注意的是，切片扩容还会根据切片中元素的类型不同而做不同的处理，比如`int`和`string`类型的处理方式就不一样。

## 使用copy()函数复制切片

首先我们来看一个问题：

```go
func main() {
	a := []int{1, 2, 3, 4, 5}
	b := a
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(b) //[1 2 3 4 5]
	b[0] = 1000
	fmt.Println(a) //[1000 2 3 4 5]
	fmt.Println(b) //[1000 2 3 4 5]
}
```

由于切片是引用类型，所以a和b其实都指向了同一块内存地址。修改b的同时a的值也会发生变化。

Go语言*内建的`copy()`函数可以迅速地将一个切片的数据复制到另外一个切片空间中，*`copy()`函数的使用格式如下：

```bash
copy(destSlice, srcSlice []T)
```

其中：

- srcSlice: 数据来源切片
- destSlice: 目标切片

举个例子：

```go
func main() {
	// copy()复制切片
	a := []int{1, 2, 3, 4, 5}
	c := make([]int, 5, 5)
	copy(c, a)     //使用copy()函数将切片a中的元素复制到切片c
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1 2 3 4 5]
	c[0] = 1000
	fmt.Println(a) //[1 2 3 4 5]
	fmt.Println(c) //[1000 2 3 4 5]
}
```

## 从切片中删除元素

Go语言中并没有删除切片元素的专用方法，我们可以使用切片本身的特性来删除元素。 代码如下：

```go
func main() {
	// 从切片中删除元素
	a := []int{30, 31, 32, 33, 34, 35, 36, 37}
	// 要删除索引为2的元素
	a = append(a[:2], a[3:]...)
	fmt.Println(a) //[30 31 33 34 35 36 37]
}
```

总结一下就是：要从切片a中删除索引为`index`的元素，操作方法是`a = append(a[:index], a[index+1:]...)`

# 0X02 Go语言中的指针

任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。

**Go语言中的指针不能进行偏移和运算，**因此Go语言中的指针操作非常简单，我们只需要记住两个符号：`&`（取地址）和`*`（根据地址取值）。

## 指针地址和指针类型

每个变量在运行时都拥有一个地址，这个地址代表变量在内存中的位置。Go语言中使用`&`字符放在变量前面对变量进行“取地址”操作。 Go语言中的值类型（int、float、bool、string、array、struct）都有对应的指针类型，如：`*int`、`*int64`、`*string`等。

取变量指针的语法如下：

```go
ptr := &v    // v的类型为T
```

其中：

- v:代表被取地址的变量，类型为`T`
- ptr:用于接收地址的变量，ptr的类型就为`*T`，称做T的指针类型。*代表指针。

举个例子：

```go
func main() {
	a := 10
	b := &a
	fmt.Printf("a:%d ptr:%p\n", a, &a) // a:10 ptr:0xc00001a078
	fmt.Printf("b:%p type:%T\n", b, b) // b:0xc00001a078 type:*int
	fmt.Println(&b)                    // 0xc00000e018
}
```

我们来看一下`b := &a`的图示：

![取变量地址图示](https://img.herrluk.icu/typoraPicture/ptr.png)

## 指针取值

在对普通变量使用`&`操作符取地址后会获得这个变量的指针，然后可以对指针使用`*`操作，也就是指针取值，代码如下。

```go
func main() {
	//指针取值
	a := 10
	b := &a // 取变量a的地址，将指针保存到b中
	fmt.Printf("type of b:%T\n", b)
	c := *b // 指针取值（根据指针去内存取值）
	fmt.Printf("type of c:%T\n", c)
	fmt.Printf("value of c:%v\n", c)
}
```

输出如下：

```go
type of b:*int
type of c:int
value of c:10
```

**总结：** 取地址操作符`&`和取值操作符`*`是一对互补操作符，`&`取出地址，`*`根据地址取出地址指向的值。

变量、指针地址、指针变量、取地址、取值的相互关系和特性如下：

- 对变量进行取地址（&）操作，可以获得这个变量的指针变量。
- 指针变量的值是指针地址。
- 对指针变量进行取值（*）操作，可以获得指针变量指向的原变量的值。

**指针传值示例：**

```go
func modify1(x int) {
	x = 100
}

func modify2(x *int) {
	*x = 100
}

func main() {
	a := 10
	modify1(a)
	fmt.Println(a) // 10
	modify2(&a)
	fmt.Println(a) // 100
}
```



## 指向数组的指针

```go
array := [3]int{1,2,3}
var arrayPtr *[3]int = &array // C++赋值就不用加&
for i:=0; i<len(array); i++ {
  // arrayPtr[i]的值就是数组array里下标索引i对应的值
	fmt.Printf("arrayPtr[%d]=%d\n", i, arrayPtr[i])
}
```

这段代码使用了Go语言的语法来创建一个长度为3的整数数组，其中包含数字1、2和3。接着，使用指针变量来引用该数组，并将其地址存储在指针变量 `arrayPtr` 中。

然后使用 `for` 循环遍历该数组，并打印出每个元素的值。循环的条件是 `i<len(array)`，这里的 `len` 函数返回数组的长度，即 `3`。在循环体中，使用指针变量和数组下标来访问数组中的元素。 `arrayPtr[i]` 表示数组 `array` 中索引为 `i` 的元素，因为 `arrayPtr` 是一个指向数组的指针。

具体来说，如果数组 `array` 被分配在内存中的地址是 `0x1000`，那么 `arrayPtr` 的值就是 `0x1000`。这个值是一个指针，它指向一个长度为3的整数数组，数组中包含数字1、2和3。指针变量 `arrayPtr` 可以使用下标操作符 `[]` 来访问数组中的元素，例如 `arrayPtr[0]` 就表示数组中的第一个元素，即数字1。

## 指针数组

- 定义

  ```go
  var ptr [SIZE]*int // 指向int的指针数组，数组里有多个指针，每个都指向一个int
  ```

- 使用

  ```go
  package main
  
  import "fmt"
  
  const SIZE = 5
  
  func main() {
      var ptrArray [SIZE]*int
      a := [5]int{1,2,3,4,5}
      for i:=0; i<SIZE; i++ {
          ptrArray[i] = &a[i]
      }
      
      for i:=0; i<SIZE; i++ {
          fmt.Printf("%d ", *ptrArray[i])
      }
      fmt.Println()
  }
  ```

## 指向指针的指针

- 定义

  ```
  var a int = 100
  var ptr1 *int = &a
  var ptr2 **int = &ptr1
  var ptr3 ***int = &ptr2
  ```

- 使用

  ```
  package main
  
  import "fmt"
  
  func main() {
      var a int = 100
      var ptr1 *int = &a
      var ptr2 **int = &ptr1
      var ptr3 ***int = &ptr2
      
      fmt.Println("*ptr1=", *ptr1)
      fmt.Println("**ptr2=", **ptr2)
      fmt.Println("***ptr3=", ***ptr3)
  }
  ```

## 向函数传递指针参数

- 示例：通过指针参数修改实参的值

  ```
  package main
  
  import "fmt"
  
  // 这个可以交换外部传入的2个实参的值
  func swap(a *int, b *int) {
      *a, *b = *b, *a
  }
  
  // 这个无法交换外部传入的2个实参的值
  func swap2(a *int, b *int) {
      a, b = b, a
  }
  
  
  func main() {
      a, b := 1, 2
      swap(&a, &b)
      fmt.Println("a=", a, " b=", b) // a= 2  b= 1
      
      swap2(&a, &b)
      fmt.Println("a=", a, " b=", b) // a= 2  b= 1
  }
  ```

## 指向结构体的指针

指向结构体的指针在访问结构体成员的时候使用点`.`，和C++里用箭头->不一样。具体参见[指向结构体的指针](https://github.com/jincheng9/go-tutorial/blob/main/workspace/lesson11/workspace/lesson12)

## new和make

我们先来看一个例子：

```go
func main() {
	var a *int
	*a = 100
	fmt.Println(*a)

	var b map[string]int
	b["沙河娜扎"] = 100
	fmt.Println(b)
}
```

执行上面的代码会引发panic，为什么呢？ 在Go语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的new和make。 Go语言中new和make是内建的两个函数，主要用来分配内存。

### new

new是一个内置的函数，它的函数签名如下：

```go
func new(Type) *Type
```

其中，

- Type表示类型，new函数只接受一个参数，这个参数是一个类型
- `*Type`表示类型指针，new函数返回一个指向该类型内存地址的指针。

new函数不太常用，使用new函数得到的是一个类型的指针，并且该指针对应的值为该类型的零值。举个例子：

```go
func main() {
	a := new(int)
	b := new(bool)
	fmt.Printf("%T\n", a) // *int
	fmt.Printf("%T\n", b) // *bool
	fmt.Println(*a)       // 0
	fmt.Println(*b)       // false
}	
```

本节开始的示例代码中`var a *int`**只是声明了一个指针变量a但是没有初始化，指针作为引用类型需要初始化后才会拥有内存空间，才可以给它赋值**。应该按照如下方式使用内置的new函数对a进行初始化之后就可以正常对其赋值了：

```go
func main() {
	var a *int
	a = new(int)
	*a = 10
	fmt.Println(*a)
}
```

### make

*make也是用于内存分配的，区别于new，它**只用于slice、map以及chan的内存创建**，而且它**返回的类型就是这三个类型本身，而不是他们的指针类型**，因为这三种类型就是引用类型，所以就没有必要返回他们的指针了*。make函数的函数签名如下：

```go
func make(t Type, size ...IntegerType) Type
```

make函数是无可替代的，我们在使用slice、map以及channel的时候，都需要使用make进行初始化，然后才可以对它们进行操作。这个我们在上一章中都有说明，关于channel我们会在后续的章节详细说明。

本节开始的示例中`var b map[string]int`只是声明变量b是一个map类型的变量，需要像下面的示例代码一样使用make函数进行初始化操作之后，才能对其进行键值对赋值：

```go
func main() {
	var b map[string]int
	b = make(map[string]int, 10)
	b["沙河娜扎"] = 100
	fmt.Println(b)
}
```

### new与make的区别

1. 二者都是用来做内存分配的。
2. *make只用于slice、map以及channel的初始化，返回的还是这三个引用类型本身；*
3. *new用于类型的内存分配，并且内存对应的值为类型零值，返回的是指向类型的指针。*

# 0X03 Go语言基础之map

map是一种无序的基于`key-value`的数据结构，Go语言中的map是引用类型，必须初始化才能使用。

## map定义

Go语言中 `map`的定义语法如下：**类似于其他编程语言的集合**。

```go
map[KeyType]ValueType
```

其中，

- `KeyType`:表示键的类型。
- `ValueType`:表示键对应的值的类型。

map类型的变量默认初始值为nil，需要使用make()函数来分配内存。语法为：

```go
make(map[KeyType]ValueType, [cap])
```

其中cap表示map的容量，该参数虽然不是必须的，但是我们应该在初始化map的时候就为其指定一个合适的容量。

## map基本使用

map中的数据都是成对出现的，map的基本使用示例代码如下：

```go
func main() {
	scoreMap := make(map[string]int, 8)
	scoreMap["张三"] = 90
	scoreMap["小明"] = 100
	fmt.Println(scoreMap)
	fmt.Println(scoreMap["小明"])
	fmt.Printf("type of a:%T\n", scoreMap)
}
```

输出：

```bash
map[小明:100 张三:90]
100
type of a:map[string]int
```

map也支持在声明的时候填充元素，例如：

```go
func main() {
	userInfo := map[string]string{
		"username": "沙河小王子",
		"password": "123456",
	}
	fmt.Println(userInfo) //
}
```

## 判断某个键是否存在

Go语言中有个判断map中键是否存在的特殊写法，格式如下:

```go
value, ok := map[key]
```

举个例子：

```go
func main() {
	scoreMap := make(map[string]int)
	scoreMap["张三"] = 90
	scoreMap["小明"] = 100
	// 如果key存在ok为true,v为对应的值；不存在ok为false,v为值类型的零值
	v, ok := scoreMap["张三"]
	if ok {
		fmt.Println(v)
	} else {
		fmt.Println("查无此人")
	}
}
```

## map的遍历 

Go语言中使用`for range`遍历map。

```go
func main() {
	scoreMap := make(map[string]int)
	scoreMap["张三"] = 90
	scoreMap["小明"] = 100
	scoreMap["娜扎"] = 60
	for k, v := range scoreMap {
		fmt.Println(k, v)
	}
}
```

但我们只想遍历key的时候，可以按下面的写法：

```go
func main() {
	scoreMap := make(map[string]int)
	scoreMap["张三"] = 90
	scoreMap["小明"] = 100
	scoreMap["娜扎"] = 60
	for k := range scoreMap {
		fmt.Println(k)
	}
}
```

**注意：** 遍历map时的元素顺序与添加键值对的顺序无关。

## 使用delete()函数删除键值对

使用`delete()`内建函数从map中删除一组键值对，`delete()`函数的格式如下：

```go
delete(map, key)
```

其中，

- map:表示要删除键值对的map
- key:表示要删除的键值对的键

示例代码如下：

```go
func main(){
	scoreMap := make(map[string]int)
	scoreMap["张三"] = 90
	scoreMap["小明"] = 100
	scoreMap["娜扎"] = 60
	delete(scoreMap, "小明")//将小明:100从map中删除
	for k,v := range scoreMap{
		fmt.Println(k, v)
	}
}
```

## 按照指定顺序遍历map

```go
func main() {
	rand.Seed(time.Now().UnixNano()) //初始化随机数种子

	var scoreMap = make(map[string]int, 200)

	for i := 0; i < 100; i++ {
		key := fmt.Sprintf("stu%02d", i) //生成stu开头的字符串
		value := rand.Intn(100)          //生成0~99的随机整数
		scoreMap[key] = value
	}
	//取出map中的所有key存入切片keys
	var keys = make([]string, 0, 200)
	for key := range scoreMap {
		keys = append(keys, key)
	}
	//对切片进行排序
	sort.Strings(keys)
	//按照排序后的key遍历map
	for _, key := range keys {
		fmt.Println(key, scoreMap[key])
	}
}
```

## 元素为map类型的切片

下面的代码演示了切片中的元素为map类型时的操作：

```go
func main() {
	var mapSlice = make([]map[string]string, 3)
	for index, value := range mapSlice {
		fmt.Printf("index:%d value:%v\n", index, value)
	}
	fmt.Println("after init")
	// 对切片中的map元素进行初始化
	mapSlice[0] = make(map[string]string, 10)
	mapSlice[0]["name"] = "小王子"
	mapSlice[0]["password"] = "123456"
	mapSlice[0]["address"] = "沙河"
	for index, value := range mapSlice {
		fmt.Printf("index:%d value:%v\n", index, value)
	}
}
```

## 值为切片类型的map

下面的代码演示了map中值为切片类型的操作：

```go
func main() {
	var sliceMap = make(map[string][]string, 3)
	fmt.Println(sliceMap)
	fmt.Println("after init")
	key := "中国"
	value, ok := sliceMap[key]
	if !ok {
		value = make([]string, 0, 2)
	}
	value = append(value, "北京", "上海")
	sliceMap[key] = value
	fmt.Println(sliceMap)
}
```

# 0X04 Go语言基础之函数

Go语言中支持函数、匿名函数和闭包，并且函数在Go语言中属于“一等公民”。

## 函数定义

Go语言中定义函数使用`func`关键字，具体格式如下：

```go
func 函数名(参数)(返回值){
    函数体
}
```

其中：

- 函数名：由字母、数字、下划线组成。但函数名的第一个字母不能是数字。在同一个包内，函数名也称不能重名（包的概念详见后文）。
- 参数：参数由参数变量和参数变量的类型组成，多个参数之间使用`,`分隔。
- 返回值：返回值由返回值变量和其变量类型组成，也可以只写返回值的类型，多个返回值必须用`()`包裹，并用`,`分隔。
- 函数体：实现指定功能的代码块。

我们先来定义一个求两个数之和的函数：

```go
func intSum(x int, y int) int {
	return x + y
}
```

函数的参数和返回值都是可选的，例如我们可以实现一个既不需要参数也没有返回值的函数：

```go
func sayHello() {
	fmt.Println("Hello 沙河")
}
```

## 函数的调用

定义了函数之后，我们可以通过`函数名()`的方式调用函数。 例如我们调用上面定义的两个函数，代码如下：

```go
func main() {
	sayHello()
	ret := intSum(10, 20)
	fmt.Println(ret)
}
```

注意，调用有返回值的函数时，可以不接收其返回值。

## 参数

### 类型简写

函数的参数中如果相邻变量的类型相同，则可以省略类型，例如：

```go
func intSum(x, y int) int {
	return x + y
}
```

上面的代码中，`intSum`函数有两个参数，这两个参数的类型均为`int`，因此可以省略`x`的类型，因为`y`后面有类型说明，`x`参数也是该类型。

### 可变参数

**可变参数是指函数的参数数量不固定。Go语言中的可变参数通过在参数名后加`...`来标识。**

注意：*可变参数通常要作为函数的最后一个参数。*

举个例子：

```go
func intSum2(x ...int) int {
	fmt.Println(x) //x是一个切片
	sum := 0
	for _, v := range x {
		sum = sum + v
	}
	return sum
}
```

调用上面的函数：

```go
ret1 := intSum2()
ret2 := intSum2(10)
ret3 := intSum2(10, 20)
ret4 := intSum2(10, 20, 30)
fmt.Println(ret1, ret2, ret3, ret4) //0 10 30 60
```

**固定参数搭配可变参数使用时，可变参数要放在固定参数的后面**，示例代码如下：

```go
func intSum3(x int, y ...int) int {
	fmt.Println(x, y)
	sum := x
	for _, v := range y {
		sum = sum + v
	}
	return sum
}
```

调用上述函数：

```go
ret5 := intSum3(100)
ret6 := intSum3(100, 10)
ret7 := intSum3(100, 10, 20)
ret8 := intSum3(100, 10, 20, 30)
fmt.Println(ret5, ret6, ret7, ret8) //100 110 130 160
```

**本质上，*函数的可变参数是通过切片来实现的*。**

## 返回值

Go语言中通过`return`关键字向外输出返回值。

### 多返回值

Go语言中函数支持多返回值，**函数如果有多个返回值时必须用`( )`将所有返回值包裹起来**。

举个例子：

```go
func calc(x, y int) (int, int) {
	sum := x + y
	sub := x - y
	return sum, sub
}
```

### 返回值命名

函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过`return`关键字返回。

例如：

```go
func calc(x, y int) (sum, sub int) {
	sum = x + y
	sub = x - y
	return
}
```

### 返回值补充

**当我们的一个函数返回值类型为slice时，nil可以看做是一个有效的slice，没必要显示返回一个长度为0的切片。**

```go
func someFunc(x string) []int {
	if x == "" {
		return nil // 没必要返回[]int{}
	}
	...
}
```

### 函数作为参数

函数作为其它函数的实参：函数定义后可以作为另一个函数的实参，比如下例的函数realFunc作为函数calValue的实参

```go
package main

import "fmt"
import "math"

// define function getSquareRoot1
func getSquareRoot1(x float64) float64 {
	return math.Sqrt(x)
}

// deffine a function variable
var getSquareRoot2 = func(x float64) float64 {
	return math.Sqrt(x)
}

// define a function type
type callback_func func(int) int


// function calValue accepts a function variable cb as its second argument
func calValue(x int, cb callback_func) int{
	fmt.Println("[func|calValue]")
	return cb(x)
}

func realFunc(x int) int {
	fmt.Println("[func|realFunc]callback function")
	return x*x
}

func main() {
	num := 100.00
	result1 := getSquareRoot1(num)
	result2 := getSquareRoot2(num)
	fmt.Println("result1=", result1)
	fmt.Println("result2=", result2)

	value := 81
	result3 := calValue(value, realFunc) // use function realFunc as argument of calValue
	fmt.Println("result3=", result3)
}
```



# 0X05 Go语言基础之函数进阶

## 变量作用域

### 全局变量

全局变量是定义在函数外部的变量，它在程序整个运行周期内都有效。 在函数中可以访问到全局变量。

```go
package main

import "fmt"

//定义全局变量num
var num int64 = 10

func testGlobalVar() {
	fmt.Printf("num=%d\n", num) //函数中可以访问全局变量num
}
func main() {
	testGlobalVar() //num=10
}
```

### 局部变量

局部变量又分为两种： 函数内定义的变量无法在该函数外使用，例如下面的示例代码main函数中无法使用testLocalVar函数中定义的变量x：

```go
func testLocalVar() {
	//定义一个函数局部变量x,仅在该函数内生效
	var x int64 = 100
	fmt.Printf("x=%d\n", x)
}

func main() {
	testLocalVar()
	fmt.Println(x) // 此时无法使用变量x
}
```

> ***如果局部变量和全局变量重名，优先访问局部变量。***

```go
package main

import "fmt"

//定义全局变量num
var num int64 = 10

func testNum() {
	num := 100
	fmt.Printf("num=%d\n", num) // 函数中优先使用局部变量
}
func main() {
	testNum() // num=100
}
```

接下来我们来看一下语句块定义的变量，通常我们会在if条件判断、for循环、switch语句上使用这种定义变量的方式。

```go
func testLocalVar2(x, y int) {
	fmt.Println(x, y) //函数的参数也是只在本函数中生效
	if x > 0 {
		z := 100 //变量z只在if语句块生效
		fmt.Println(z)
	}
	//fmt.Println(z)//此处无法使用变量z
}
```

还有我们之前讲过的for循环语句中定义的变量，也是只在for语句块中生效：

```go
func testLocalVar3() {
	for i := 0; i < 10; i++ {
		fmt.Println(i) //变量i只在当前for语句块中生效
	}
	//fmt.Println(i) //此处无法使用变量i
}
```

- 花括号`{ }`可以控制变量的作用域：和C++类似

  ```go
  package main
  
  import "fmt"
  
  func main() {
  	a := 10
  	{
  		a := 5
  		fmt.Println("a=", a) // a=5
  	}
  	fmt.Println("a=", a) // a=10
  }
  ```

### GO内存三区

栈区：基本数据类型一般分配到栈区，但是go编译器存在一个逃逸分析

堆区：引用数据类型一般分配到堆区，但是go编译器存在一个逃逸分析

代码区：代码存放在这里

## 函数类型与变量

### 定义函数类型

我们可以使用`type`关键字来定义一个函数类型，具体格式如下：

```go
type calculation func(int, int) int
```

上面语句定义了一个`calculation`类型，它是一种函数类型，这种函数接收两个int类型的参数并且返回一个int类型的返回值。

简单来说，凡是满足这个条件的函数都是calculation类型的函数，例如下面的add和sub是calculation类型。

```go
func add(x, y int) int {
	return x + y
}

func sub(x, y int) int {
	return x - y
}
```

add和sub都能赋值给calculation类型的变量。

```go
var c calculation
c = add
```

### 函数类型变量

我们可以声明函数类型的变量并且为该变量赋值：

```go
func main() {
	var c calculation               // 声明一个calculation类型的变量c
	c = add                         // 把add赋值给c
	fmt.Printf("type of c:%T\n", c) // type of c:main.calculation
	fmt.Println(c(1, 2))            // 像调用add一样调用c

	f := add                        // 将函数add赋值给变量f1
	fmt.Printf("type of f:%T\n", f) // type of f:func(int, int) int
	fmt.Println(f(10, 20))          // 像调用add一样调用f
}
```

## 高阶函数

高阶函数分为函数作为参数和函数作为返回值两部分。

### 函数作为参数

函数可以作为参数：

```go
func add(x, y int) int {
	return x + y
}
func calc(x, y int, op func(int, int) int) int {
	return op(x, y)
}
func main() {
	ret2 := calc(10, 20, add)
	fmt.Println(ret2) //30
}
```

### 函数作为返回值

函数也可以作为返回值：

```go
func do(s string) (func(int, int) int, error) {
	switch s {
	case "+":
		return add, nil
	case "-":
		return sub, nil
	default:
		err := errors.New("无法识别的操作符")
		return nil, err
	}
}
```

## 匿名函数和闭包

### init函数

*每一个源文件都可以包含一个 `init` 函数，该函数会在 main 函数执行前，被 Go 运行框架调用，**也就是说 init 会在 main 函数前被调用**。主要用来做初始化的工作。*

```go
package main

import "fmt"

func init() {
	fmt.Println("init()...")
}
func main() {
	fmt.Println("main...")

}
```

输出：

```
init()...
main...
```

> *如果一个文件同时包含全局变量定义，init 函数和 main 函数，则执行的流程为：**全局变量定义->init 函数->main 函数**。*

细节说明: 面试题：如果 `main.go` 和 `utils.go` 都含有变量定义，`init `函数时，执行的流程又是怎么样的呢？

![image-20220421153012198](https://img.herrluk.icu/typoraPicture/image-20220421153012198.png)

### 匿名函数

函数当然还可以作为返回值，但是在**Go语言中函数内部不能定义函数，只能定义匿名函数。**

如果我们某个函数只是希望使用一次，可以考虑使用匿名函数，匿名函数也可以实现多次调用。

匿名函数就是没有函数名的函数，匿名函数的定义格式如下：

```go
func(参数)(返回值){
    函数体
}
```

匿名函数因为没有函数名，所以没办法像普通函数那样调用，所以匿**名函数需要保存到某个变量或者作为立即执行函数**：

```go
func main() {
	// 将匿名函数保存到变量
	add := func(x, y int) {
		fmt.Println(x + y)
	}
	add(10, 20) // 通过变量调用匿名函数
}
```

***自执行函数：匿名函数定义完加`()`直接执行***

```go
//自执行函数：匿名函数定义完加()直接执行
	func(x, y int) {
		fmt.Println(x + y)
	}(10, 20)
```

匿名函数使用方式 1：
在定义匿名函数时就直接调用，这种方式匿名函数只能调用一次。 

```go
func main() {
    //在定义匿名函数时就直接调用,这种方式匿名函数只能调用一次
	//案例演示,求两个数的和,使用匿名函数的方式完成
    res1 := func(n1, n2 int) int {
		return n1 + n2
	}(10, 20)
	fmt.Println("res1=", res1)
}
```

匿名函数使用方式 2：
将匿名函数赋给一个变量(函数变量)，再通过该变量来调用匿名函数 。

```go
func main() {
    //将匿名函数func (n1 int,n2 int) int赋给a变量
    //则a的数据类型就是函数类型,此时,我们可以通过a完成调用
	a := func(n1, n2 int) int {
		return n1 - n2
	}
	res2 := a(10, 30)
	fmt.Println("res2=", res2)
}
```

全局匿名函数：
如果将匿名函数赋给一个全局变量，那么这个匿名函数，就成为一个全局匿名函数，可以在程序有效。

```go
var (
	func1 = func(n1, n2 int) int {
		return n1 * n2
	}
)

func main() {
	res4 := func1(4, 9)
	fmt.Println("res4=", res4)
}
```

匿名函数多用于实现回调函数和闭包。

### 闭包

闭包指的是一个函数和与其相关的引用环境组合而成的实体。

```go
// func3.go
package main

import "fmt"

func main() {
	/*
		定义2个匿名函数，也就是闭包。
		闭包可以直接调用，也可以赋值给一个变量，后续调用
	*/
	result1 := func(a int, b int) int {
		return a + b
	}(1, 2)

	var sub = func(a int, b int) int {
		return a - b
	}
	result2 := sub(1, 2)
	/*输出结果：3 -1*/
	fmt.Println(result1, result2)
}
```

简单来说，**闭包 = 函数+引用环境**。 首先我们来看一个例子：

```go
func adder() func(int) int {
	var x int
	return func(y int) int {
		x += y
		return x
	}
}
func main() {
	var f = adder()
	fmt.Println(f(10)) //10
	fmt.Println(f(20)) //30
	fmt.Println(f(30)) //60

	f1 := adder()
	fmt.Println(f1(40)) //40
	fmt.Println(f1(50)) //90
}
```

***变量`f`是一个函数并且它引用了其外部作用域中的`x`变量，此时`f`就是一个闭包。 在`f`的生命周期内，变量`x`也一直有效**。* 

闭包进阶示例1：

```go
func adder2(x int) func(int) int {
	return func(y int) int {
		x += y
		return x
	}
}

func main() {
	var f = adder2(10)
	fmt.Println(f(10)) //20
	fmt.Println(f(20)) //40
	fmt.Println(f(30)) //70

	f1 := adder2(20)
	fmt.Println(f1(40)) //60
	fmt.Println(f1(50)) //110
}
```

闭包进阶示例2：

```go
func makeSuffixFunc(suffix string) func(string) string {
	return func(name string) string {
		if !strings.HasSuffix(name, suffix) {
			return name + suffix
		}
		return name
	}
}

func main() {
	jpgFunc := makeSuffixFunc(".jpg")
	txtFunc := makeSuffixFunc(".txt")
	fmt.Println(jpgFunc("test")) //test.jpg
	fmt.Println(txtFunc("test")) //test.txt
}
```

闭包进阶示例3：

```go
func calc(base int) (func(int) int, func(int) int) {
	add := func(i int) int {
		base += i
		return base
	}

	sub := func(i int) int {
		base -= i
		return base
	}
	return add, sub
}

func main() {
	f1, f2 := calc(10)
	fmt.Println(f1(1), f2(2)) //11 9
	fmt.Println(f1(3), f2(4)) //12 8
	fmt.Println(f1(5), f2(6)) //13 7
}
```

闭包其实并不复杂，只要牢记`闭包=函数+引用环境`。

## defer语句

在函数中，程序员经常需要创建资源(比如：数据库连接、文件句柄、锁等) ，**为了在函数执行完毕后，及时的释放资源**，Go 的设计者提供 defer (延时机制)。

*Go语言中的**`defer`语句会将其后面跟随的语句进行延迟处理**。在`defer`归属的函数即将返回时，将延迟处理的语句按`defer`定义的逆序进行执行，也就是说，**先被`defer`的语句最后被执行，最后被`defer`的语句，最先被执行**。*

举个例子：

```go
func main() {
	fmt.Println("start")
	defer fmt.Println(1)
	defer fmt.Println(2)
	defer fmt.Println(3)
	fmt.Println("end")
}
```

输出结果：

```go
start
end
3
2
1
```

由于`defer`语句延迟调用的特性，所以`defer`语句能非常方便的处理资源释放问题。比如：资源清理、文件关闭、解锁及记录时间等。

### defer执行时机

在Go语言的函数中`return`语句在底层并不是原子操作，它分为给返回值赋值和RET指令两步。而`defer`语句执行的时机就在返回值赋值操作后，RET指令执行前。具体如下图所示：

![defer执行时机](https://img.herrluk.icu/typoraPicture/defer.png)

在计算机体系结构中，RET（Return）指令用于从子程序（或函数）中返回到调用它的主程序。当程序执行到一个子程序的调用指令时，它将保存调用指令的下一条指令的地址（也称为返回地址）并跳转到子程序的入口点。当子程序执行完毕时，它使用 RET 指令返回到调用它的主程序，并将返回地址从堆栈中弹出。

### defer经典案例

阅读下面的代码，写出最后的打印结果。

```go
func f1() int {
	x := 5
	defer func() {
		x++
	}()
	return x
}

func f2() (x int) {
	defer func() {
		x++
	}()
	return 5
}

func f3() (y int) {
	x := 5
	defer func() {
		x++
	}()
	return x
}
func f4() (x int) {
	defer func(x int) {
		x++
	}(x)
	return 5
}
func main() {
	fmt.Println(f1())
	fmt.Println(f2())
	fmt.Println(f3())
	fmt.Println(f4())
}
```

> 对函数 f3()
>
> 在 Go 语言中，对于有命名返回值的函数，如果在函数体中使用了一个 `return` 语句而没有指定返回值，则返回值将被自动设置为命名返回值的值。因此，在这个例子中，`return x` 实际上是返回了命名返回值 `y` 的值，即变量 `x` 的值。
>
> 在这个函数中，虽然 `defer` 语句会在函数返回之前对 `x` 进行加一操作，但是这个操作对命名返回值 `y` 并没有影响。**当函数执行到 `return x` 语句时，将会把 `x` 的值赋值给命名返回值 `y` 并返回，此时 `x` 的值为 `5`，因此函数返回值为 `5`。**
>
> 需要注意的是，在 Go 语言中，命名返回值是在函数定义时声明的，它们会被自动初始化为对应类型的零值。在这个例子中，命名返回值 `y` 的类型是 `int`，因此它的初始值为 `0`，而不是 `5` 或 `6`。
>
> 虽然 `defer` 语句在函数返回之前对 `x` 进行了加一操作，但这个操作对命名返回值 `y` 并没有影响，因此函数返回值为 `5`，而不是 `6`。
>
> 在函数体中，我们使用 `defer` 语句在函数返回之前对变量 `x` 的值进行了修改。由于 `defer` 语句的执行时机是在函数返回之前，因此最终命名返回值 `y` 的值将被修改为 `x` 的值加上 `1`，即 `6`。虽然 `return` 语句返回的是 `x` 的值，但实际上返回的是命名返回值 `y` 的值。

这段代码的输出如下：

```
5
6
5
5
```

我们逐个解释每个函数的输出：

- `f1()` 函数返回 `x` 的值，即 `5`。由于 `defer` 函数在 `return` 语句之后执行，因此在这个例子中，`x` 的值不会被修改。
- `f2()` 函数返回变量 `x` 的值，该变量在函数体中被初始化为 `5`。`defer` 函数在 `return` 语句之后执行，并将 `x` 的值加 `1`，因此最终返回值为 `6`。
- `f3()` 函数返回变量 `y` 的值，该变量在函数体中被初始化为 `0`（因为 `int` 类型的变量会自动初始化为 `0`）。与 `f1()` 函数类似，`defer` 函数在 `return` 语句之后执行，因此 `x` 的值不会被修改。因此最终返回值仍为 `5`。
- `f4()` 函数返回变量 `x` 的值，该变量在函数体中被初始化为 `5`。与 `f2()` 函数类似，`defer` 函数在 `return` 语句之后执行，并且它接受一个参数 `x`，该参数的值等于返回值的副本。因此，`defer` 函数中对 `x` 的修改不会影响返回值。因此最终返回值仍为 `5`。

总之，**`defer` 语句可以在函数返回之前执行某些操作，但是需要注意它们对变量值的修改是否会影响返回值。**



##### 关于命名返回值

Go 语言中的命名返回值是一种可以在函数定义时声明的特殊变量，用于指定函数的返回值。它通常用于函数返回多个值的情况。

在使用命名返回值时，需要在函数定义时在括号内指定返回值的名称及类型。例如：

```
func foo() (x int, y string) {
    x = 42
    y = "hello"
    return
}
```

在这个例子中，函数 `foo()` 返回两个值，一个是 `int` 类型的变量 `x`，一个是 `string` 类型的变量 `y`。在函数体中，我们可以像普通变量一样使用 `x` 和 `y`，并在函数返回时省略 `return` 语句，因为命名返回值会自动被返回。

使用命名返回值的好处是可以使函数的返回值更加清晰明了，同时还可以减少代码的重复性。例如，在返回多个值的函数中，如果不使用命名返回值，则需要在 `return` 语句中重复写出每个返回值的名称，这样的代码会比较冗长。

需要注意的是，如果在函数体中使用了 `return` 语句但没有指定返回值，则会使用命名返回值的默认值作为返回值。例如，如果上面的函数 `foo()` 中没有给 `x` 和 `y` 赋值而直接返回，则 `x` 的默认值为 `0`，`y` 的默认值为 `""`（空字符串）。

总之，命名返回值是 Go 语言中一个非常实用的特性，它可以让函数的返回值更加清晰明了，同时也可以减少代码的重复性。

##### 命名返回值是拷贝值吗

在 Go 语言中，命名返回值并不是拷贝值，而是直接返回变量的值。**换句话说，命名返回值和普通变量一样，都是直接引用函数内部的变量。**

因此，如果函数返回的是一个指针类型的命名返回值，那么该指针指向的是函数内部的变量，而不是拷贝值。如果在函数外部修改了该指针指向的变量，则会影响函数内部的变量。

需要注意的是，在有些情况下，命名返回值可能会被优化为栈上的变量，而不是堆上的变量。这样做的好处是可以避免在堆上分配内存，从而提高程序的性能。但在这种情况下，如果返回的是指针类型的命名返回值，那么该指针将指向栈上的变量，而不是堆上的变量。

总之，命名返回值并不是拷贝值，而是直接返回变量的值，因此需要注意在函数外部修改命名返回值的值可能会影响函数内部的变量。

### defer面试题

```go
func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}

func main() {
	x := 1
	y := 2
	defer calc("AA", x, calc("A", x, y))
	x = 10
	defer calc("BB", x, calc("B", x, y))
	y = 20
}
```

问，上面代码的输出结果是？（提示：defer注册要延迟执行的函数时该函数所有的参数都需要确定其值）

## 内置函数介绍(builtin包)

Golang 设计者为了编程方便，提供了一些函数，这些函数可以直接使用，我们称为 Go 的内置函数。文档：https://studygolang.com/pkgdoc -> `builtin`

|    内置函数    |                             介绍                             |
| :------------: | :----------------------------------------------------------: |
|     close      |                     主要用来关闭channel                      |
|      len       |      用来求长度，比如string、array、slice、map、channel      |
|      new       | 用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针 |
|      make      |   用来分配内存，主要用来分配引用类型，比如chan、map、slice   |
|     append     |                 用来追加元素到数组、slice中                  |
| panic和recover |                        用来做错误处理                        |

### panic/recover

1. Go 语言追求简洁优雅，所以，Go 语言不支持传统的 try…catch…finally  这种处理。
2. Go 中引入的处理方式为：defer, panic, recover
3. 这几个异常的使用场景可以这么简单描述：**Go 中可以抛出一个 panic 的异常，然后在 defer 中通过 recover 捕获这个异常，然后正常处理**。

Go语言中目前（Go1.12）是没有异常机制，但是使用`panic/recover`模式来处理错误。 `panic`可以在任何地方引发，但`recover`只有在`defer`调用的函数中有效。 首先来看一个例子：

```go
func funcA() {
	fmt.Println("func A")
}

func funcB() {
	panic("panic in B")
}

func funcC() {
	fmt.Println("func C")
}
func main() {
	funcA()
	funcB()
	funcC()
}
```

输出：

```bash
func A
panic: panic in B

goroutine 1 [running]:
main.funcB(...)
        .../code/func/main.go:12
main.main()
        .../code/func/main.go:20 +0x98
```

程序运行期间`funcB`中引发了`panic`导致程序崩溃，异常退出了。这个时候我们就可以通过`recover`将程序恢复回来，继续往后执行。

```go
func funcA() {
	fmt.Println("func A")
}

func funcB() {
	defer func() {
		err := recover()
		//如果程序出出现了panic错误,可以通过recover恢复过来
		if err != nil {
			fmt.Println("recover in B")
		}
	}()
	panic("panic in B")
}

func funcC() {
	fmt.Println("func C")
}
func main() {
	funcA()
	funcB()
	funcC()
}
```

**注意：**

1. `recover()`必须搭配`defer`使用。
2. `defer`一定要在可能引发`panic`的语句之前定义。

## 类型别名和自定义类型

### 自定义类型

在Go语言中有一些基本的数据类型，如`string`、`整型`、`浮点型`、`布尔`等数据类型， Go语言中可以使用`type`关键字来定义自定义类型。

自定义类型是定义了一个全新的类型。我们可以基于内置的基本类型定义，也可以通过struct定义。例如：

```go
//将MyInt定义为int类型
type MyInt int
```

通过`type`关键字的定义，`MyInt`就是一种新的类型，它具有`int`的特性。

### 类型别名

类型别名是`Go1.9`版本添加的新功能。

类型别名规定：TypeAlias只是Type的别名，本质上TypeAlias与Type是同一个类型。就像一个孩子小时候有小名、乳名，上学后用学名，英语老师又会给他起英文名，但这些名字都指的是他本人。

```go
type TypeAlias = Type
```

**我们之前见过的`rune`和`byte`就是类型别名，他们的定义如下**：

```go
type byte = uint8
type rune = int32
```

### 类型定义和类型别名的区别

类型别名与类型定义表面上看只有一个等号的差异，我们通过下面的这段代码来理解它们之间的区别。

```go
//类型定义
type NewInt int

//类型别名
type MyInt = int

func main() {
	var a NewInt
	var b MyInt
	
	fmt.Printf("type of a:%T\n", a) //type of a:main.NewInt
	fmt.Printf("type of b:%T\n", b) //type of b:int
}
```

结果显示a的类型是`main.NewInt`，表示main包下定义的`NewInt`类型。b的类型是`int`。`MyInt`类型只会在代码中存在，编译完成时并不会有`MyInt`类型。



