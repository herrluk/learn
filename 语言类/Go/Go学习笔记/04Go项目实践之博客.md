# 准备工作

# 3.开始编码

## 新建项目

## 一个简单的 Go Web 程序

**main.go**

```go
package main

import (
    "fmt"
    "net/http"
)

func handlerFunc(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "<h1>Hello, 这里是 goblog</h1>")
}

func main() {
    http.HandleFunc("/", handlerFunc)
    http.ListenAndServe(":3000", nil)
}
```

### package main

```php
package main
```

每一段 Go 程序都 **必须** 属于一个包。而 main 包在 Go 程序中有特殊的位置。

> 一个标准的可执行的 Go 程序必须有 `package main` 的声明。

如果一段程序是属于 main 包的，那么当执行 `go install` 或者 `go run` 时就会将其生成二进制文件，当执行这个文件时，就会调用 `main` 函数。

main 包里的 `main` 函数相当于应用程序的入口。要想生成可执行的二进制文件，必须把代码写在 `main` 包里，而且其中必须包含一个 `main` 函数。

> **小知识：** 存放 `main` 函数的文件名称不一定是 main.go，也可以是任何其他合规的 go 文件名称，例如 app.go、index.go。一般推荐使用 main.go，因为直观。

### import

```php
import (
    "fmt"
    "net/http"
)
```

我们使用 `import` 关键词用以引入程序所需的 Go 包。在 goblog 中，我们引入了两个 **Go 标准库的包**。

#### 第一个是 `fmt` 包

fmt 是使用频率非常高的一个包。它是 `format` 的缩写，fmt 包含有格式化 I/O 函数。主要分为向外输出内容和获取输入内容两大部分。

```php
fmt.Fprint(w, "<h1>Hello, 这里是 goblog</h1>")
```

> fmt 的 `Fprint` 函数会将内容输出到实现了 `io.Writer` 接口类型的变量 `w` 中，我们通常用这个函数往文件中写入内容。**注意，只要满足 `io.Writer` 接口的类型都支持写入。**在我们的代码中 `w` 是 `http.ResponseWriter` 的实例，已经实现了 `io.Writer` 接口。

#### 第二个是 `net/http` 包

标准库 `net/http` 提供了 HTTP 编程有关的接口，内部封装了 TCP 连接和报文解析的复杂琐碎细节。http 提供了 HTTP 客户端和服务器实现。

HTTP 客户端可用以发送请求到第三方 API 或者请求网页，以获取所需数据，类似于 curl 或者 wget 。

HTTP 服务器用以提供 HTTP 服务器来处理 HTTP 请求，此处我们使用了此功能：

```php
func handlerFunc(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "<h1>Hello, 这里是 goblog</h1>")
}

func main() {
    http.HandleFunc("/", handlerFunc)
    http.ListenAndServe(":3000", nil)
}
```

### **http.ListenAndServe**

`http.ListenAndServe` 用以监听本地 3000 端口以提供服务，标准的 HTTP 端口是 80 端口，如 `baidu.com:80`，另一个 Web 常用是 HTTPS 的 443 端口，如 `baidu.com:443`。当我们监听本地端口时，可使用 `localhost` 加上端口号来访问，如以下代码：

```php
http.ListenAndServe(":3000", nil)
```

我们可以通过 [localhost:3000/](http://localhost:3000/) 进行访问。

### **http.HandleFunc**

`http.HandleFunc` 用以指定处理 HTTP 请求的函数，**此函数允许我们只写一个 handler（在此例子中 `handlerFunc`，可任意命名），请求会通过参数传递进来，使用者只需与 `http.Request` 和 `http.ResponseWriter` 两个对象交互即可。**

在：

```php
fmt.Fprint(w, "<h1>Hello, 这里是 goblog</h1>")
```

中，我们利用 `fmt.Fprint` 将 `<h1>Hello, 这里是 goblog</h1>` 子串写入 `http.ResponseWriter`，即可响应用户请求。

### **http.Request**

`http.Request` 是用户的请求信息，一般用 `r` 作为简写。

一些常见的操作如：

- `r.URL.Query()` 获取用户参数
- 获取客户端信息 `r.Header.Get("User-Agent")`

### **http.ResponseWriter**

`http.ResponseWriter` 是返回用户的响应，一般用 `w` 作为简写。

常见操作如：

- 返回 500 状态码 `w.WriteHeader(http.StatusInternalServerError)`
- 设置返回标头 `w.Header().Set("name", "my name is smallsoup")`

> **提示：** 后面我们会有具体示例来讲解 http 包的更多用法，以上信息阅读并尝试理解即可。

### 什么是 Go 标准库？

Go 语言标准库是由 Go 官方团队维护，包含在 Go 语言安装包中的 Go 包。

对于 Go 程序员而言，标准库与语言本身同样重要，它好比一个百宝箱，能为各种常见的任务提供解决方案。

以下是 Go 标准库常见的包以及功能介绍：

| 标准库包名 | 功能简介                                                     |
| ---------- | ------------------------------------------------------------ |
| bufio      | 带缓冲的 I/O 操作                                            |
| bytes      | 实现字节操作                                                 |
| container  | 封装堆、列表和环形列表等容器                                 |
| crypto     | 加密算法                                                     |
| database   | 数据库驱动和接口                                             |
| debug      | 各种调试文件格式访问及调试功能                               |
| encoding   | 常见算法如 JSON、XML、Base64 等                              |
| flag       | 命令行解析                                                   |
| fmt        | 格式化操作                                                   |
| go         | Go 语言的词法、语法树、类型等。可通过这个包进行代码信息提取和修改 |
| html       | HTML 转义及模板系统                                          |
| image      | 常见图形格式的访问及生成                                     |
| io         | 实现 I/O 原始访问接口及访问封装                              |
| math       | 数学库                                                       |
| net        | 网络库，支持 Socket、HTTP、邮件、RPC、SMTP 等                |
| os         | 操作系统平台不依赖平台操作封装                               |
| path       | 兼容各操作系统的路径操作实用函数                             |
| plugin     | Go 1.7 加入的插件系统。支持将代码编译为插件，按需加载        |
| reflect    | 语言反射支持。可以动态获得代码中的类型信息，获取和修改变量的值 |
| regexp     | 正则表达式封装                                               |
| runtime    | 运行时接口                                                   |
| sort       | 排序接口                                                     |
| strings    | 字符串转换、解析及实用函数                                   |
| time       | 时间接口                                                     |
| text       | 文本模板及 Token 词法器                                      |

以上的包你只需要阅读并尝试理解即可，无需死记硬背。随着本课程以及对 Go 语言学习的深入，这些包对你来说会如数家珍。

## 新增页面

本节我们来开始为 goblog 应用新增页面。

### URL 路径解析

goblog 中 URL 路径解析的代码如下：

```php
http.HandleFunc("/", handlerFunc)
```

新人在学习 http 包时，很多时候会误以为这段代码中反斜杠 `/` 是站点的根目录，其实不然。

我们来做个试验：

*main.go*

```php
package main

import (
    "fmt"
    "net/http"
)

func handlerFunc(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "<h1>Hello, 这里是 goblog</h1>")
    fmt.Fprint(w, "请求路径为："+r.URL.Path)
}

func main() {
    http.HandleFunc("/", handlerFunc)
    http.ListenAndServe(":3000", nil)
}
```

以上代码我们新增了这一行：

```php
fmt.Fprint(w, "请求路径为："+r.URL.Path)
```

用以打印当前请求的路径，保存修改后，我们重新启动程序：

```php
$ go run main.go
```

> **注意：** 如果你之前已运行过以上命令，请 Ctrl + C 退出，然后再重新运行以上命令。

浏览器访问以下三个链接，看看页面显示的结果：

- [localhost:3000/](http://localhost:3000/)
- [localhost:3000/about](http://localhost:3000/about)
- [localhost:3000/no-where](http://localhost:3000/no-where)

例如：

![新增页面](https://img.herrluk.icu/typoraPicture/2023-02-01-20:53:08.png)

**可以看出，`http.HandleFunc` 里传参的 `/` 意味着 任意路径。**

我们可以利用此机制来设置多页面访问，修改代码如下：

*main.go*

```php
package main

import (
    "fmt"
    "net/http"
)

func handlerFunc(w http.ResponseWriter, r *http.Request) {
    if r.URL.Path == "/" {
        fmt.Fprint(w, "<h1>Hello, 这里是 goblog</h1>")
    } else if r.URL.Path == "/about" {
        fmt.Fprint(w, "此博客是用以记录编程笔记，如您有反馈或建议，请联系 "+
            "<a href=\"mailto:summer@example.com\">summer@example.com</a>")
    } else {
        fmt.Fprint(w, "<h1>请求页面未找到 :(</h1>"+
            "<p>如有疑惑，请联系我们。</p>")
    }
}

func main() {
    http.HandleFunc("/", handlerFunc)
    http.ListenAndServe(":3000", nil)
}
```

新增了 about 页面，浏览器尝试访问 [localhost:3000/about](http://localhost:3000/about) ：

![新增页面](https://img.herrluk.icu/typoraPicture/2023-02-01-20:53:08.png)

跟我们的预期不一致，那是因为我们需要重启 `go run` 命令。使用 Ctrl + C 中断内置命令行中 `go run` 的运行，然后再：

```php
$ go run main.go
```

重启后再次访问 [localhost:3000/about](http://localhost:3000/about) ：

![新增页面](https://img.herrluk.icu/typoraPicture/2023-02-01-20:53:08.png)

可以看到逻辑已更新。如果我们随意访问一个不存在的页面，如 [localhost:3000/no-exists](http://localhost:3000/no-exists) 还可以看到：

![新增页面](https://img.herrluk.icu/typoraPicture/2023-02-01-20:53:08.png)

我们现在有两个问题。

第一个问题是修改代码后都需要手动去 Ctrl+C 停止 `go run` 命令，再重新运行。效率低下。

第二个问题是 about 页面的解析并不如我们的预想的那样，客户端并没有将内容按照 HTML 格式来解析。

后面的章节里我们将逐个解决这些问题。

### 版本控制

本节我们新增了 about 页面，开始下节课之前我们先来做版本标记：

```php
$ git add .
$ git commit -m "新增关于页面"
```

## 自动重载

Go 语言为编译型语言，编译型语言有诸多好处，如：

- 部署简单
- 提早发现错误
- 执行效率高

然而这也意味着代码修改后需重新编译才能看到变更，这为我们本地开发带来了诸多不便。

本节中我们将一起探讨如何使用第三方工具来提高开发效率。

### 初始化 Go Modules

air 需要项目是 Go Modules 才能工作，我们先：

```php
$ go mod init
```

> 注意：Go Modules 我们后面章节中会详细讲解。

### 安装 air

自动重载方案，比较老牌的是 [fresh](https://github.com/gravityblast/fresh) ，不过此项目已经放弃维护。

本课程我们将使用的是 [air](https://github.com/cosmtrek/air)。接下来先安装 air 。

使用以下命令来安装 air ：

```php
$ GO111MODULE=on  go install github.com/cosmtrek/air@latest
```

（windows 下 [github.com/cosmtrek/air/releases](https://github.com/cosmtrek/air/releases) 此处下载后放入 Go 安装目录下的 bin 目录，重命名为 air.exe）

最前面的 `GO111MODULE=on` 是只为当前命令启用 Go Module，开启以后我们才能使用 [Go Proxy 进行加速](https://learnku.com/go/wikis/38122)。后续我们会深入讲解 Go Module ，这里你只需要记住这个用法即可。

> **注意：** 以上操作如果遇到错误，请先确保你的 Go 版本是 1.17。使用此命令查看 `go version`。

安装成功后使用以下命令检查下：

```php
$ air -v

  __    _   ___
 / /\  | | | |_)
/_/--\ |_| |_| \_ , built with Go
```

### 使用 air

在我们的 goblog 项目根目录运行以下命令：

```php
$ air
```

在 VSCode 内置命令行中执行结果如下：

![自动重载](https://img.herrluk.icu/typoraPicture/2023-02-01-21:33:51.png)

此时浏览器访问 [localhost:3000/](http://localhost:3000/) ：

![自动重载](https://img.herrluk.icu/typoraPicture/2023-02-01-21:33:51.png)

### 测试自动加载

修改 main.go 文件如下：

*main.go*

```php
package main

import (
    "fmt"
    "net/http"
)

func handlerFunc(w http.ResponseWriter, r *http.Request) {
    if r.URL.Path == "/" {
        fmt.Fprint(w, "<h1>Hello, 欢迎来到 goblog！</h1>")
    } else if r.URL.Path == "/about" {
        fmt.Fprint(w, "此博客是用以记录编程笔记，如您有反馈或建议，请联系 "+
            "<a href=\"mailto:summer@example.com\">summer@example.com</a>")
    } else {
        fmt.Fprint(w, "<h1>请求页面未找到 :(</h1>"+
            "<p>如有疑惑，请联系我们。</p>")
    }
}

func main() {
    http.HandleFunc("/", handlerFunc)
    http.ListenAndServe("localhost:3000", nil)
}
```

保存后可以看到命令行有相关的更信息：

![自动重载](https://img.herrluk.icu/typoraPicture/2023-02-01-21:33:51.png)

浏览器访问 [localhost:3000/](http://localhost:3000/) ：

![自动重载](https://img.herrluk.icu/typoraPicture/2023-02-01-21:33:51.png)

即可看到我们修改后的欢迎语。至此我们成功集成了 air 自动重置功能。

后续的课程中，请确保 air 命令行时刻处于运行状态。air 还有很多参数可供设置，我们会在后续课程中使用到时再做讲解。

### 新的命令行窗口

为了保持 air 窗口持续运行着，我们点击 `+` 按钮新建命令行窗口，并使用命令:

```php
$ git status
```

来查看文件修改状态：

![自动重载](https://img.herrluk.icu/typoraPicture/2023-02-01-21:33:51.png)

从上图可以看到我们的根目录下多了一个 `tmp` 文件夹，这是 air 命令的编译文件存放地。我们需要设置版本控制器将其排除在外：

*.gitignore*

```php
tmp
```

再次执行 `git status` 即可看到 tmp 目录已被排除在外：

![自动重载](https://img.herrluk.icu/typoraPicture/2023-02-01-21:33:51.png)

接下来我们可以放心地将代码纳入版本控制器中：

```php
$ git add .
$ git commit -m "自动重载"
```



## 设置标头

本节我们将为返回内容设置正确的标头，以解决 about 页面 HTML 无法正确解析的问题。

同时，我们将一起学习如何在本地查阅 Go 文档。

### 查看标头信息

**什么是 HTTP 标头？**

HTTP 请求是无状态的，HTTP 标头是客户端与服务端通讯的重要方式。

### 设置标头

**如何查看标头呢？**

访问 [learnku.com/](https://learnku.com/) ，网页上右键菜单选择『审查元素』，选中『网络』栏目，为方便区分我们点击前面的小三角形进行折叠：

![设置标头](https://img.herrluk.icu/typoraPicture/2023-02-01-21:43:40.png)

查看响应标头：

![设置标头](https://img.herrluk.icu/typoraPicture/2023-02-01-21:43:40.png)

浏览器 [localhost:3000](http://localhost:3000/) ，右键查看网络请求：

![设置标头](https://img.herrluk.icu/typoraPicture/2023-02-01-21:43:40.png)

可以看到的我们的 Web 服务器只返回了几个标头，且 `Content-Type:` 的内容为 `text/html; charset=utf-8`。

查看解析有问题的 [localhost:3000/about](http://localhost:3000/about) 页面：

![设置标头](https://img.herrluk.icu/typoraPicture/2023-02-01-21:43:40.png)

可以看到服务端返回的 `Content-Type:` 的值为 `text/plain; charset=utf-8` ，很明显标头错误了。

### Content-Type 标头

`Content-Type:` 响应标头是告知客户端内容的类型，客户端再根据这个信息将内容正确地呈现给用户。

常见的内容类型有：

- `text/html` —— HTML 文档
- `text/plain` —— 文本内容
- `text/css`—— CSS 样式文件
- `text/javascript` —— JS 脚本文件
- `application/json`—— JSON 格式的数据
- `application/xml` —— XML 格式的数据
- `image/png` —— PNG 图片

接下来我们将尝试服务端返回正确的 `Content-Type:` 标头。

### 返回正确的 `Content-Type:`

*main.go*

```php
package main

import (
    "fmt"
    "net/http"
)

func handlerFunc(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    if r.URL.Path == "/" {
        fmt.Fprint(w, "<h1>Hello, 欢迎来到 goblog！</h1>")
    } else if r.URL.Path == "/about" {
        fmt.Fprint(w, "此博客是用以记录编程笔记，如您有反馈或建议，请联系 "+
            "<a href=\"mailto:summer@example.com\">summer@example.com</a>")
    } else {
        fmt.Fprint(w, "<h1>请求页面未找到 :(</h1>"+
            "<p>如有疑惑，请联系我们。</p>")
    }
}

func main() {
    http.HandleFunc("/", handlerFunc)
    http.ListenAndServe(":3000", nil)
}
```

浏览器访问 [localhost:3000/about](http://localhost:3000/about)

![设置标头](https://img.herrluk.icu/typoraPicture/2023-02-01-21:43:40.png)

可以看到标头成功设置，内容也被正确解析为 HTML 了。

### 如何知道 http 包有哪些接口呢？

上面的代码中，我们使用这一行来设置标头：

```php
w.Header().Set("Content-Type", "text/html; charset=utf-8")
```

那么我们怎么知道 `w` 对象所代表的 `http.ResponseWriter` 有哪些接口的呢？

答：看 Go 文档。

### 本地查看 Go 文档

在我们的 goblog 项目目录下，命令行运行：

```php
$ godoc -http=:6060
```

[localhost:6060/pkg/](http://localhost:6060/pkg/) 进入标准库文档，定位到 `net/http`:

![设置标头](https://img.herrluk.icu/typoraPicture/2023-02-01-21:43:40.png)

在索引里定位 `type ResponseWriter` 的定义（ [快速链接](http://localhost:6060/pkg/net/http/#ResponseWriter) ）：

![设置标头](https://img.herrluk.icu/typoraPicture/2023-02-01-21:43:40.png)

滚动下来，点击 `Example` 取消折叠，即可看到示例代码：

![设置标头](https://img.herrluk.icu/typoraPicture/2023-02-01-21:43:40.png)

> **提示：** Go 是开源软件，标准库的文档非常齐全。早期学习 Go 时，要培养自己查阅 API 文档的习惯。可能一开始你会找不到方向，或者因为信息量太大而产生焦虑，看不下去，没关系，我们每个人都会这样。谨记，作为一个优秀的 Go 程序员，阅读文档是必备的修行。

### 版本控制

本节我们修复了 about 页面未能正确解析 HTML 的 Bug，开始下一节之前，我们先标记下代码版本：

```php
$ git add .
$ git commit -m "设置标头"
```



## 404 状态码

本节我们将为 goblog 添加正确 404 响应状态码。

### Web 数据响应

Web 的响应与请求结构是类似的，响应分为三个部分：响应行、响应头部、响应体。

> 1. 响应行：协议、响应状态码和状态描述，如： `HTTP/1.1 200 OK`
> 2. 响应标头：包含各种头部字段信息，如 cookie，Content-Type 等头部信息。
> 3. 响应体：携带客户端想要的数据，格式与编码由头部的 Content-Type 决定。

**响应状态码的有固定取值和意义：**

> - 100~199：表示服务端成功接收客户端请求，要求客户端继续提交下一次请求才能完成整个处理过程。
> - 200~299：表示服务端成功接收请求并已完成整个处理过程。最常用就是：200
> - 300~399：为完成请求，客户端需进一步细化请求。比较常用的如：客户端请求的资源已经移动一个新地址使用 302 表示将资源重定向，客户端请求的资源未发生改变，使用 304，告诉客户端从本地缓存中获取。
> - 400~499：客户端的请求有错误，如：404 表示你请求的资源在 web 服务器中找不到，403 表示服务器拒绝客户端的访问，一般是权限不够。
> - 500~599：服务器端出现错误，最常用的是：500

### 404 标头

在 http 包中我们是通过与 `http.ResponseWriter` 交互来改变响应内容的，要添加的 HTTP 状态码的话，我们先访问 `ResponseWriter` 的文档 [localhost:6060/pkg/net/http/#Respon...](http://localhost:6060/pkg/net/http/#ResponseWriter) ：

> **提示：** 本地文档访问请运行命令 `godoc -http=:6060` 。

![404 状态码](https://img.herrluk.icu/typoraPicture/2023-02-01-23:09:23-WvGqBg.png)

可以看到提供了 `WriteHeader()` 方法以及代码示例：

```php
w.WriteHeader(http.StatusOK)
```

页面按快捷键 `Ctrl+F` 搜索关键词 `StatusOK`，即可定位到设置状态码的常量：

![404 状态码](https://img.herrluk.icu/typoraPicture/2023-02-01-23:09:44-DvO9J5.png)

选中我们的 404 状态码，在代码中添加：

**main.go**

```php
package main

import (
    "fmt"
    "net/http"
)

func handlerFunc(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    if r.URL.Path == "/" {
        fmt.Fprint(w, "<h1>Hello, 欢迎来到 goblog！</h1>")
    } else if r.URL.Path == "/about" {
        fmt.Fprint(w, "此博客是用以记录编程笔记，如您有反馈或建议，请联系 "+
            "<a href=\"mailto:summer@example.com\">summer@example.com</a>")
    } else {
        w.WriteHeader(http.StatusNotFound)
        fmt.Fprint(w, "<h1>请求页面未找到 :(</h1>"+
            "<p>如有疑惑，请联系我们。</p>")
    }
}

func main() {
    http.HandleFunc("/", handlerFunc)
    http.ListenAndServe(":3000", nil)
}
```

顺便访问一个不存在的页面：

![404 状态码](https://img.herrluk.icu/typoraPicture/2023-02-01-22:47:46.png)

### 版本控制

接下来把代码纳入版本控制器中：

```php
$ git add .
$ git commit -m "404 状态码"
```

# 4.路由和中间件

## 路由 - http.ServeMux

goblog 需要一款灵活的路由器来搭配 MVC 程序结构。Go Web 开发有各式各样的路由器可供选择，我们先来看下 Go 标准库 `net/http` 包里的 http.ServeMux。

### ServeMux 和 Handler

Go 语言中处理 HTTP 请求主要跟两个东西相关：ServeMux 和 Handler。

**ServeMux 本质上是一个 HTTP 请求路由器（或者叫多路复用器，Multiplexor）。它把收到的请求与一组预先定义的 URL 路径列表做对比，然后在匹配到路径的时候调用关联的处理器（Handler）。**

http 的 ServeMux 虽听起来陌生，事实上我们已经在使用它了。

### 重构：区分不同的 Handler

先来重构下我们的代码，修改如下：

*main.go*

```php
package main

import (
    "fmt"
    "net/http"
)

func defaultHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    if r.URL.Path == "/" {
        fmt.Fprint(w, "<h1>Hello, 欢迎来到 goblog！</h1>")
    } else {
        w.WriteHeader(http.StatusNotFound)
        fmt.Fprint(w, "<h1>请求页面未找到 :(</h1>"+
            "<p>如有疑惑，请联系我们。</p>")
    }
}

func aboutHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    fmt.Fprint(w, "此博客是用以记录编程笔记，如您有反馈或建议，请联系 "+
        "<a href=\"mailto:summer@example.com\">summer@example.com</a>")
}

func main() {
    http.HandleFunc("/", defaultHandler)
    http.HandleFunc("/about", aboutHandler)
    http.ListenAndServe(":3000", nil)
}
```

浏览器访问以下三个链接，发现与之前一致：

- [localhost:3000/](http://localhost:3000/)
- [localhost:3000/about](http://localhost:3000/about)
- [localhost:3000/no-where](http://localhost:3000/no-where)

### 查看 http.HandleFunc 源码

在 VSCode 编辑器里，把鼠标放置在 main 方法中的 `http.HandleFunc` 上，并同时按住 Ctrl 键（不要松开），当出现下划线的时候，点击进去：

![http.ServeMux](https://img.herrluk.icu/typoraPicture/2023-02-01-23:27:22-CRGNtq.png)

此时我们看到的代码，是 `net/http` 包的源码。显而易见，http 包也是由 Go 代码实现的。

仔细看下 HandleFunc 函数的定义：

```php
func HandleFunc(pattern string, handler func(ResponseWriter, *Request)) {
    DefaultServeMux.HandleFunc(pattern, handler)
}
```

参数：

- `pattern` 是 URI 的规则，例如 `/` 或者 `about`
- `handler` 是供调用的函数

`http.HandleFunc()` 函数是对 `DefaultServeMux.HandleFunc()` 的封装，而我们在用相同的方法查看 `http.ListenAndServe()` 的源码：

![路由器 - http.ServeMux](https://img.herrluk.icu/typoraPicture/2023-02-01-23:27:22-vtFIGe.png)

注释里有这么一段：

```php
The handler is typically nil, in which case the DefaultServeMux is used.
```

handler 通常为 nil，此种情况下会使用 DefaultServeMux。

### 重构：使用自定义的 ServeMux

重构如下：

*main.go*

```php
.
.
.

func main() {
    router := http.NewServeMux()

    router.HandleFunc("/", defaultHandler)
    router.HandleFunc("/about", aboutHandler)

    http.ListenAndServe(":3000", router)
}
```

浏览器访问以下三个链接，与之前一致：

- [localhost:3000/](http://localhost:3000/)
- [localhost:3000/about](http://localhost:3000/about)
- [localhost:3000/no-where](http://localhost:3000/no-where)

### http.ServeMux 的局限性

http.ServeMux 在 goblog 中使用，会遇到以下几个问题：

- 不支持 URI 路径参数
- 不支持请求方法过滤
- 不支持路由命名

**URI 路径参数**

例如说博客详情页，我们的 URI 是 `articles/1` 这样来查看 ID 为 1 的文章。http.ServeMux 也可以实现，新增一个路由作为示范：

*main.go*

```php
.
.
.
func main() {
    router := http.NewServeMux()

    router.HandleFunc("/", defaultHandler)
    router.HandleFunc("/about", aboutHandler)

    // 文章详情
    router.HandleFunc("/articles/", func(w http.ResponseWriter, r *http.Request) {
        id := strings.SplitN(r.URL.Path, "/", 3)[2]
        fmt.Fprint(w, "文章 ID："+id)
    })

    http.ListenAndServe(":3000", router)
}
```

不够直观，且徒增了代码的维护成本。

**请求方法过滤**

无法直接从路由上区分 POST 或者 GET 等 HTTP 请求方法，只能手动判断，例如：

*main.go*

```php
.
.
.
func main() {
    .
    .
    .


    // 列表 or 创建
    router.HandleFunc("/articles", func(w http.ResponseWriter, r *http.Request) {
        switch r.Method {
        case "GET":
            fmt.Fprint(w, "访问文章列表")
        case "POST":
            fmt.Fprint(w, "创建新的文章")
        }
    })

    http.ListenAndServe(":3000", router)
}
```

我们使用 CURL 来测试下：

```php
$ curl http://localhost:3000/articles
访问文章列表%                                                                                                                       
$ curl -X POST http://localhost:3000/articles
创建新的文章% 
```

可以实现，但是要多出来很多代码。

**不支持路由命名**

路由命名是一套允许我们快速修改页面里显示 URL 的机制。

例如说我们的文章详情页，URL 是

```php
http://example.com/articles/{id}
```

项目随着时间的推移，变得非常巨大，在几十个页面里都存在这个 URI 。突然有个需求或者有其他不可控因素，要求我们修改链接为：

```php
http://example.com/posts/{id}
```

那么我们只能到这个几十个页面里去修改。

使用路由命名的话，我们为 `articles/{id}` 这个路由命名为 `articles.show`，几十个页面在编码时，都使用这个路由名称而不是具体的 URI，遇到修改的需求时，我们只需在定义路由这一个地方修改即可。

目前 http.ServeMux 不支持此功能。

### http.ServeMux 的优缺点

如上所述，Go 开源社区里有诸多路由器可供选择，那么标准库的 http.ServeMux 对比这些路由器有什么优缺点呢？

**优点**

- 标准库意味着随着 Go 打包安装，无需另行安装
- 测试充分
- 稳定、兼容性强
- 简单，高效

**缺点**

- 缺少 Web 开发常见的特性
- 在复杂的项目中使用，需要你写更多的代码

开发效率和运行效率，永远是对立面。

Go 因为其诞生的背景（Google 的大流量），以及核心成员的出身（底层语言和系统的缔造者），Go 标准库选择 **运行效率** 高于 开发效率，所以对一些常见的功能并没有添加到标准库中，这是情有可原的。

然而在 goblog 中，我们将会有数据库等与第三方服务的请求操作，跟这类编码比起来，路由解析这点性能优化微不足道。所以在这个项目中，我们将在性能不会牺牲太大的情况下，选择 **开发效率** 多一点。

### 标准库里的就是最好的？

新手常常会认为标准库里的就是最好的。其实不然，标准库也是由 Go 语言编写的。

就拿 `net/http` 来讲，GitHub 上有一个项目专门对 [Go 中知名的 HTTP 路由器性能做对比](https://github.com/julienschmidt/go-http-routing-benchmark)，结果是第三方包 [HttpRouter](https://github.com/julienschmidt/httprouter) 比 http.ServeMux 还要快不少。

事实上，标准库最大的优点是 Go 自带。

所以不止在选择 HTTP 服务器，在选择其他解决方案时，都可以大胆的使用一些 Go 开源社区优秀的第三方包。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "尝试 http.ServeMux"
```

## 使用 gorilla/mux



### 为什么不选择 HttpRouter？

[HttpRouter](http://github.com/julienschmidt/httprouter) 是目前来讲速度最快的路由器，且被知名框架 [Gin](http://github.com/gin-gonic/gin) 所采用。

不选择 HttpRouter 的原因是其功能略显单一，没有路由命名功能，不符合我们的要求。

HttpRouter 和 Gin 比较适合在要求高性能，且路由功能要求相对简单的项目中，如 API 或微服务。在全栈的 Web 开发中，gorilla/mux 在性能上虽然有所不及，但是功能强大，比较实用。

### 安装 gorilla/mux

这是我们第一次安装第三方依赖，goblog 项目将使用官方推荐的 Go Module 来管理第三方依赖。

Go Modules 相关知识下一节再来讲。本节专注于安装和使用 gorilla/mux。

下面使用 `go get` 命令安装 gorilla/mux ：

```php
$ go get -u github.com/gorilla/mux
```

### 使用 gorilla/mux

gorilla/mux 因实现了 net/http 包的 `http.Handler` 接口，故兼容 http.ServeMux ，也就是说，我们可以直接修改一行代码，即可将 gorilla/mux 集成到我们的项目中：

```
func main() {
    router := mux.NewRouter()
    .
    .
    .
}
```

依次以下链接：

1. [localhost:3000/](http://localhost:3000/)
2. [localhost:3000/about](http://localhost:3000/about)
3. [localhost:3000/articles](http://localhost:3000/articles)
4. [localhost:3000/no-exists](http://localhost:3000/no-exists)
5. [localhost:3000/articles/2](http://localhost:3000/articles/2)
6. [localhost:3000/articles/](http://localhost:3000/articles/)

可以发现：

- 1、2 和 3 可以正常访问。
- 4 无法访问到自定义的 404 页面
- 5 文章详情页无法访问
- 6 可以访问到文章页面，但是 ID 为空

因为 gorilla/mux 的路由解析采用的是 **精准匹配** 规则，而 net/http 包使用的是 **长度优先匹配** 规则。

- **精准匹配** 指路由只会匹配准确指定的规则，这个比较好理解，也是较常见的匹配方式。
- **长度优先匹配** 一般用在静态路由上（不支持动态元素如正则和 URL 路径参数），优先匹配字符数较多的规则。

以我们的 goblog 为例：

```php
router.HandleFunc("/", defaultHandler)
router.HandleFunc("/about", aboutHandler)
```

使用 **长度优先匹配** 规则的 http.ServeMux 会把除了 `/about` 这个匹配的以外的所有 URI 都使用 `defaultHandler` 来处理。

而使用 **精准匹配** 的 gorilla/mux 会把以上两个规则精准匹配到两个链接，`/` 为首页，`/about` 为关于，除此之外都是 `404 未找到`。

知道这个规则后，配合上面几个测试链接的返回结果，会更好理解。

> 一般 **长度优先匹配** 规则用在静态内容处理上比较合适，动态内容，例如我们的 goblog 这种动态网站，使用 **精准匹配** 会比较方便。
>

### 迁移到 Gorilla Mux

基于以上规则，接下来改进代码：

*main.go*

```php
package main

import (
    "fmt"
    "net/http"

    "github.com/gorilla/mux"
)

func homeHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    fmt.Fprint(w, "<h1>Hello, 欢迎来到 goblog！</h1>")
}

func aboutHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    fmt.Fprint(w, "此博客是用以记录编程笔记，如您有反馈或建议，请联系 "+
        "<a href=\"mailto:summer@example.com\">summer@example.com</a>")
}

func notFoundHandler(w http.ResponseWriter, r *http.Request) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")
    w.WriteHeader(http.StatusNotFound)
    fmt.Fprint(w, "<h1>请求页面未找到 :(</h1><p>如有疑惑，请联系我们。</p>")
}

func articlesShowHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id := vars["id"]
    fmt.Fprint(w, "文章 ID："+id)
}

func articlesIndexHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "访问文章列表")
}

func articlesStoreHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "创建新的文章")
}

func main() {
    router := mux.NewRouter()

    router.HandleFunc("/", homeHandler).Methods("GET").Name("home")
    router.HandleFunc("/about", aboutHandler).Methods("GET").Name("about")

    router.HandleFunc("/articles/{id:[0-9]+}", articlesShowHandler).Methods("GET").Name("articles.show")
    router.HandleFunc("/articles", articlesIndexHandler).Methods("GET").Name("articles.index")
    router.HandleFunc("/articles", articlesStoreHandler).Methods("POST").Name("articles.store")

    // 自定义 404 页面
    router.NotFoundHandler = http.HandlerFunc(notFoundHandler)

    // 通过命名路由获取 URL 示例
    homeURL, _ := router.Get("home").URL()
    fmt.Println("homeURL: ", homeURL)
    articleURL, _ := router.Get("articles.show").URL("id", "23")
    fmt.Println("articleURL: ", articleURL)

    http.ListenAndServe(":3000", router)
}
```

接下来我们一步步分解代码。

#### 1. 新增 homeHandler

首先，因为使用的是精确匹配，我们将 `defaultHandler` 变更 `homeHandler` 且将处理 404 的代码移除。

#### 2. 指定 Methods () 来区分请求方法

看下这两个路由：

```php
router.HandleFunc("/articles", articlesIndexHandler).Methods("GET").Name("articles.index")
router.HandleFunc("/articles", articlesStoreHandler).Methods("POST").Name("articles.store")
```

命令行：

```php
$ curl http://localhost:3000/articles
访问文章列表%
$ curl -X POST http://localhost:3000/articles
创建新的文章%
```

解析正确。

> **注意：** 在 Gorilla Mux 中，如未指定请求方法，默认会匹配所有方法。

### 请求路径参数和正则匹配

我们的文章详情页面的匹配：

```php
router.HandleFunc("/articles/{id:[0-9]+}", articlesShowHandler).Methods("GET").Name("articles.show")
```

注意 ID 路径的设置：

```php
{id:[0-9]+}
```

有以下规则：

- 使用 `{name}` 花括号来设置路径参数
- 在有正则匹配的情况下，使用 `:` 区分。第一部分是名称，第二部分是正则表达式

```php
[0-9]+
```

限定了 **一个或者多个的数字**。如果你访问非数字的 ID ，如 [localhost:3000/articles/string](http://localhost:3000/articles/string) 即会看到 404 页面。

再看下在 Handler 里面我们如何获取到这个参数：

```php
func articlesShowHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id := vars["id"]
    fmt.Fprint(w, "文章 ID："+id)
}
```

*Mux 提供的方法 `mux.Vars(r)` 会将 URL 路径参数解析为键值对应的 Map，使用以下方法即可读取：*

```php
vars["id"]
```

### 命名路由与链接生成

看下以下代码：

```php
router.HandleFunc("/", homeHandler).Methods("GET").Name("home")
router.HandleFunc("/articles/{id:[0-9]+}", articlesShowHandler).Methods("GET").Name("articles.show")
```

`Name()` 方法用来给路由命名，传参是路由的名称，接下来我们就可以靠这个名称来获取到 URI：

```php
homeURL, _ := router.Get("home").URL()
fmt.Println("homeURL: ", homeURL)
articleURL, _ := router.Get("articles.show").URL("id", "1")
fmt.Println("articleURL: ", articleURL)
```

## 依赖管理 Go Modules

Go Modules 是 Go 语言的代码依赖管理工具。类似于 PHP 中的 Composer、Node.js 中的 npm 。

Go Modules 由官方维护。自 Go 版本 1.14 开始，官方鼓励所有用户迁移到 Go Modules 以进行依赖项管理。

### Go 依赖管理工具大统一

Go 1.11 之前，最令人诟病的问题是其缺少一个现代化、统一的、官方推荐的依赖管理工具。虽说开源社区自发创建了许多依赖工具，其中优秀的如 dep、glide 等。

然而，他们都有同一个问题 —— 非官方推荐。开源社区出现无意义的分裂和消耗。

Go 1.11 推出的模块（Modules）无疑为 Go 语言开发者打开了一扇新的大门。

### 弃用 $GOPATH

Go Modules 出现的目的之一就是为了解决 GOPATH 的问题。

在 $GOPATH 时代，Go 源码必须放置于 `$GOPATH/src` 下，抛弃 $GOPATH 的好处，是你能在任意地方创建的 Go 项目。

另外，$GOPATH 有非常落后的依赖管理系统。因在执行 `go get` 时，无法传达任何版本信息。

在构建 Go 应用程序上，我们无法保证其它人与你所期望依赖的第三方库是相同的版本（相同的代码），也就是说无法保证所有人的依赖版本都一致。

### Go Modules 日常使用

#### 1. 初始化

新项目，我们可以使用 `go mod init` 初始化生成 `go.mod` 文件，这个我们在之前章节已做了，无需再次执行：

```php
$ go mod init
```

#### 2. Go Proxy

因国内访问外网受限，一般我们都会配合 Go Proxy 使用，以防止使用 `go get` 获取源码包时花费时间过长或无法下载：

```php
$ go env -w  GOPROXY=https://goproxy.cn,direct
```

> **知识点：** 我们使用 `go env -w` 来修改 Go 相关的环境变量。

Go Proxy 设置完成后即可放心使用 `go get` 来下载依赖了，作为测试，我们下载 HttpRouter ：

```php
$ go get github.com/julienschmidt/httprouter
```

使用 Proxy 的情况下一般很快就能下载完成。

安装 package 的原则是先拉最新的 release tag，若无 tag 则拉最新的 commit。

#### 3. go.mod

每一次的 `go get` 都会同时修改 `go.mod` 和 `go.sum` 文件。

这两个文件是下载依赖包的主要依据。`go.mod` 类似于 PHP 中的 composer.json ，而 go.sum 则是 composer.lock。

打开查看 `go.mod` 的源码：

*go.mod*

```php
module goblog

go 1.19

require (
    github.com/gorilla/mux v1.8.0 // indirect
    github.com/julienschmidt/httprouter v1.3.0 // indirect
)
```

几个参数：

- module —— 我们的 goblog 在 Go Module 里也算是一个 Module ；
- go —— 指定了版本要求，最低 1.19
- require —— 是项目所需依赖

#### 4. go.sum

`go.sum` 文件保存着依赖包的版本和哈希值：

*go.sum*

```php
github.com/gorilla/mux v1.8.0 h1:i40aqfkR1h2SlN9hojwV5ZA91wcXFOvkdNIeFDP5koI=
github.com/gorilla/mux v1.8.0/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=
github.com/julienschmidt/httprouter v1.3.0 h1:U0609e9tgbseu3rBINet9P48AI/D3oJs4dN7jwJOQ1U=
github.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=
```

需要注意的是，`go.sum` 里不止会保存直接依赖包的哈希值，间接依赖包的哈希值也会被保存。

**什么是间接依赖包？**

间接依赖包就是依赖包的依赖，以及他们的依赖… 我们目前下载的两个包 `mux` 和 `httprouter`，没有间接依赖，接下来我们拉取知名的 gin 框架来试试：

```php
$ go get github.com/gin-gonic/gin
```

下载成功后打开 `go.sum` ，会发现里面的内容远远多于 `go.mod`。这是因为 gin 有很多依赖包，而这些依赖包也会有自己的依赖。

接下来我们仔细看下，每个模块路径有如下两种哈希：

```php
github.com/gorilla/mux v1.8.0 h1:i40aqfkR1h2SlN9hojwV5ZA91wcXFOvkdNIeFDP5koI=
github.com/gorilla/mux v1.8.0/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=
```

前者为 Go Modules 打包整个模块包文件 zip 后再进行 hash 值，而后者为针对 go.mod 的 hash 值。

由此可见，go.sum 是保证所下载源码 100% 正确的重要依据。如果有恶意用户，将某个 Git 项目的 tag 源码做了修改，这些哈希值将会不匹配并报错。

因为 go.sum 有 100% 保证 build 一致的作用，我们建议开发中将其**加入到代码版本控制器中**。这里面不止有安全的因素，当同事或者其他人 clone 你的代码，我们也希望代码可以保持一致。

#### 5. indirect

回到我们的 `go.mod` 中，可以看到 `require` 区块里有 `// indirect` 字样：

```php
.
.
.
require (
    github.com/gin-contrib/sse v0.1.0 // indirect
    github.com/gin-gonic/gin v1.8.1 // indirect
    github.com/go-playground/locales v0.14.0 // indirect
    github.com/go-playground/universal-translator v0.18.0 // indirect
    github.com/go-playground/validator/v10 v10.10.0 // indirect
    github.com/goccy/go-json v0.9.7 // indirect
    github.com/gorilla/mux v1.8.0 // indirect
    github.com/json-iterator/go v1.1.12 // indirect
    github.com/julienschmidt/httprouter v1.3.0 // indirect
    github.com/leodido/go-urn v1.2.1 // indirect
    github.com/mattn/go-isatty v0.0.14 // indirect
    github.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421 // indirect
    github.com/modern-go/reflect2 v1.0.2 // indirect
    github.com/pelletier/go-toml/v2 v2.0.1 // indirect
    github.com/ugorji/go/codec v1.2.7 // indirect
    golang.org/x/crypto v0.0.0-20210711020723-a769d52b0f97 // indirect
    golang.org/x/net v0.0.0-20210226172049-e18ecbb05110 // indirect
    golang.org/x/sys v0.0.0-20210806184541-e5e7981a1069 // indirect
    golang.org/x/text v0.3.6 // indirect
    google.golang.org/protobuf v1.28.0 // indirect
    gopkg.in/yaml.v2 v2.4.0 // indirect
)
```

此标志标明这个依赖包还未被使用，如果你在代码的某个地方 `import` 到的话，VSCode 的 Go 插件就会自动将这个标志去除。

#### 6. go mod tidy 命令

此命令做整理依赖使用，执行时会把未使用的 module 移除掉，我们试试：

```php
$ go mod tidy
```

再次查看 `go.mod` 和 `go.sum` 文件，会发现我们上面测试引入的两个包，包括一大堆的依赖，因未使用，皆被移除。

#### 7. 源码包的存放位置

默认源码包存放于 `$GOPATH/pkg/mod` 中，你可以打开看下。我的如下：

![依赖管理 Go Module](https://img.herrluk.icu/typoraPicture/2023-02-02-14:27:23-GBHUDT.png)

#### 8. 清空 Go Modules 缓存

使用以下命令可以清空本地下载的 Go Modules 缓存：

```php
$ go clean -modcache
```

#### 9. 下载依赖

默认情况下，当 `go run` 和 `go build` 命令执行时，Go 会基于 `go.mod` 文件自动拉取依赖。

Go Module 也提供了一个命令用以下载项目所需依赖：

```php
$ go mod download
```

#### 10. 所有 Go Modules 命令

以下是完整的命令列表，有些不常用的篇幅原因我们不做讲解：

| 命令            | 作用                             |
| --------------- | -------------------------------- |
| go mod init     | 生成 go.mod 文件                 |
| go mod download | 下载 go.mod 文件中指明的所有依赖 |
| go mod tidy     | 整理现有的依赖                   |
| go mod graph    | 查看现有的依赖结构               |
| go mod edit     | 编辑 go.mod 文件                 |
| go mod vendor   | 导出项目所有的依赖到 vendor 目录 |
| go mod verify   | 校验一个模块是否被篡改过         |
| go mod why      | 查看为什么需要依赖某模块         |

### 11. 相关环境变量

#### 1). GO111MODULE

此变量为 Go modules 的开关，此值有以下几个可能：

- auto：项目包含了 go.mod 文件的话启用 Go modules，目前在 Go1.11 至 Go1.15 中仍然是默认值。
- on：启用 Go modules，推荐设置，将会是未来版本中的默认值。
- off：禁用 Go modules，不推荐设置。

因是在 Go1.11 版本添加，故命名为 GO111MODULE。

未来 GO111MODULE 会先调整为默认值为 on（曾经在 Go1.13 想改为 on，并且已经合并了 PR，但最后因为种种原因改回了 auto），然后再把 GO111MODULE 这个变量去掉，目前猜测会在 Go 2。太早去掉 GO111MODULE 的支持，会存在兼容性问题。

#### 2). GOPROXY

此变量用于设置 Go 模块代理（Go module proxy），其作用是拉取源码时能够脱离传统的 VCS 方式，直接通过镜像站点来快速拉取。

镜像的好处多多，一个是防止某个版本的代码被有意或无意删除。第二是能将源码压为 zip 包，方便传输。最重要的 —— 可以做镜像加速站点，这在例如国内这种不稳定的网络环境下尤为重要。

GOPROXY 的默认值是：

```php
https://proxy.golang.org,direct
```

然而 `proxy.golang.org` 在国内是无法访问的，所以我们使用 Go modules 时，需设置国内的 Go 模块代理：

```php
$ go env -w GOPROXY=https://goproxy.cn,direct
```

> **信息：** goproxy.cn 是一个由 CDN 提供商七牛云支持的非营利性项目。七牛云也是中国最早在生产环境中使用 Go 的公司之一，项目介绍请见：[github.com/goproxy/goproxy.cn/blob...](https://github.com/goproxy/goproxy.cn/blob/master/README.zh-CN.md) 。

GOPROXY 的值是一个以英文逗号 `,` 分割的 Go 模块代理列表，可设置多个模块代理。将其设置为 `off` ，将会禁止 Go 在后续操作中使用任何 Go 模块代理。

**direct 标志**

`direct` 标志意味着从源地址抓取（比如 GitHub 等）。

如我们设置 GOPROXY 的值为：

```php
https://goproxy.cn,direct
```

则告诉 `go get` 在获取源码包时先尝试 `https://goproxy.cn`，如果遇到 404 等错误时，再尝试从源地址抓取。

#### 3). GOSUMDB

此值是 Go Checksum Database 的缩写，用于在拉取模块版本时（无论是从源站拉取还是通过 Go Module Proxy 拉取）保证拉取到的模块代码包未经过篡改，若发现不一致将会立即中止。

GOSUMDB 的默认值为：

```php
sum.golang.org
```

在国内同样无法访问，所幸 GOSUMDB 可以被 Go Module Proxy 代理。我们所设置的模块代理 `goproxy.cn` 支持代理 `sum.golang.org`。

另外，此变量还可设置为 `off`，会禁止 Go 在后续操作中校验模块哈希。

#### 4). GONOPROXY/GONOSUMDB/GOPRIVATE

这三个环境变量都是用在依赖了私有模块，这些模块 GOPROXY 和 GOSUMDB 都无法读取。

- GONOPROXY —— 设置不走 Go Proxy 的 URL 规则；
- GONOSUMDB —— 设置不检查哈希的 URL 规则；
- GOPRIVATE —— 设置私有模块的 URL 规则，会同时设置以上两个变量。

因为 GOPRIVATE 会同时设定以上两个，所以一般私有仓库使用 GOPRIVATE 即可。

以上三个值，都可使用逗号分隔来设置多个选项。例如：

```php
$ go env -w GOPRIVATE="git.example.com,github.com/name/project"
```

设置后当 `go get` 时，前缀为 `git.example.com` 和 `github.com/name/project` 的模块都会被认为是私有模块。

我们也可以利用通配符，例如：

```php
$ go env -w GOPRIVATE="*.example.com"
```

这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，需要注意的是不包括 example.com 本身。

### 小结

以上我们学习了 Go Modules 的规则，规则较多信息量比较大，如果你记不住，没关系。这里你只需过一遍，混个脸熟，后面遇到问题可以来这里查阅即可。

### 版本控制

如果你跟着上面的内容进行操作，此时你无需做什么。如果 `git status` 发现有修改的内容，这些内容都是我们测试的，无需提交到版本控制器中，可以使用以下方法进行放弃：

```php
$ git checkout .
```

此命令检出版本库最新的代码，并放弃本地修改。



## 使用中间件

### 说明

本节我们来讨论现代 Web 开发常见的解决方案：中间件。

### 中间件

目前为止，我们的代码中有一段重复性很高的代码：

```php
w.Header().Set("Content-Type", "text/html; charset=utf-8")
```

这是设置内容类型的标头，以便浏览器能正常解析页面。

基本上我们每一个页面都会用到这段代码。后面会有静态内容，像图片、CSS 和 JS 文件，`Content-Type` 有不一致的，到时候我们再行处理，目前我们先默认所有页面都需要。

***一般像这种要统一对响应做处理的，我们可以使用中间件来做。***

### 使用中间件

main.go

```php
package main

import (
    "fmt"
    "net/http"

    "github.com/gorilla/mux"
)

func homeHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "<h1>Hello, 欢迎来到 goblog！</h1>")
}

func aboutHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "此博客是用以记录编程笔记，如您有反馈或建议，请联系 "+
        "<a href=\"mailto:summer@example.com\">summer@example.com</a>")
}

func notFoundHandler(w http.ResponseWriter, r *http.Request) {

    w.WriteHeader(http.StatusNotFound)
    fmt.Fprint(w, "<h1>请求页面未找到 :(</h1><p>如有疑惑，请联系我们。</p>")
}

func articlesShowHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id := vars["id"]
    fmt.Fprint(w, "文章 ID："+id)
}

func articlesIndexHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "访问文章列表")
}

func articlesStoreHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "创建新的文章")
}

func forceHTMLMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 1. 设置标头
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        // 2. 继续处理请求
        next.ServeHTTP(w, r)
    })
}

func main() {
    router := mux.NewRouter()

    router.HandleFunc("/", homeHandler).Methods("GET").Name("home")
    router.HandleFunc("/about", aboutHandler).Methods("GET").Name("about")

    router.HandleFunc("/articles/{id:[0-9]+}", articlesShowHandler).Methods("GET").Name("articles.show")
    router.HandleFunc("/articles", articlesIndexHandler).Methods("GET").Name("articles.index")
    router.HandleFunc("/articles", articlesStoreHandler).Methods("POST").Name("articles.store")

    // 自定义 404 页面
    router.NotFoundHandler = http.HandlerFunc(notFoundHandler)

    // 中间件：强制内容类型为 HTML
    router.Use(forceHTMLMiddleware)

    // 通过命名路由获取 URL 示例
    homeURL, _ := router.Get("home").URL()
    fmt.Println("homeURL: ", homeURL)
    articleURL, _ := router.Get("articles.show").URL("id", "1")
    fmt.Println("articleURL: ", articleURL)

    http.ListenAndServe(":3000", router)
}
```

可以看到我们新增了 `forceHTMLMiddleware` 中间件方法：

```php
func forceHTMLMiddleware(h http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 1. 设置标头
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        // 2. 继续处理请求
        h.ServeHTTP(w, r)
    })
}
```

然后使用 Gorilla Mux 的 `mux.Use()` 方法来加载中间件：

```php
router.Use(forceHTMLMiddleware)
```

### 测试一下

浏览器打开 [localhost:3000/about](http://localhost:3000/about) ，或者其他存在的页面，查看标头：

![使用中间件](http://pictureload-1300403731.cos.ap-shanghai.myqcloud.com/typoraPicture/xuYo536Yqw.png)

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "使用中间件"
```

## URL中的斜杆

本小节我们将解决程序里 URL 的斜杆问题。

访问以下两个链接：

- [localhost:3000/about](http://localhost:3000/about)
- [localhost:3000/about/](http://localhost:3000/about/)

可以看到有 `/` 的链接会报 404 错误：

![URI 中的斜杆](https://img.herrluk.icu/typoraPicture/Cium0RNMHU.png)

就如：

- [learnku.com/go](http://learnku.com/go)
- [learnku.com/go/](http://learnku.com/go/)

我们希望 URL 后面是否加斜杆的情况下，皆使用同一个返回结果。

### StrictSlash

对于这个问题 Gorilla Mux 提供了一个 `StrictSlash(value bool)` 函数，我们先来试试：

在 `main` 函数中，请将以下这一行：

```php
router := mux.NewRouter()
```

修改为：

```php
router := mux.NewRouter().StrictSlash(true)
```

浏览器再次访问 [localhost:3000/about/](http://localhost:3000/about/) ：

![URI 中的斜杆](https://img.herrluk.icu/typoraPicture/2023-02-02-14:50:04-1jjd50.png)

可以看到 URL 被校正了，跳转速度太快，我们再次试试看。

我们打开 Chrome 的控制台，查看请求，注意把 `Disable cache` 打钩：

![URI 中的斜杆](https://img.herrluk.icu/typoraPicture/2023-02-02-14:50:04-H7DAQx.png)

可以看到当请求 `about/` 时产生了两个请求，第一个是 301 跳转，第二个是跳转到的 `about` 去掉斜杆的链接。

浏览器在处理 301 请求时，会缓存起来。后续的 `about/` 浏览器都会自动去请求 `about` 链接，也就是说两次请求只会在第一次的时候发生。

这个解决方案看起来不错，然而有一个严重的问题 —— 当请求方式为 POST 的时候，遇到服务端的 `301` 跳转，将会变成 GET 方式。很明显，这并非所愿，我们需要一个更好的方案。

### 兼容 POST 请求

我们需要在 URL 进入 Gorilla Mux 路由解析之前，就将后面的 `/` 去掉。

首先还原我们上面的修改：

```php
$ git checkout .
```

像这种针对所有请求的操作，你第一时间想到的可能是用中间件处理，然而因为执行顺序的问题，Gorilla Mux 会先匹配路由，再执行中间件，故使用中间件永远会返回 404.

**解决方法很简单，那就是写一个函数把 Gorilla Mux 包起来，在这个函数中我们先对进来的请求做处理，然后再传给 Gorilla Mux 去解析。**



接下来新增 `removeTrailingSlash()` 函数并调用：

*main.go*

```php
.
.
.
func removeTrailingSlash(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 1. 除首页以外，移除所有请求路径后面的斜杆
        if r.URL.Path != "/" {
            r.URL.Path = strings.TrimSuffix(r.URL.Path, "/")
        }

        // 2. 将请求传递下去
        next.ServeHTTP(w, r)
    })
}

func main() {
    .
    .
    .

    http.ListenAndServe(":3000",  removeTrailingSlash(router))
}
```

我们使用 strings 包提供的 `TrimSuffix(s, suffix string) string` 函数来移除 `/` 后缀，如果不带斜杆后缀的话，`r.URL.Path` 将会被原封不动地返回。

> **
> 知识点：** Go 标准库中的 strings 包提供了用于操作字符串，比如分割、合并、去除、替换等等常用的方法。

修改保持后，再次访问 [localhost:3000/about/](http://localhost:3000/about/) ：

![URI 中的斜杆](https://img.herrluk.icu/typoraPicture/2023-02-02-14:51:57-chEdkU.png)

问题解决。

偶然间，我们又发现了另一个问题，访问主页 [localhost:3000/](http://localhost:3000/) 会出现错误：

![URI 中的斜杆](https://img.herrluk.icu/typoraPicture/2023-02-02-14:51:57-IQKbTQ.png)

那是因为我们的 `removeTrailingSlash` 中这一段：

```php
r.URL.Path = strings.TrimSuffix(r.URL.Path, "/")
```

会将我们的首页 URL `/` 给去除了，解决方法是把 `/` 路径排除在外：

*main.go*

```php
func removeTrailingSlash(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 1. 除首页以外，移除所有请求路径后面的斜杆
        if r.URL.Path != "/" {
            r.URL.Path = strings.TrimSuffix(r.URL.Path, "/")
        }

        // 2. 将请求传递下去
        next.ServeHTTP(w, r)
    })
}
```

保存修改后，再次访问 [localhost:3000/](http://localhost:3000/) ，可见正常的结果：

![URI 中的斜杆](https://img.herrluk.icu/typoraPicture/2023-02-02-14:51:57-xvOqkR.png)

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "移除 URL 路径中的斜杠"
```

本文章首发在 [LearnKu.com](https://learnku.com/) 网站上。

[ 上一篇](https://learnku.com/courses/go-basic/1.19/using-middleware/13373)[下一篇 ](https://learnku.com/courses/go-basic/1.19/summary-and-task/13375)

[ 纠错改进](https://learnku.com/courses/articles/13374/patches/create)

 贡献者：1

# 5.表单提交

## 创建博文

### 说明

本节开始，我们将开发创建博客相关的功能。

### 新增路由

*main.go*

```php
func articlesCreateHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "创建博文表单")
}

func main() {
    .
    .
    .

    router.HandleFunc("/articles/create", articlesCreateHandler).Methods("GET").Name("articles.create")

    // 自定义 404 页面
    router.NotFoundHandler = http.HandlerFunc(notFoundHandler)

    // 中间件：强制内容类型为 HTML
    router.Use(forceHTMLMiddleware)

    http.ListenAndServe(":3000", removeTrailingSlash(router))
}
```

以上代码注意：

1. 我们新增了 `/articles/create` 路由和 `articlesCreateHandler` 请求处理器；
2. 移除了 `router.Use(forceHTMLMiddleware)` 后面的测试路由命名相关的代码。

打开浏览器 [localhost:3000/articles/create](http://localhost:3000/articles/create) ，可见：

![创建博文](http://img.herrluk.icu/typoraPicture/4jVD73lmZO-20221115190222424.png)

### 构建表单

接下来我们构建表单，修改 `articlesCreateHandler` 函数的代码如下：

```php
func articlesCreateHandler(w http.ResponseWriter, r *http.Request) {
    html := `
<!DOCTYPE html>
<html lang="en">
<head>
    <title>创建文章 —— 我的技术博客</title>
</head>
<body>
    <form action="%s" method="post">
        <p><input type="text" name="title"></p>
        <p><textarea name="body" cols="30" rows="10"></textarea></p>
        <p><button type="submit">提交</button></p>
    </form>
</body>
</html>
`
    storeURL, _ := router.Get("articles.store").URL()
    fmt.Fprintf(w, html, storeURL)
}
```

**代码分析：**

我们使用上标符号 `` ` 来书写 HTML 代码，一般多行字符串可以使用这种方式。

```php
storeURL, _ := router.Get("articles.store").URL()
```

使用路由名称传参给 `router.Get()` 方法来获取创建博文的链接，使用命名路由的好处是为 URL 修改提供了灵活性。

保存文件后发现命令行里我们的自动重载程序 `air` 报错了，VSCode 里鼠标放上去，也可以看到提示信息：

![创建博文](http://img.herrluk.icu/typoraPicture/yTHuXOUXyR.png)

> undefined: router

`router` 变量未定义。

这里有个 Go 语言变量作用域的问题，`main()` 函数中定义的 `router := mux.NewRouter()` 无法在函数 `articlesCreateHandler()` 中使用，因为 `router` 是函数级别的变量，Go 语言中函数间的变量是不可见的。我们可以使用包级别的变量来解决此问题，只需要将 `router` 变量初始代码移出 `main()` 方法，置于文件顶部：



*main.go*

```php
package main

import (
    "fmt"
    "net/http"
    "strings"

    "github.com/gorilla/mux"
)

router := mux.NewRouter()

.
.
.
```

保存文件会提示一下错误：

![创建博文](http://img.herrluk.icu/typoraPicture/GjRjw834zg.png)

```php
syntax error: non-declaration statement outside function body

# 翻译
语法错误：函数外无法使用变量赋值语句
```

原因是包级别的变量声明时不能使用 `:=` 语法，修改为带关键词 `var` 的变量声明即可：

*main.go*

```php
package main

import (
    "fmt"
    "net/http"
    "strings"

    "github.com/gorilla/mux"
)

var router = mux.NewRouter()

.
.
.
```

保存后将编译成功，浏览器访问 [localhost:3000/articles/create](http://localhost:3000/articles/create) ，可见：

![创建博文](http://img.herrluk.icu/typoraPicture/JBH5wcZL5k.png)

浏览器上右键，查看源码：

![创建博文](http://img.herrluk.icu/typoraPicture/ryCU1qfaO3.png)

可以看到命名路由为我们生成的链接。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "新建博文表单"
```

## 读取表单数据

### 说明

上一节我们完成了表单的构建，这一节来处理表单提交过来的数据。

### 接收数据

在 `main()` 函数里有这一行是设置保存表单数据的路由：

```php
router.HandleFunc("/articles", articlesStoreHandler).Methods("POST").Name("articles.store")
```

指定到了 `articlesStoreHandler()` 函数中，接下来我们修改此函数，将用户提交的数据打印出来：

*main.go*

```php
.
.
.
func articlesStoreHandler(w http.ResponseWriter, r *http.Request) {

    err := r.ParseForm()
    if err != nil {
        // 解析错误，这里应该有错误处理
        fmt.Fprint(w,  "请提供正确的数据！")
        return
    }

    title := r.PostForm.Get("title")

    fmt.Fprintf(w, "POST PostForm: %v <br>", r.PostForm)
    fmt.Fprintf(w, "POST Form: %v <br>", r.Form)
    fmt.Fprintf(w, "title 的值为: %v", title)
}

.
.
.
```

**代码解析：**

`r.ParseForm()` 由 http 包提供，从请求中解析请求参数，必须是执行完这段代码，后面 `r.PostForm` 和 `r.Form` 才能读取到数据，否则为空数组。

关于错误处理，一般常见的简写是：

```php
    if err := r.ParseForm(); err != nil {
        // 解析错误，这里应该有错误处理
        fmt.Fprint(w,  "请提供正确的数据！")
        return
    }
```

修改完成后，打开 [localhost:3000/articles/create](http://localhost:3000/articles/create) ，在标题和内容里随便填入点信息：

![表单验证](http://img.herrluk.icu/typoraPicture/zFx9LpYrX2.png)

点击提交可见：

![表单验证](http://img.herrluk.icu/typoraPicture/QmgRL409m5.png)

打印出来的数据可见 `r.PostForm` 和 `r.Form` 的数据是一样的。

- Form：存储了 post、put 和 get 参数，在使用之前需要调用 ParseForm 方法。
- PostForm：存储了 post、put 参数，在使用之前需要调用 ParseForm 方法。

我们修改代码来验证两者区别：

*main.go*

```php
.
.
.
func articlesCreateHandler(w http.ResponseWriter, r *http.Request) {
    html := `
<!DOCTYPE html>
<html lang="en">
<head>
    <title>创建文章 —— 我的技术博客</title>
</head>
<body>
    <form action="%s?test=data" method="post">
        <p><input type="text" name="title"></p>
        <p><textarea name="body" cols="30" rows="10"></textarea></p>
        <p><button type="submit">提交</button></p>
    </form>
</body>
</html>
`
    storeURL, _ := router.Get("articles.store").URL()
    fmt.Fprintf(w, html, storeURL)
}
.
.
.
```

注意修改的这一段，添加了 URL 参数：

```php
<form action="%s?test=data" method="post">
```

重新打开 [localhost:3000/articles/create](http://localhost:3000/articles/create) 并填写数据（注意如果你使用浏览器的回退功能的话，需要重新刷新页面），再次提交：

![表单验证](http://img.herrluk.icu/typoraPicture/gvOz7P6Wic.png)

可见 `r.Form` 比 `r.PostForm` 多了 URL 参数里的数据。

如不想获取所有的请求内容，而是逐个获取的话，这也是比较常见的操作，无需使用 `r.ParseForm()` 可直接使用 `r.FormValue()` 和 `r.PostFormValue()` 方法：

*main.go*

```php
.
.
.
func articlesStoreHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, "r.Form 中 title 的值为: %v <br>", r.FormValue("title"))
    fmt.Fprintf(w, "r.PostForm 中 title 的值为: %v <br>", r.PostFormValue("title"))
    fmt.Fprintf(w, "r.Form 中 test 的值为: %v <br>", r.FormValue("test"))
    fmt.Fprintf(w, "r.PostForm 中 test 的值为: %v <br>", r.PostFormValue("test"))
}
.
.
.
```

刷新页面并提交表单，打印出来的数据如下：

![表单验证](http://img.herrluk.icu/typoraPicture/oAYJ53TIR6.png)

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "读取请求数据"
```

## 表单验证

### 说明

现在我们学会了如何获取数据，接下来需要对表单数据进行验证。

验证规则如下：

- 标题不能为空，且要大于两个字符，且小于 40 个字符
- 内容不能为空，且要大于 10 个字符

### 表单验证

接下来修改 `articlesStoreHandler()` 方法，先对数据进行验证：

*main.go*

```php
.
.
.
func articlesStoreHandler(w http.ResponseWriter, r *http.Request) {

    title := r.PostFormValue("title")
    body := r.PostFormValue("body")

    errors := make(map[string]string)

    // 验证标题
    if title == "" {
        errors["title"] = "标题不能为空"
    } else if len(title) < 3 || len(title) > 40 {
        errors["title"] = "标题长度需介于 3-40"
    }

    // 验证内容
    if body == "" {
        errors["body"] = "内容不能为空"
    } else if len(body) < 10 {
        errors["body"] = "内容长度需大于或等于 10 个字节"
    }

    // 检查是否有错误
    if len(errors) == 0 {
        fmt.Fprint(w, "验证通过!<br>")
        fmt.Fprintf(w, "title 的值为: %v <br>", title)
        fmt.Fprintf(w, "title 的长度为: %v <br>", len(title))
        fmt.Fprintf(w, "body 的值为: %v <br>", body)
        fmt.Fprintf(w, "body 的长度为: %v <br>", len(body))
    } else {
        fmt.Fprintf(w, "有错误发生，errors 的值为: %v <br>", errors)
    }
}
.
.
.
```

测试一下，打开 [localhost:3000/articles/create](http://localhost:3000/articles/create) ，填入很少的内容：

![表单验证](https://img.herrluk.icu/typoraPicture/2023-02-03-16:38:39-eEHuYa.png)

提交以后，发现显示的是 `验证通过!` ：

![表单验证](https://img.herrluk.icu/typoraPicture/2023-02-03-16:38:39-ouxpxd.png)

且命名是两个中文汉字，使用 `len()` 函数计数却为 6 个。

Go 语言的内建函数 len ()，可以用来获取切片、字符串、通道（channel）等的长度。

这里的差异是由于 Go 语言的字符串都以 UTF-8 格式保存，每个中文占用 3 个字节，因此使用 len () 获得两个中文文字对应的 6 个字节。

如果希望按习惯上的字符个数来计算，就需要使用 Go 语言中 utf8 包提供的 RuneCountInString () 函数来计数。重新修改代码：

*main.go*

```php
.
.
.
func articlesStoreHandler(w http.ResponseWriter, r *http.Request) {

    title := r.PostFormValue("title")
    body := r.PostFormValue("body")

    errors := make(map[string]string)

    // 验证标题
    if title == "" {
        errors["title"] = "标题不能为空"
    } else if utf8.RuneCountInString(title) < 3 || utf8.RuneCountInString(title) > 40 {
        errors["title"] = "标题长度需介于 3-40"
    }

    // 验证内容
    if body == "" {
        errors["body"] = "内容不能为空"
    } else if utf8.RuneCountInString(body) < 10 {
        errors["body"] = "内容长度需大于或等于 10 个字节"
    }

    // 检查是否有错误
    if len(errors) == 0 {
        fmt.Fprint(w, "验证通过!<br>")
        fmt.Fprintf(w, "title 的值为: %v <br>", title)
        fmt.Fprintf(w, "title 的长度为: %v <br>", utf8.RuneCountInString(title))
        fmt.Fprintf(w, "body 的值为: %v <br>", body)
        fmt.Fprintf(w, "body 的长度为: %v <br>", utf8.RuneCountInString(body))
    } else {
        fmt.Fprintf(w, "有错误发生，errors 的值为: %v <br>", errors)
    }
}
.
.
.
```

再次提交，即可看到正确的报错信息：

![表单验证](https://img.herrluk.icu/typoraPicture/2023-02-03-16:38:39-es14CO.png)

### 出错时提示

数据验证的逻辑是：

- 正确的时候存入数据库
- 错误时重新显示表单，并显示错误提示

接下来我们先来处理错误提示。

发生错误时，也就是 `errors` 的长度大于零时，我们会把 `errors` 传参到 HTML 中进行渲染。Go 标准库的 `html/template`，就是专门为这种场景所设计的。

*main.go*

```php
.
.
.
// ArticlesFormData 创建博文表单数据
type ArticlesFormData struct {
    Title, Body string
    URL         *url.URL
    Errors      map[string]string
}

func articlesStoreHandler(w http.ResponseWriter, r *http.Request) {
    .
    .
    .

    // 检查是否有错误
    if len(errors) == 0 {
        .
        .
        .
    } else {

        html := `
<!DOCTYPE html>
<html lang="en">
<head>
    <title>创建文章 —— 我的技术博客</title>
    <style type="text/css">.error {color: red;}</style>
</head>
<body>
    <form action="{{ .URL }}" method="post">
        <p><input type="text" name="title" value="{{ .Title }}"></p>
        {{ with .Errors.title }}
        <p class="error">{{ . }}</p>
        {{ end }}
        <p><textarea name="body" cols="30" rows="10">{{ .Body }}</textarea></p>
        {{ with .Errors.body }}
        <p class="error">{{ . }}</p>
        {{ end }}
        <p><button type="submit">提交</button></p>
    </form>
</body>
</html>
`
        storeURL, _ := router.Get("articles.store").URL()

        data := ArticlesFormData{
            Title:  title,
            Body:   body,
            URL:    storeURL,
            Errors: errors,
        }
        tmpl, err := template.New("create-form").Parse(html)
        if err != nil {
            panic(err)
        }

        err = tmpl.Execute(w, data)
        if err != nil {
            panic(err)
        }
    }
}
.
.
.
```

**代码分析：**

首先我们定义一个 `ArticlesFormData` struct，用以给模板文件传输变量时使用。

接下来是构建 ArticlesFormData 里的数据，`storeURL` 是通过路由参数生成的 URL 路径。

```php
tmpl, err := template.New("create-form").Parse(html)
```

这是 `template.New()` 包的初始化。`html` 变量里是包含模板语法的内容，模板语法以双层大括号 `{{` 包起来，关于模板的使用以及更多的语法，我们下节再探讨。

此时再次刷新浏览器，即可看到我们的错误提示被成功渲染：

![表单验证](https://img.herrluk.icu/typoraPicture/2023-02-03-16:38:39-Ngj9q4.png)

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "表单验证"
```

## 模板文件

### 说明

上一节我们使用 Go 的 template 标准库来构建表单。

本节我们一起重构 `articlesCreateHandler()` 和 `articlesStoreHandler()` 函数，为了遵循最佳实践，使其更方便维护，将 HTML 抽离并放置于独立的模板文件中。同时两个函数也会共用一个模板文件。

### 模板文件

我们先来让 `articlesStoreHandler()` 使用模板文件：

*main.go*

```php
.
.
.
func articlesStoreHandler(w http.ResponseWriter, r *http.Request) {
    .
    .
    .

    // 检查是否有错误
    if len(errors) == 0 {
        .
        .
        .
    } else {

        storeURL, _ := router.Get("articles.store").URL()

        data := ArticlesFormData{
            Title:  title,
            Body:   body,
            URL:    storeURL,
            Errors: errors,
        }
        tmpl, err := template.ParseFiles("resources/views/articles/create.gohtml")
        if err != nil {
            panic(err)
        }

        err = tmpl.Execute(w, data)
        if err != nil {
            panic(err)
        }
    }
}
.
.
.
```

以上的修改：1. 删了 html 变量， 2. 使用以下这段代码加载模板文件，其他代码保持不变：

```php
tmpl, err := template.ParseFiles("resources/views/articles/create.gohtml")
```

关于模板后缀名 `.gohtml` ，可以使用任意后缀名，这不会影响代码的运行。常见的 Go 模板后缀名有 `.tmpl`、`.tpl`、 `.gohtml` 等。

Go 官方 [开源的 Blog 代码](https://github.com/golang/blog/tree/master/template) 中，使用的是 `.tmpl`，然而在 LearnKu 的 Go 论坛里，我们推荐使用 `.gohtml`。原因是避免与其他语言的模板后缀产生不必要的冲突。PHP 或其他语言可能会使用相同后缀，且你都是使用 VSCode 来作为编辑器，那么 VSCode 将无法准确地提供代码高亮。

接下来创建模板文件：

*resources/views/articles/create.gohtml*

```php
<!DOCTYPE html>
<html lang="en">
<head>
    <title>创建文章 —— 我的技术博客</title>
    <style type="text/css">.error {color: red;}</style>
</head>
<body>
    <form action="{{ .URL }}" method="post">
        <p><input type="text" name="title" value="{{ .Title }}"></p>
        {{ with .Errors.title }}
        <p class="error">{{ . }}</p>
        {{ end }}
        <p><textarea name="body" cols="30" rows="10">{{ .Body }}</textarea></p>
        {{ with .Errors.body }}
        <p class="error">{{ . }}</p>
        {{ end }}
        <p><button type="submit">提交</button></p>
    </form>
</body>
</html>
```

浏览器打开 [localhost:3000/articles/create](http://localhost:3000/articles/create) ，填入内容：

![使用模板](https://img.herrluk.icu/typoraPicture/2023-02-03-16:57:48-IwRO4q.png)

点击提交：

![使用模板](https://img.herrluk.icu/typoraPicture/2023-02-03-16:57:48-JtPL98.png)

修改成功。

### 统一模板

接下来修改 `/articles/create` 的代码来加载同一个模板：

*main.go*

```php
func articlesCreateHandler(w http.ResponseWriter, r *http.Request) {

    storeURL, _ := router.Get("articles.store").URL()
    data := ArticlesFormData{
        Title:  "",
        Body:   "",
        URL:    storeURL,
        Errors: nil,
    }
    tmpl, err := template.ParseFiles("resources/views/articles/create.gohtml")
    if err != nil {
        panic(err)
    }

    err = tmpl.Execute(w, data)
    if err != nil {
        panic(err)
    }
}
```

这里我们使用与 articlesStoreHandler 类似的代码，需要特别注意的是 `panic()` 函数的使用。

> **知识点：** 在 Go 中，一般 err 处理方式可以是给用户提示或记录到错误日志里，这种很多时候为 **业务逻辑错误**。当有重大错误，或者**系统错误时**，例如无法加载模板文件，就使用 `panic()` 。应用里需要有一套合理的错误机制，后面的开发中我们会详细讲解到。

访问 [localhost:3000/articles/create](http://localhost:3000/articles/create) ，可以见成功渲染：

![使用模板](https://img.herrluk.icu/typoraPicture/2023-02-03-16:57:48-5mqOKO.png)

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "使用模板文件"
```



## 模板语法

### 模板语法

双层大括号 `{{ }}` 是默认的模板界定符。用于在 HTML 模板文件中界定模板语法。

模板语法都包含在 `{{`和`}}` 中间。

先来看目前我们模板文件里的内容：

*resources/views/articles/create.gohtml*

```php
<!DOCTYPE html>
<html lang="en">
<head>
    <title>创建文章 —— 我的技术博客</title>
    <style type="text/css">.error {color: red;}</style>
</head>
<body>
    <form action="{{ .URL }}" method="post">
        <p><input type="text" name="title" value="{{ .Title }}"></p>
        {{ with .Errors.title }}
        <p class="error">{{ . }}</p>
        {{ end }}
        <p><textarea name="body" cols="30" rows="10">{{ .Body }}</textarea></p>
        {{ with .Errors.body }}
        <p class="error">{{ . }}</p>
        {{ end }}
        <p><button type="submit">提交</button></p>
    </form>
</body>
</html>
```

#### {{.}} 语句

第一个语法是：

```php
<form action="{{ .URL }}" method="post">
```

`{{ . }}` 中的点表示当前对象。当我们传入一个结构体对象时，我们可以使用 `.` 来访问结构体的对应字段。同理，当我们传入的变量是 `map` 时，也可以在模板文件中通过 `.` 根据 key 来取值。

接下来再来看：

```php
{{ with .Errors.title }}
<p class="error">{{ . }}</p>
{{ end }}
```

#### **with** 关键字

语法如下：

> {{ with pipeline }} T1 {{ end }}
> 如果 pipeline 为空则不产生输出，否则将 `.` 设为 pipeline 的值并执行 T1。不修改外面的 `.` 。

> {{ with pipeline }} T1 {{ else }} T0 {{ end }}
> 如果 pipeline 为空则不改变 `.` 并执行 T0，否则 `.` 设为 pipeline 的值并执行 T1。

**with** 区块外，`{{ . }}` 代表传入模板的数据，而在 **with** 区块内，则代表 pipline 里的数据。

如 `{{ with .Errors.title }}` 这个区块内，`{{ . }}` 代表 `.Errors.title`。

#### pipeline

`pipeline` 是指产生数据的操作。比如 `{{ . }}`、`{{ .Name }}` 等。Go 的模板语法支持使用管道符号 `|` 连接多个命令，用法和 Unix 下的管道类似 —— `|` 前面的命令会将运算结果 (或返回值) 传递给后一个命令的最后一个位置。

> **注意：** 并不是只有使用了 `|` 才是 pipeline。Go 的模板中，`pipeline` 的概念是传递数据，只要能产生数据的，都是 `pipeline`。

### 其他模板语法

目前为止我们只接触简单的几种语法，接下来将大致讲解下其他常见的语法。

这些语法在后面的课程中会接触到，这里先混个脸熟即可。

#### 注释

注释，执行时会忽略。可以多行。注释不能嵌套，且须紧贴分界符。

```php
{{/* 这是一个注释 */}}
```

#### 变量

我们还可以在模板中声明变量，用来保存传入模板的数据或其他语句生成的结果。具体语法如下：

```php
$variable := {{ . }}
```

其中 `$variable` 是变量的名字，在后续的代码中就可以使用该变量了。

#### 移除空格

有时会不可避免的引入空格或者换行符，导致模板最终渲染结果不符预期。这种情况可以使用 `{{-` 语法去除模板内容左侧的所有空白符号， 使用 `-}}` 去除模板内容右侧的所有空白符号。

例如：

```php
{{- .Name -}}
```

**注意：** `-` 要紧挨 `{{`和`}}`，同时与模板值之间需要使用空格分隔。

#### 条件判断

Go 模板语法的条件判断有以下几种:

```php
{{if pipeline}} T1 {{end}}

{{if pipeline}} T1 {{else}} T0 {{end}}

{{if pipeline}} T1 {{else if pipeline}} T0 {{end}}
```

#### range 遍历

`range` 关键字用以在模板里遍历数据，有以下两种写法，其中 `pipeline` 的值必须是数组、切片、字典或者通道。

语法如下：

> {{range pipeline}} T1 {{end}}
> 如果 pipeline 的值其长度为 0，不会有任何输出

> {{range pipeline}} T1 {{else}} T0 {{end}}
> 如果 pipeline 的值其长度为 0，则会执行 T0。

#### 修改默认的标识符

Go 标准库的模板引擎使用的花括号 `{{`和`}}` 作为标识，而许多前端框架（如 `Vue` 和 `AngularJS`）也使用 `{{`和`}}` 作为标识符，所以当我们同时使用 Go 语言模板引擎和以上前端框架时就会出现冲突，这个时候我们需要修改标识符，修改前端的或者修改 Go 语言的。这里演示如何修改 Go 语言模板引擎默认的标识符：

```php
template.New("test").Delims("{[", "]}").ParseFiles("filename.gohtml")
```

### 结语

除了以上提到的这些语法，比较高级，但不常用的还有：

- 预定义函数
- 比较函数
- 自定义函数
- 模板嵌套

这些概念比较抽象，脱离上下文记不牢，我们在使用时再行讲解。

### 代码版本

这一节我们没有修改代码。如你在学习以上内容时尝试着修改代码，请使用以下命令还原代码，为下一节做准备：

```php
$ git checkout .
```

# 6.操作数据库

## MySQL 驱动

### 说明

目前为止，我们能接收到用户提交过来的数据，且对这些数据做验证。也已经开发完成验证错误的逻辑。

从这一节开始，我们将来开发验证成功后的逻辑，做数据持久化，或简单来讲 —— 把数据存到数据库里。

### 操作 MySQL 数据库

我们将使用 MySQL 来做主要存储数据库。

使用 Go 操作 MySQL 等数据库，一般有两种方式：

- 一是利用 database/sql 接口，直接在代码里硬编码 sql 语句；
- 二是使用 ORM，具体一点是 GORM，以对象关系映射的方式在抽象地操作数据库。

我们会先使用第一种方式来实现，让大家熟悉下 database/sql 接口，这是基本功，需要先练习一下。

随着项目开发的深入，需要大量数据查询时，我们会统一重构为使用 ORM 的方式。

### MySQL 驱动

Go 官方提供了 `database/sql` 包来给用户进行和数据库打交道的工作，`database/sql` 库实际只提供了一套操作数据库的**接口和规范**，例如抽象好的 SQL 预处理（prepare），连接池管理，数据绑定，事务，错误处理等。官方并没有提供具体某种数据库驱动。

> **小提示：** 维护标准接口的好处是 —— 将数据库操作抽象出来，相当于同一份代码可用于多种数据库中，只需要换个驱动而已。比较常见的场景 —— 生产环境使用 MySQL / PostgreSQL 等专业数据库，测试时可使用速度更快的内存 SQLite 数据库。

操作具体的数据库，例如说 MySQL，还需要再引入对应的数据库驱动。官方提供了 [这个 Wiki 页面](http://github.com/golang/go/wiki/SQLDrivers) 用以罗列第三方数据库驱动，我们常用的数据库基本上都有完整的第三方实现。

本课程中，我们将选用 [github.com/go-sql-driver/mysql](http://github.com/go-sql-driver/mysql) 项目作为我们的数据库驱动。此驱动是 Go 语言中最知名的 MySQL 驱动，存在时间长，同类中 GitHub 点赞最多，项目维护也很活跃，是一个比较可靠的选择。

### 安装驱动

使用以下命令下载驱动：

```php
$ go get github.com/go-sql-driver/mysql
```

下载成功后，打开 go.mod 可以看到：

![MySQL 驱动](http://cdn.learnku.com/uploads/images/202111/01/1/cWwPz1eHvy.png!large)

多出来这一行：

```php
github.com/go-sql-driver/mysql v1.6.0 // indirect
```

因为现在代码中还未使用到，所以会有 `indirect` 这个标示。驱动开始使用时，此标示会消失（由 VSCode 插件自动管理）。

这就算下载完成，接下来是在项目中引用：

```php
package main

import (
    .
    .
    .

    _ "github.com/go-sql-driver/mysql"
)
.
.
.
```

注意导入 mysql 驱动时，在包路径前我们添加 `_`，这里使用了**匿名导入**的方式来加载驱动。

### 为什么需要匿名导入？

因为引入的是驱动，操作数据库时我们使用的是 sql 库里的方法，而不会具体使用到 `go-sql-driver/mysql` 包里的方法，当有未使用的包被引入时，Go 编译器会停止编译。为了让编译器能正常运行，需要使用 **匿名导入** 来加载。

当导入了一个数据库驱动后，此驱动会自行初始化（利用 `init()` 函数）并注册自己到 Golang 的 database/sql 上下文中，驱动里的 `init()` 代码如下：

*mysql/driver.go（ 详见 [go-sql-driver/mysql 源码](http://github.com/go-sql-driver/mysql/blob/master/driver.go#L83-L85) ）*

```php
func init() {
    sql.Register("mysql", &MySQLDriver{})
}
```

随后我们就可以通过 database/sql 包提供的方法来操作数据库了。

> **注意：** 细心的你可以注意到了，上面我们并未对 `database/sql` 进行导入。对于标准库的 import 我们让 VSCode 来管理，后面在代码中使用 `sql.DB` 并保存时，VSCode 会自动为我们 import `database/sql` 库。

> **知识点：** Go 语言中，为了使用导入的程序包，必须首先对其进行初始化。初始化始终在单个线程中执行，并且以程序包依赖关系的顺序执行。初始化每个包后，会优先自动执行 `init()` 函数，并且执行优先级高于主函数的执行优先级。—— 详见 [翻译：详解 Go 语言中的 init () 函数](http://learnku.com/go/t/47178)

### go mod tidy

此时我们再使用 tidy 命令：

```php
$ go mod tidy
```

打开 go.mod 文件可以看到 `// indirect` 标志会被去除。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "添加 MySQL 驱动"
```

## 连接数据库

### 说明

上节我们安装了 MySQL 驱动，接下来我们将尝试连接数据库。

### 建立数据库连接

首先删除这一行：

```php
_ "github.com/go-sql-driver/mysql"
```

修改代码：

*main.go*

```php
package main

import (
    "database/sql"
    "fmt"
    "log"
    "net/http"
    "net/url"
    "strings"
    "text/template"
    "time"
    "unicode/utf8"

    "github.com/go-sql-driver/mysql"
    "github.com/gorilla/mux"
)

var router = mux.NewRouter()
var db *sql.DB
.
.
.
func initDB() {

    var err error
    config := mysql.Config{
        User:                 "homestead",
        Passwd:               "secret",
        Addr:                 "127.0.0.1:3306",
        Net:                  "tcp",
        DBName:               "goblog",
        AllowNativePasswords: true,
    }

    // 准备数据库连接池
    db, err = sql.Open("mysql", config.FormatDSN())
    checkError(err)

    // 设置最大连接数
    db.SetMaxOpenConns(25)
    // 设置最大空闲连接数
    db.SetMaxIdleConns(25)
    // 设置每个链接的过期时间
    db.SetConnMaxLifetime(5 * time.Minute)

    // 尝试连接，失败会报错
    err = db.Ping()
    checkError(err)
}

func checkError(err error) {
    if err != nil {
        log.Fatal(err)
    }
}

func main() {
    initDB()

    .
    .
    .
}
```

### 代码概览

首先我们设置了变量：

```php
var db *sql.DB
```

变量范围是包层面的，主要是方便各个函数中访问。

`sql.DB` 结构体是 database/sql 包封装的一个数据库操作对象，包含了操作数据库的基本方法，通常情况下，我们把它理解为 **连接池对象**。

接下来在 main 函数中调用了 `initDB()` 函数，以对 `sql.DB` 进行初始化。此函数需在路由之前调用，将数据库连接准备就绪，以备后用。

### DSN 信息

接下来看下 `initDB()` 函数：

```php
// 设置数据库连接信息
config := mysql.Config{
    User:                 "homestead",
    Passwd:               "secret",
    Addr:                 "127.0.0.1:3306",
    Net:                  "tcp",
    DBName:               "goblog",
    AllowNativePasswords: true,
}

// 准备数据库连接池
db, err = sql.Open("mysql", config.FormatDSN())
checkError(err)
```

> **注意：** 请按你的实际情况修改以上的数据库连接信息。

为了方便阅读，我们利用 `mysql.Config` 来生成 DSN 信息。

#### **什么是 DSN 信息？**

`DSN` 全称为 `Data Source Name`，表示 **数据源信息**，用于定义如何连接数据库。不同数据库的 DSN 格式是不同的，这取决于数据库驱动的实现，下面是 `go-sql-driver/sql` 的 DSN 格式，如下所示：

`//[用户名[:密码]@][协议(数据库服务器地址)]]/数据库名称?参数列表`

```php
//[用户名[:密码]@][协议(数据库服务器地址)]]/数据库名称?参数列表
[username[:password]@][protocol[(address)]]/dbname[?param1=value1&...&paramN=valueN]
```

`FormatDSN()` 是 `mysql.Config` 提供的用来生成 DSN 信息的方法，我们可以尝试把其生成的信息打印出来：

```php
fmt.Println(config.FormatDSN())
```

会输出：

```php
homestead:secret@tcp(127.0.0.1:3306)/goblog?checkConnLiveness=false&maxAllowedPacket=0
```

### sql.DB 连接池

一般而言，我们使用 `sql.Open()` 函数便可初始化并返回一个 `*sql.DB` 结构体实例，使用 `sql.Open()` 函数只要传入驱动名称及对应的 DSN 便可，使用很简单，也很通用：

```php
//driverName  表示驱动名，如 mysql, dataSourceName 为上文介绍的 DSN
func Open(driverName, dataSourceName string) (*sql.DB, error)
```

当需要连接不同数据库时，只需修改驱动名与 DSN 即可。

需要特别注意的是，调用 `sql.Open()` 时，并未开始连接数据库，只是为连接数据库做好准备而已。所以一般我们都会跟着一个 `db.Ping()` 来检测连接状态。

你可以试着把 `initDB()` 里的这两行注释掉：

```php
err = db.Ping()
checkError(err)
```

目前来讲，我们还未创建 `goblog` 数据库，如果尝试建立数据库连接，应会发生错误，命令行会打印报错信息。然而注释掉以后运行程序，我们并未看到报错信息：

![数据入库](http://cdn.learnku.com/uploads/images/202009/18/1/DEYyevLv98.png!large)

去除以上两行的注释后再次运行，可见命令行里报未知数据库 `goblog` 的错误：

![数据入库](http://cdn.learnku.com/uploads/images/202009/18/1/JYb4PJufvY.png!large)

也就是说，当 `db.Ping()` 时再尝试建立连接。

### sql.DB 连接池的配置信息

接下来讲解下几个配置信息：

```php
// 设置最大连接数
db.SetMaxOpenConns(100)

// 设置最大空闲连接数
db.SetMaxIdleConns(25)

// 设置每个链接的过期时间
db.SetConnMaxLifetime(5 * time.Minute)
```

#### SetMaxOpenConns 最大连接数

设置连接池最大打开数据库连接数，<= 0 表示无限制，默认为 0。

**问：应该设置多大呢？**

[实验表明](http://learnku.com/go/t/49809)，在高并发的情况下，将值设为大于 10，可以获得比设置为 1 接近六倍的性能提升。而设置为 10 跟设置为 0（也就是无限制），在高并发的情况下，性能差距不明显。

**问：是否越大越好？**

需要考虑的是不要超出数据库系统设置的最大连接数。MySQL 数据库可使用以下命令来查询：

```php
show variables like 'max_connections';
```

MySQL 8 默认是 151：

![连接数据库](http://cdn.learnku.com/uploads/images/202009/19/1/wBbyqZuHmr.png!large)

设置时不应该超过这个值，否则会出现 MySQL 错误：

```php
MySQL: ERROR 1040: Too many connections
```

另外，还需要注意这个值是整个系统的，如有其他应用程序也在共享这个数据库，这个可以合理地控制小一点。

#### SetMaxIdleConns 空闲连接数

设置连接池最大空闲数据库连接数，<= 0 表示不设置空闲连接数，默认为 2。

[实验表明](http://learnku.com/go/t/49809)，在高并发的情况下，将值设为大于 0，可以获得比设置为 0 **超过 20 倍的性能提升**。

这是因为设置为 0 的情况下，每一个 SQL 连接执行任务以后就销毁掉了，执行新任务时又需要重新建立连接。很明显，重新建立连接是很消耗资源的一个动作。

设置空闲连接数，当有新任务进来时，直接使用这些随时待命的连接传输数据，以此达到节约资源，提高执行效率的目的。

**问：是不是数值越大越好？**

首先此值不能大于 `SetMaxOpenConns` 的值，大于的情况下 mysql 驱动会自动将其纠正。

其次需要考虑的是，长时间打开大量的数据库连接需要占用系统的内存和 CPU 资源。

还有一个情况是 MySQL 会有一个 `wait_timeout` 的设置，连接超过这个时间就会被自动关闭，默认情况下是 8 个小时。当 MySQL 关闭连接时，sql.DB 请求到的就是一个坏的连接，虽然 sql 包里已经做了处理，当请求到坏连接时会自动重连。但是在这种情况下，单次请求相当于建立了两次连接，消耗比设置为 0 还大，得不偿失。

所以回答上面的问题，不是越大越好，应根据实际情况选择合理的值。

#### SetConnMaxLifetime 过期时间

设置连接池里每一个连接的过期时间，过期会自动关闭。理论上来讲，在并发的情况下，此值越小，连接就会越快被关闭，也意味着更多的连接会被创建。

设置的值不应该超过 MySQL 的 `wait_timeout` 设置项（默认情况下是 8 个小时）。

此值也不宜设置过短，关闭和创建都是极耗系统资源的操作。

设置此值时，需要特别注意 SetMaxIdleConns 空闲连接数的设置。假如设置了 100 个空闲连接，过期时间设置了 1 分钟，在没有任何应用的 SQL 操作情况下，数据库连接每 1.6 秒就销毁和新建一遍。

这里的推荐，比较保守的做法是设置五分钟：

```php
db.SetConnMaxLifetime(5 * time.Minute)
```

SetConnMaxLifetime 要求传参的是一个 `time.Duration` 对象，所以这里使用了 `time.Minute`，这也是我们初次使用标准库里的关于处理时间的包 —— time 。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "连接数据库"
```

## 数据库表结构

### 说明

上一节我们已经已经建立好数据库连接，接下来将创建数据库与数据表。

### 新建数据库

有两个选项，接下来分别讲解。

#### 选项 1. 命令行创建数据库

连接数据库通用格式:

```php
mysql -P 端口号 -h 主机名或ip地址 -u 用户名 -p
```

端口默认是 `3306`，主机名默认为 `localhost`，如果你的 MySQL 连接信息的端口与主机名与默认值一致，可不传输，如以下：

```php
$ mysql -u root -p
```

以上命令按回车键以后输入密码，认证成功即可进入：

![数据库表结构](http://cdn.learnku.com/uploads/images/202009/20/1/byZnXBnZaI.png!large)

接下来在 `mysql>` 的对话框里输入以下 SQL 语句以创建数据库：

```php
CREATE DATABASE goblog CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;
```

编码使用 `utf8mb4_unicode_ci` 是为了支持存储 Emoji，这在现代化的应用中是必要的。另外支持大小写不敏感（ci 是 Case Insensitive 的缩写）。

#### 选项 2. 使用 TablePlus 图形工具

调用数据库窗口：

![数据库表结构](http://cdn.learnku.com/uploads/images/202009/20/1/LQJoXOZkve.png!large)

填入数据库名称以及编码：

![数据库表结构](http://cdn.learnku.com/uploads/images/202009/20/1/R66G3Lcwu9.png!large)

至此数据库成功创建。

### 新建数据表

接下来我们将在代码中创建 articles 的数据表：

*main.go*

```php
.
.
.

func createTables() {
    createArticlesSQL := `CREATE TABLE IF NOT EXISTS articles(
    id bigint(20) PRIMARY KEY AUTO_INCREMENT NOT NULL,
    title varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
    body longtext COLLATE utf8mb4_unicode_ci
); `

    _, err := db.Exec(createArticlesSQL)
    checkError(err)
}

func main() {

    initDB()
    createTables()

    .
    .
    .
}
```

我们创建一个函数 `createTables()` 来专门存放创建表结构的逻辑，调用时紧跟着 `initDB()`，我们希望数据库连接建立后开始这些操作。

> **小技巧：** Go 语言中根据首字母的大小写来确定可以访问的权限。无论是函数名、方法名、常量、变量名还是结构体的名称，如果首字母大写，则可以被其他的包访问；如果首字母小写，则只能在本包中使用。可以简单的理解成，首字母大写是公有的，首字母小写是私有的。使用时，但凡不想作为公有方法提供，皆使用小写字母开头。

接下来看下 `createTables()` 方法：

```php
func createTables() {
    createArticlesSQL := `CREATE TABLE IF NOT EXISTS articles(
    id bigint(20) PRIMARY KEY AUTO_INCREMENT NOT NULL,
    title varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
    body longtext COLLATE utf8mb4_unicode_ci
); `

    _, err := db.Exec(createArticlesSQL)
    checkError(err)
}
```

首先使用了 SQL 的创建数据表语句：

```php
CREATE TABLE IF NOT EXISTS articles(
...
```

加上 `IF NOT EXISTS` 允许我们多次执行，MySQL 不会报错。

#### Exec 方法

```php
_, err := db.Exec(createArticlesSQL)
```

我们使用 `Exec()` 来执行创建数据库表结构的语句。

*一般使用 `sql.DB` 中的 `Exec()` 来执行没有返回结果集的 SQL 语句*。例如 `INSERT`, `UPDATE`, `DELETE` 等语句。语法如下：

```php
func (db *DB) Exec(query string, args ...interface{}) (Result, error)
```

`Exec()` 方法的第一个返回值为一个实现了 `sql.Result` 接口的类型，`sql.Result` 的定义如下：

```php
type Result interface {
    LastInsertId() (int64, error)    // 使用 INSERT 向数据插入记录，数据表有自增 id 时，该函数有返回值
    RowsAffected() (int64, error)    // 表示影响的数据表行数
}
```

我们可以用 `sql.Result` 中的 `LastInsertId()` 方法或 `RowsAffected()` 来判断 `SQL` 语句是否执行成功。

因为我们执行的是 `CREATE TABLE IF NOT EXISTS` 语句，会被重复执行，所以这里判断返回结果意义不大，主要判断返回的第二个参数 `err` 是否有问题。

后面课程中，下一节我们数据入库时也会用到此方法，届时再根据实例讲解多参数和返回结果的情况。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "创建数据表"
```

## 插入数据

### 说明

数据库连接和数据表皆准备就绪，接下来我们将继续 `articlesStoreHandler()` 函数里的逻辑，将验证成功的用户数据保存到数据库中。

### 插入数据

修改代码：

*main.go*

```php
.
.
.
func articlesStoreHandler(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    // 检查是否有错误
    if len(errors) == 0 {
        lastInsertID, err := saveArticleToDB(title, body)
        if lastInsertID > 0 {
            fmt.Fprint(w, "插入成功，ID 为"+strconv.FormatInt(lastInsertID, 10))
        } else {
            checkError(err)
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w,  "500 服务器内部错误")
        }
    } else {
        .
        .
        .
    }
}

func saveArticleToDB(title string, body string) (int64, error) {

    // 变量初始化
    var (
        id   int64
        err  error
        rs   sql.Result
        stmt *sql.Stmt
    )

    // 1. 获取一个 prepare 声明语句
    stmt, err = db.Prepare("INSERT INTO articles (title, body) VALUES(?,?)")
    // 例行的错误检测
    if err != nil {
        return 0, err
    }

    // 2. 在此函数运行结束后关闭此语句，防止占用 SQL 连接
    defer stmt.Close()

    // 3. 执行请求，传参进入绑定的内容
    rs, err = stmt.Exec(title, body)
    if err != nil {
        return 0, err
    }

    // 4. 插入成功的话，会返回自增 ID
    if id, err = rs.LastInsertId(); id > 0 {
        return id, nil
    }

    return 0, err
}
.
.
.
```

先看 `articlesStoreHandler()` 里的调用：

```php
lastInsertID, err := saveArticleToDB(title, body)
if lastInsertID > 0 {
    fmt.Fprint(w, "插入成功，ID 为"+strconv.FormatInt(lastInsertID, 10))
} else {
    checkError(err)
    w.WriteHeader(http.StatusInternalServerError)
    fmt.Fprint(w,  "500 服务器内部错误")
}
```

为了方便阅读，我们将插入数据的操作封装到 `saveArticleToDB()` 中，此方法接收标题和内容作为参数，返回插入成功 MySQL 返回的 `lastInsertID` 以及失败情况下的 `error` 信息。

在 SQL 没有执行错误的情况下，通常我们使用 `lastInsertID` 是否大于零来判断插入操作是否成功。

SQL 报错了提示用户内部错误。

### strconv 包的 FormatInt () 方法

```php
fmt.Fprint(w, "插入成功，ID 为"+strconv.FormatInt(lastInsertID, 10))
```

需要注意的是，我们第一次使用 Go 标准库的 strconv 包。此包主要提供字符串和其他类型之间转换的函数。类型转换在脚本类语言例如说 PHP 或者 JS 中不需要太重视，但在 Go 强类型语言中是一个很重要的概念。

```php
strconv.FormatInt(lastInsertID, 10)
```

这里我们使用到了 `FormatInt()` 方法来将类型为 `int64` 的 `lastInsertID` 转换为字符串。此方法的第二个参数 10 为十进制。

### saveArticleToDB () 函数

函数最顶端是变量声明：

```php
// 变量初始化
var (
    id   int64
    err  error
    rs   sql.Result
    stmt *sql.Stmt
)
```

多变量声明的方式与引入多个包使用 `import(...)` 同出一辙，都是 Go 语言为了让开发者少写代码而提供的简写方式。

#### prepare 语句

接下来是真正将数据入库的操作：

```php
// 1. 获取一个 prepare 声明语句
stmt, err = db.Prepare("INSERT INTO articles (title, body) VALUES(?,?)")
// 例行的错误检测
if err != nil {
    return 0, err
}

// 2. 在此函数运行结束后关闭此语句，防止占用 SQL 连接
defer stmt.Close()

// 3. 执行请求，传参进入绑定的内容
rs, err = stmt.Exec(title, body)
if err != nil {
    return 0, err
}
```

对于 Prepare 语句，常常会联想到以下：

> 永远不要相信用户提交过来数据。

**这是 Web 工程师最需要铭记的箴言警句**，为最糟糕的情况来做计划。从安全角度出发，把所有用户都当成是不怀好意的用户，他们时刻准备入侵你的系统，你必须保证他们提交的数据都得到完备的处理。

在数据库安全方面，Prepare 语句是防范 SQL 注入攻击**有效且必备**的手段。SQL 注入的例子请见 —— [翻译：Golang MySQL 驱动中的 Prepare 语句（防 SQL 注入）](http://learnku.com/go/t/49692#0e50ee) 。

##### sql.Stmt

当我们执行：

```php
stmt, err = db.Prepare("INSERT INTO articles (title, body) VALUES(?,?)")
```

会使用 SQL 连接向 MySQL 服务器发送一次请求，此方法返回一个 `*sql.Stmt` 指针对象，我们将其赋值到 `stmt` 变量里。*`stmt` 是 `statement` 的简写，是声明、陈述的意思。可以理解为将包含变量占位符 `?` 的语句先告知 MySQL 服务器端。*

此时的 stmt 是一个指针变量，会占用 SQL 连接，我们需要对其进行关闭以释放 SQL 连接：

```php
defer stmt.Close()
```

**及时关闭 SQL 连接是很有必要**的，否则很快就会遇到 `ERROR 1040: Too many connections` 的错误。

`defer` 延迟执行语句，Go 语言的 defer 语句会将其后面跟随的语句进行延迟处理，在 defer 归属的函数即将返回时，执行被延迟的语句。

##### stmt.Exec()

Prepare 只会生产 stmt ，真正执行请求的需要调用 `stmt.Exec()`：

```php
rs, err = stmt.Exec(title, body)
```

`stmt.Exec()` 的参数依次对应 `db.Prepare()` 参数中 SQL 变量占位符 `?`：

```php
INSERT INTO articles (title, body) VALUES(?,?)
```

返回值是一个 `sql.Result` 对象，定义如下：

```php
type Result interface {
    // 使用 INSERT 向数据插入记录，数据表有自增 ID 时，该函数有返回值
    LastInsertId() (int64, error)
    // 表示影响的数据表行数，常用于 UPDATE/DELETE 等 SQL 语句中
    RowsAffected() (int64, error)
}
```

因为我们的 articles 表里有设置 `id` 字段为自增 ID，故在我们的代码中，使用 `rs.LastInsertId()` 来判断是否执行成功，成功的话就返回这条新创建数据的 ID：

```php
// 4. 插入成功的话，会返回自增 ID
if id, err = rs.LastInsertId(); id > 0 {
    return id, nil
}
```

### 测试一下

代码分解得差不多了，接下来浏览器打开 [localhost:3000/articles/create](http://localhost:3000/articles/create) 填入一些测试数据：

![插入数据](http://cdn.learnku.com/uploads/images/202009/21/1/UjPdp8cBHg.png!large)

点击提交，可以看到提示：

![插入数据](https://img.herrluk.icu/typoraPicture/MEmKuMaYd1.png)

多刷新几次，可以看到自增 ID 在增加。此时查看数据表里的内容：

![插入数据](https://cdn.learnku.com/uploads/images/202009/21/1/qrnMmEf3Tn.png!large)

可看到成功插入的数据。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "保存博文到数据库"
```

## 显示文章

### 说明

上一节我们成功将表单数据存入到数据库中，接下来一起来看下如何显示文章。

显示文章分两个步骤：

1. 读取数据
2. 渲染模板

接下来我们各自说明。

### articles.show 路由

前面章节我们已在 `main()` 函数里设定 `articles.show` 路由，将其指定到 `articlesShowHandler()` 函数上：

```php
router.HandleFunc("/articles/{id:[0-9]+}", articlesShowHandler).Methods("GET").Name("articles.show")
```

目前函数 `articlesShowHandler()` 里的代码：

```php
func articlesShowHandler(w http.ResponseWriter, r *http.Request) {
    vars := mux.Vars(r)
    id := vars["id"]
    fmt.Fprint(w, "文章 ID："+id)
}
```

获取并打印出来请求 ID，为确保此路由能正常工作，访问 [localhost:3000/articles/1](http://localhost:3000/articles/1) ，可见：

![显示文章](https://cdn.learnku.com/uploads/images/202009/22/1/mq5eKIDBg0.png!large)

路由的规则是 `/articles/{id:[0-9]+}` 后面 id 部分是正则表达式限定了只能是数字，作为测试随意修改 id 部分的内容，访问 [localhost:3000/articles/1show](http://localhost:3000/articles/1show) ，可见：

![显示文章](https://cdn.learnku.com/uploads/images/202009/22/1/Aekg3K0x5e.png!large)

与预期一致。

### 读取数据

接下来我们修改 `articlesShowHandler()` 函数：

*main.go*

```php
.
.
.

// Article  对应一条文章数据
type Article struct {
    Title, Body string
    ID          int64
}

func articlesShowHandler(w http.ResponseWriter, r *http.Request) {

    // 1. 获取 URL 参数
    vars := mux.Vars(r)
    id := vars["id"]

    // 2. 读取对应的文章数据
    article := Article{}
    query := "SELECT * FROM articles WHERE id = ?"
    err := db.QueryRow(query, id).Scan(&article.ID, &article.Title, &article.Body)

    // 3. 如果出现错误
    if err != nil {
        if err == sql.ErrNoRows {
            // 3.1 数据未找到
            w.WriteHeader(http.StatusNotFound)
            fmt.Fprint(w, "404 文章未找到")
        } else {
            // 3.2 数据库错误
            checkError(err)
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "500 服务器内部错误")
        }
    } else {
        // 4. 读取成功
        fmt.Fprint(w, "读取成功，文章标题 —— "+article.Title)
    }
}
.
.
.
```

#### 代码解析

首先我们声明了一个 Article 的 struct，用以存储从数据库里读出来的文章数据：

```php
type Article struct {
    Title, Body string
    ID          int64
}
```

函数顶部是获取 URL 参数 `id` 的值：

```php
// 1. 获取 URL 参数
vars := mux.Vars(r)
id := vars["id"]
```

接下来是根据 id 从数据库里读取对应的文章数据：

```php
// 2. 读取对应的文章数据
article := Article{}
query := "SELECT * FROM articles WHERE id = ?"
err := db.QueryRow(query, id).Scan(&article.ID, &article.Title, &article.Body)
```

一般情况下，我们使用 `QueryRow()` 来读取单条数据。

#### Prepare 模式

`QueryRow()` 是可变参数的方法，语法如下：

```php
func (db *DB) QueryRow(query string, args ...interface{}) *Row
```

它的参数可以为一个或者多个。参数只有一个的情况下，我们称之为**纯文本模式**，多个参数的情况下称之为 **Prepare 模式**。

之所以称之为 Prepare 模式是因为当多个参数的情况下，`QueryRow()` 封装了 Prepare 方法的调用，也就是说，下面这段代码：

```php
err := db.QueryRow(query, id).Scan(&article.ID, &article.Title, &article.Body)
```

等同于：

```php
stmt, err := db.Prepare(query)
checkError(err)
defer stmt.Close()
err = stmt.QueryRow(id).Scan(&article.ID, &article.Title, &article.Body)
```

你可以将以上代码做下替换，然后打开 [localhost:3000/articles/3](http://localhost:3000/articles/3) 试验一下。

使用 `QueryRow()` 的 Prepare 模式不仅保证了安全性，更能提升可读性。

关于 Prepare 模式和纯文本模式，这里还需提两点：

1. 使用 Prepare 模式会发送两个 SQL 请求到 MySQL 服务器上，而纯文本模式只有一个；
2. 在使用路由参数过滤只允许数字的情况下，可以放心使用纯文本模式无需担心 SQL 注入，这里有意使用 Prepare 模式是为了课程的需要。

#### Scan () 方法

`QueryRow()` 会返回一个 `sql.Row` struct，紧接着我们使用链式调用的方式调用了 `sql.Row.Scan()` 方法：

```php
db.QueryRow(query, id).Scan(&article.ID, &article.Title, &article.Body)
```

`Scan()` 将查询结果赋值到我们的 article struct 中，传参应与数据表字段的顺序保持一致。

需要注意的是，返回的 `sql.Row` 是个指针变量，保存有 SQL 连接。当调用 `Scan()` 时，就会将连接释放。所以在每次 **QueryRow 后使用 Scan 是必须的**。

**我们极力推荐这种链式调用的方式，养成好习惯以避免掉进 SQL 连接不够用的坑。**

#### sql.ErrNoRows

当 `Scan()` 发现没有返回数据的话，会返回 `sql.ErrNoRows` 类型的错误，所以在做错误检查时需要区分到底是未找到数据或是 SQL 报错：

```php
// 3. 如果出现错误
if err != nil {
    if err == sql.ErrNoRows {
        // 3.1 数据未找到
        w.WriteHeader(http.StatusNotFound)
        fmt.Fprint(w, "404 文章未找到")
    } else {
        // 3.2 数据库错误
        checkError(err)
        w.WriteHeader(http.StatusInternalServerError)
        fmt.Fprint(w, "500 服务器内部错误")
    }
} else {
    // 4. 读取成功
    fmt.Fprint(w, "读取成功，文章标题 —— "+article.Title)
}
```

当文章未找到的情况下，我们给响应 404 提示用户。而当数据库请求出错时，通常做法是记录错误日志，并响应 500 状态码给浏览器，且提示用户服务器发生错误。

日志记录我们先统一调用 `checkError()` 方法，教程后部分章节会系统性讲解日志记录相关知识。

至此数据读取的逻辑我们已经写完，接下来做数据展示。

### 渲染模板

首先我们在读取成功的逻辑部分加载模板：

*main.go*

```php
.
.
.
func articlesShowHandler(w http.ResponseWriter, r *http.Request) {

    .
    .
    .

    // 3. 如果出现错误
    if err != nil {
        .
        .
        .
    } else {
        // 4. 读取成功，显示文章
        tmpl, err := template.ParseFiles("resources/views/articles/show.gohtml")
        checkError(err)

        err = tmpl.Execute(w, article)
        checkError(err)
    }
}
.
.
.
```

保存成功后打开 [localhost:3000/articles/3](http://localhost:3000/articles/3) 刷新会出现无法访问的情况，应该是有错误发生，我们有使用 `checkError()` 函数进行错误记录，此时查看 VSCode 的终端：

![显示文章](https://cdn.learnku.com/uploads/images/202009/22/1/DkxQ2Je38G.png!large)

报文件未找到的错误，接下来我们添加此文件：

*resources/views/articles/show.gohtml*

```php
<!DOCTYPE html>
<html lang="en">
<head>
    <title>{{ .Title }} —— 我的技术博客</title>
    <style type="text/css">.error {color: red;}</style>
</head>
<body>
    <p>ID： {{ .ID }}</p>
    <p>标题： {{ .Title }}</p>
    <p>内容：{{ .Body }}</p>
</body>
</html>
```

> 注意：如若不能访问，请重启 air 。

因为我们传参 Article struct 作为模板的绑定数据，模板中可使用 `{{ . }}` 直接访问属性。

保存成功后访问 [localhost:3000/articles/3](http://localhost:3000/articles/3) ：

![显示文章](https://cdn.learnku.com/uploads/images/202009/22/1/V57utSglWv.png!large)

可以看到成功显示文章内容。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "显示文章"
```

## 编辑文章

### 说明

这一节我们来完成编辑文章的功能。

### 1. 添加路由

我们需要两个路由，一个显示编辑文章的表单，另一个处理提交过来的表单数据。

首先在 `articles.create` 路由后面加上它们：

```php
.
.
.
func  main() {
    .
    .
    .
    router.HandleFunc("/articles/create", articlesCreateHandler).Methods("GET").Name("articles.create")
    router.HandleFunc("/articles/{id:[0-9]+}/edit", articlesEditHandler).Methods("GET").Name("articles.edit")
    router.HandleFunc("/articles/{id:[0-9]+}", articlesUpdateHandler).Methods("POST").Name("articles.update")

    .
    .
    .
}
```

### 2. articlesEditHandler()

接下来我们先创建显示编辑表单的 `articlesEditHandler()` 函数，因 Go 会报错 `articlesUpdateHandler()` 未定义，所以我们都一并创建，而后者只书写简单的调试信息：

*main.go*

```php
.
.
.

func articlesEditHandler(w http.ResponseWriter, r *http.Request) {

    // 1. 获取 URL 参数
    vars := mux.Vars(r)
    id := vars["id"]

    // 2. 读取对应的文章数据
    article := Article{}
    query := "SELECT * FROM articles WHERE id = ?"
    err := db.QueryRow(query, id).Scan(&article.ID, &article.Title, &article.Body)

    // 3. 如果出现错误
    if err != nil {
        if err == sql.ErrNoRows {
            // 3.1 数据未找到
            w.WriteHeader(http.StatusNotFound)
            fmt.Fprint(w, "404 文章未找到")
        } else {
            // 3.2 数据库错误
            checkError(err)
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "500 服务器内部错误")
        }
    } else {
        // 4. 读取成功，显示表单
        updateURL, _ := router.Get("articles.update").URL("id", id)
        data := ArticlesFormData{
            Title:  article.Title,
            Body:   article.Body,
            URL:    updateURL,
            Errors: nil,
        }
        tmpl, err := template.ParseFiles("resources/views/articles/edit.gohtml")
        checkError(err)

        err = tmpl.Execute(w, data)
        checkError(err)
    }
}

func articlesUpdateHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "更新文章")
}

func articlesIndexHandler(w http.ResponseWriter, r *http.Request) {
.
.
.
```

注释 1、2、3 部分的代码与 `articlesShowHandler()` 一致，我们不作讲解。

注释 4 部分，使用路由命名功能获取到 URL ：

```php
updateURL, _ := router.Get("articles.update").URL("id", id)
```

并将其赋值到 `ArticlesFormData` 表单数据里。

### 3. 新建 edit 模板

接下来创建 edit 模板来显示编辑文章表单：

*resources/views/articles/edit.gohtml*

```php
<!DOCTYPE html>
<html lang="en">
<head>
    <title>编辑文章 —— 我的技术博客</title>
    <style type="text/css">.error {color: red;}</style>
</head>
<body>
    <form action="{{ .URL }}" method="post">
        <p><input type="text" name="title" value="{{ .Title }}"></p>
        {{ with .Errors.title }}
        <p class="error">{{ . }}</p>
        {{ end }}
        <p><textarea name="body" cols="30" rows="10">{{ .Body }}</textarea></p>
        {{ with .Errors.body }}
        <p class="error">{{ . }}</p>
        {{ end }}
        <p><button type="submit">更新</button></p>
    </form>
</body>
</html>
```

内容与 craete.gohtml 大同小异，修改了 HTML 的 title 标签，修改了提交按钮的文字。

### 4. 测试一下

访问链接 [localhost:3000/articles/1/edit](http://localhost:3000/articles/1/edit) ，显示：

![编辑文章](https://img.herrluk.icu/typoraPicture/2023-02-05-15:42:01-bSP8e2.png)

修改下标题和内容：

![编辑文章](https://img.herrluk.icu/typoraPicture/2023-02-05-15:42:01-vbxMAn.png)

点击提交按钮：

![编辑文章](https://img.herrluk.icu/typoraPicture/2023-02-05-15:42:01-V6EqVg.png)

表单数据提交到服务器，显示了我们的测试信息。

### 5. 代码重构

我们的 `articlesEditHandler()` 代码中，有 Bad Smell —— 获取 URL 中 id 的值，与从数据库中读取 id 对应的文章，这两部分的代码与 `articlesShowHandler()` 一致。

编码时，要养成习惯，一旦发现有重复的代码，就必须将其提取出来封装成函数。这样做不止可以让你少写代码，也会提高代码的可维护性。

*main.go*

```php
.
.
.
func getRouteVariable(parameterName string, r *http.Request) string {
    vars := mux.Vars(r)
    return vars[parameterName]
}

func getArticleByID(id string) (Article, error) {
    article := Article{}
    query := "SELECT * FROM articles WHERE id = ?"
    err := db.QueryRow(query, id).Scan(&article.ID, &article.Title, &article.Body)
    return article, err
}

func articlesEditHandler(w http.ResponseWriter, r *http.Request) {

    // 1. 获取 URL 参数
    id := getRouteVariable("id", r)

    // 2. 读取对应的文章数据
    article, err := getArticleByID(id)

.
.
.
```

提取出来的函数为：

- `getRouteVariable()` —— 通过传参 URL 路由参数名称获取值
- `getArticleByID()` —— 通过传参 id 获取博文

再看 `articlesEditHandler()` ，非常干净清爽。

一般我们不需要封装会影响返回结果的逻辑处理，所以注释 3 中的错误处理与模板渲染部分我们保持不变。

### 重构 articlesShowHandler () 函数

重构文章显示代码以使用我们封装的两个函数：

```php
.
.
.
func articlesShowHandler(w http.ResponseWriter, r *http.Request) {

    // 1. 获取 URL 参数
    id := getRouteVariable("id", r)

    // 2. 读取对应的文章数据
    article, err := getArticleByID(id)

.
.
.
```

修改完成后，访问 [localhost:3000/articles/1](http://localhost:3000/articles/1) 以确保正确。

### 6. 更新数据

接下来我们书写 `articlesUpdateHandler()` 函数里的逻辑：

```php
.
.
.
func articlesUpdateHandler(w http.ResponseWriter, r *http.Request) {

    // 1. 获取 URL 参数
    id := getRouteVariable("id", r)

    // 2. 读取对应的文章数据
    _, err := getArticleByID(id)

    // 3. 如果出现错误
    if err != nil {
        if err == sql.ErrNoRows {
            // 3.1 数据未找到
            w.WriteHeader(http.StatusNotFound)
            fmt.Fprint(w, "404 文章未找到")
        } else {
            // 3.2 数据库错误
            checkError(err)
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "500 服务器内部错误")
        }
    } else {
        // 4. 未出现错误

        // 4.1 表单验证
        title := r.PostFormValue("title")
        body := r.PostFormValue("body")

        errors := make(map[string]string)

        // 验证标题
        if title == "" {
            errors["title"] = "标题不能为空"
        } else if utf8.RuneCountInString(title) < 3 || utf8.RuneCountInString(title) > 40 {
            errors["title"] = "标题长度需介于 3-40"
        }

        // 验证内容
        if body == "" {
            errors["body"] = "内容不能为空"
        } else if utf8.RuneCountInString(body) < 10 {
            errors["body"] = "内容长度需大于或等于 10 个字节"
        }

        if len(errors) == 0 {

            // 4.2 表单验证通过，更新数据

            query := "UPDATE articles SET title = ?, body = ? WHERE id = ?"
            rs, err := db.Exec(query, title, body, id)

            if err != nil {
                checkError(err)
                w.WriteHeader(http.StatusInternalServerError)
                fmt.Fprint(w, "500 服务器内部错误")
            }

            // √ 更新成功，跳转到文章详情页
            if n, _ := rs.RowsAffected(); n > 0 {
                showURL, _ := router.Get("articles.show").URL("id", id)
                http.Redirect(w, r, showURL.String(), http.StatusFound)
            } else {
                fmt.Fprint(w, "您没有做任何更改！")
            }
        } else {

            // 4.3 表单验证不通过，显示理由

            updateURL, _ := router.Get("articles.update").URL("id", id)
            data := ArticlesFormData{
                Title:  title,
                Body:   body,
                URL:    updateURL,
                Errors: errors,
            }
            tmpl, err := template.ParseFiles("resources/views/articles/edit.gohtml")
            checkError(err)

            err = tmpl.Execute(w, data)
            checkError(err)
        }
    }
}
.
.
.
```

代码注释中 1、2、3、4.1、4.3 之前章节都学习过，我们不再赘述。这里我们主要看 4.2 的逻辑：

```php
// 4.2 表单验证通过，更新数据

query := "UPDATE articles SET title = ?, body = ? WHERE id = ?"
rs, err := db.Exec(query, title, body, id)

if err != nil {
    checkError(err)
    w.WriteHeader(http.StatusInternalServerError)
    fmt.Fprint(w, "500 服务器内部错误")
}

// √ 更新成功，跳转到文章详情页
if n, _ := rs.RowsAffected(); n > 0 {
    showURL, _ := router.Get("articles.show").URL("id", id)
    http.Redirect(w, r, showURL.String(), http.StatusFound)
} else {
    fmt.Fprint(w, "您没有做任何更改！")
}
```

### Exec () 方法

执行数据更新的是 `Exec()` 方法，此方法与我们之前学习 Prepare 方法时搭配使用 `stmt.Exec()` 不一样，`stmt.Exec()` 是 `sql.Stmt` 的方法，而这里的 `Exec()` 是 `sql.DB` 提供的方法。

一般情况下，我们使用此方法来处理 `CREATE`、`UPDATE`、`DELETE` 类型的 SQL。

与 `createTables()` 方法中使用的 `Exec()` 一致：

```php
func createTables() {
    createArticlesSQL := `CREATE TABLE IF NOT EXISTS articles(
    id bigint(20) PRIMARY KEY AUTO_INCREMENT NOT NULL,
    title varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
    body longtext COLLATE utf8mb4_unicode_ci
); `

    _, err := db.Exec(createArticlesSQL)
    checkError(err)
}
```

你应该知道了，他们传参的数量不一致。

`Exec()` 的用法与 `QueryRow()` 类似，支持单独参数的**纯文本模式** 与 多个参数的 **Prepare 模式**，语法如下；

```php
func (db *DB) Exec(query string, args ...interface{}) (Result, error) 
```

同样的，在 **Prepare 模式** 下会向 MySQL 发送两个 SQL 请求。

还有再强调都不为多的：

> 永远不要相信用户提交过来数据。

善用 `Exec()` 的 **Prepare 模式** 来防范 SQL 注入攻击。

### 7. 测试更新

### 测试正常修改

访问 [localhost:3000/articles/1/edit](http://localhost:3000/articles/1/edit) ，修改内容：

![编辑文章](https://img.herrluk.icu/typoraPicture/2023-02-05-15:42:01-MU4iE5.png)

提交可见跳转到文章详情页面：

![编辑文章](https://img.herrluk.icu/typoraPicture/2023-02-05-15:42:01-COQ6lJ.png)

### 测试过短的标题

再次访问 [localhost:3000/articles/1/edit](http://localhost:3000/articles/1/edit) ，将标题修改到只有两个字，点击更新按钮：

![编辑文章](https://img.herrluk.icu/typoraPicture/2023-02-05-15:42:01-0wgWyL.png)

至此我们的更新功能开发完毕。

### 8. 封装表单验证

大家应该注意到了 `articlesUpdateHandler()` 中的表单验证与 `articlesStoreHandler()` 使用同一套代码，我们将其抽出来作为单独的函数：

*main.go*

```php
.
.
.

func validateArticleFormData(title string, body string) map[string]string {
    errors := make(map[string]string)
    // 验证标题
    if title == "" {
        errors["title"] = "标题不能为空"
    } else if utf8.RuneCountInString(title) < 3 || utf8.RuneCountInString(title) > 40 {
        errors["title"] = "标题长度需介于 3-40"
    }

    // 验证内容
    if body == "" {
        errors["body"] = "内容不能为空"
    } else if utf8.RuneCountInString(body) < 10 {
        errors["body"] = "内容长度需大于或等于 10 个字节"
    }

    return errors
}

func  articlesStoreHandler(w http.ResponseWriter, r *http.Request) {
.
.
.
```

接下来将 `validateArticleFormData()` 函数应用到上文提到的两个函数中：

*main.go*

```php
.
.
.

func articlesStoreHandler(w http.ResponseWriter, r *http.Request) {

    title := r.PostFormValue("title")
    body := r.PostFormValue("body")

    errors := validateArticleFormData(title, body)
.
.
.
```

*main.go*

```php
.
.
.
func  articlesUpdateHandler(w http.ResponseWriter, r *http.Request) {
    .
    .
    .

        // 4.1 表单验证
        title := r.PostFormValue("title")
        body := r.PostFormValue("body")

        errors := validateArticleFormData(title, body)
.
.
.
```

进入 [localhost:3000/articles/1/edit](http://localhost:3000/articles/1/edit) 尝试测试正确和错误的数据。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "更新文章"
```

## 文章列表

### 说明

现在我们数据库已经有一些文章了，否则请前往 [localhost:3000/articles/create](http://localhost:3000/articles/create) 创建几篇文章以供测试。

接下来我们开发文章列表页面，以罗列我们所有的文章。

> **提示：** 本节我们主要讲解 `Query()` 方法的使用，为保持专注，暂不实现分页功能，后续章节会有涉及。

### 路由

我们已经在前面章节中注册了 `articles.index` 路由，如下：

```php
router.HandleFunc("/articles", articlesIndexHandler).Methods("GET").Name("articles.index")
```

接下来查看 `articlesIndexHandler()` 函数：

```php
func articlesIndexHandler(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "访问文章列表")
}
```

访问 [localhost:3000/articles](http://localhost:3000/articles) 以确保正确：

![文章列表](https://img.herrluk.icu/typoraPicture/2023-02-05-15:43:06-VWrX4Q.png)

### 读取数据

*main.go*

```php
.
.
.
func articlesIndexHandler(w http.ResponseWriter, r *http.Request) {
    // 1. 执行查询语句，返回一个结果集
    rows, err := db.Query("SELECT * from articles")
    checkError(err)
    defer rows.Close()

    var articles []Article
    //2. 循环读取结果
    for rows.Next() {
        var article Article
        // 2.1 扫描每一行的结果并赋值到一个 article 对象中
        err := rows.Scan(&article.ID, &article.Title, &article.Body)
        checkError(err)
        // 2.2 将 article 追加到 articles 的这个数组中
        articles = append(articles, article)
    }

    // 2.3 检测遍历时是否发生错误
    err = rows.Err()
    checkError(err)

    // 3. 加载模板
    tmpl, err := template.ParseFiles("resources/views/articles/index.gohtml")
    checkError(err)

    // 4. 渲染模板，将所有文章的数据传输进去
    err = tmpl.Execute(w, articles)
    checkError(err)
}
.
.
.
```

#### Query () 读取结果集

一般情况下，我们使用 `Query()` 从数据库中读取多条数据，而之前学到 `QueryRow()` 是读取单条的数据。语法如下：

```php
func (db *DB) Query(query string, args ...interface{}) (*Rows, error)
```

调用方式与 `QueryRow()` 和 `Exec()` 一致，支持单一参数的**纯文本模式**，以及多个参数的 **Prepare 模式**。

这里因为我们查询时候没有使用来自用户的数据，所以只是使用 **纯文本模式**。

作为回顾 —— **纯文本模式** 只会发送一次 SQL 请求，而 **Prepare 模式** 会发送两次。

#### Rows 对象

`Query()` 返回结果集 `Rows` ，包含从数据库里读取出来的数据和 SQL 连接。

#### Query () 与 Rows 时需要注意的点

1. 在每一次 `for rows.Next()` 后，都记得要检测下是否有错误发生，调用 `rows.Err()` 可获取到错误；
2. 使用 `rows.Next()` 遍历数据，遍历到最后内部遇到 EOF 错误，会自动调用 `rows.Close()` 将 SQL 连接关闭；
3. 使用 `rows.Next()` 遍历时，如遇错误，SQL 连接也会自动关闭；
4. `rows.Close()` 可调用多次，使用 `rows.Close()` 可保证 SQL 连接永远是关闭的。
5. `defer rows.Close()` 需在检测 err 以后调用，否则会让运行时 panic ；
6. 牢记在获取到结果集后，**必须**执行 `defer rows.Close()`。这样做能防止有时你在函数里过早 return ，或者其他操作忘记关闭资源，这是一个值得培养的良好习惯；
7. 如果你在循环中执行 `Query()` 并获取 `Rows` 结果集，请不要使用 `defer` ，而是直接调用 `rows.Close()`，因为 `defer` 不会立刻执行，而是在函数执行结束后执行。

### 创建模板

数据已经读取出来了，接下来创建模板：

*resources/views/articles/index.gohtml*

```php
<!DOCTYPE html>
<html lang="en">
<head>
    <title>所有文章 —— 我的技术博客</title>
    <style type="text/css">.error {color: red;}</style>
</head>
<body>
    <h1>所有文章</h1>
    <ul>
        {{ range $key, $article := . }}
            <li><a href=""><strong>{{ $article.ID }}</strong>: {{ $article.Title }}</a></li>
        {{ end }}
    </ul>
</body>
</html>
```

我们直接将类型为 Map 的 articles 数据传参给模板，模板中可直接使用 `{{ . }}` 来获取到。

接下来就是使用 Go 模板库的循环语法 `{{range …}}{{end}}` 来遍历数据，此语法的使用与 Go 语言的遍历语句 `range` 类似。

接下来打开浏览器 [localhost:3000/articles](http://localhost:3000/articles) ：

![文章列表](https://img.herrluk.icu/typoraPicture/2023-02-05-15:43:06-XRlETP.png)

### 模板中调用函数

文章已经能正确展示，接下来我们为列表里的文章加上链接。

先为 Article 对象新增 `Link()` 方法：

*main.go*

```php
.
.
'
// Article  对应一条文章数据
type Article struct {
    .
    .
    .
}

// Link 方法用来生成文章链接
func (a Article) Link() string {
    showURL, err := router.Get("articles.show").URL("id", strconv.FormatInt(a.ID, 10))
    if err != nil {
        checkError(err)
        return ""
    }
    return showURL.String()
}
.
.
.
```

生成 `articles.show` URL 的代码我们之前已经学习过，这里主要注意 Go 中方法的使用。

为了更直观地区分，以下是他们声明时的对比：

```php
type Object struct {
    ...
}
// Object 的方法
func (obj *Object) method() {
    ...
}

// 只是一个函数
func function() {
    ...
}
```

以下是调用时的对比：

```php
// 调用方法：
o := new(Object)
o.method()

// 调用函数
function()
```

#### 生成链接

生成文章链接的方法定义好了，接下来我们在模板中调用他，只需要修改 HTML 里 a 标签的 href 属性即可：

*resources/views/articles/index.gohtml*

```php
.
.
.
<li><a  href="{{ $article.Link }}"><strong>{{ $article.ID }}</strong>: {{ $article.Title }}</a></li>
.
.
.
```

Go 模板里调用函数语法如下：

```php
{{ Function arg... }}
```

这里我们调用 Article 的 `Link()` 方法：

```php
{{ $article.Link }}
```

加入参数的话，就是：

```php
{{ $article.Link  参数1 参数2 }}
```

保存后刷新页面并查看页面源码：

![文章列表](https://img.herrluk.icu/typoraPicture/2023-02-05-15:43:07-BfLVq5.png)

至此文章列表开发完成。

需要提一句，目前来讲，我们读取了所有数据，在后面章节当讲到 GORM 时，我们会为其开发分页功能。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "文章列表"
```



## 删除文章

### 说明

接下来开发文章的删除功能。

删除功能开发清单如下：

- 文章详细页面显示删除按钮
- 删除表单提交后后台处理

我们先开发后台处理的逻辑，再在文章详情页里显示删除按钮。

### 删除的逻辑

在我们的 `articles.update` 后注册 `articles.delete` 路由：

*main.go*

```php
.
.
.

func main(){
    .
    .
    .
    router.HandleFunc("/articles/{id:[0-9]+}", articlesUpdateHandler).Methods("POST").Name("articles.update")
router.HandleFunc("/articles/{id:[0-9]+}/delete", articlesDeleteHandler).Methods("POST").Name("articles.delete")

    .
    .
    .
}
```

接下来是 `articlesDeleteHandler()`:

*main.go*

```php
.
.
.
func articlesDeleteHandler(w http.ResponseWriter, r *http.Request) {

    // 1. 获取 URL 参数
    id := getRouteVariable("id", r)

    // 2. 读取对应的文章数据
    article, err := getArticleByID(id)

    // 3. 如果出现错误
    if err != nil {
        if err == sql.ErrNoRows {
            // 3.1 数据未找到
            w.WriteHeader(http.StatusNotFound)
            fmt.Fprint(w, "404 文章未找到")
        } else {
            // 3.2 数据库错误
            checkError(err)
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "500 服务器内部错误")
        }
    } else {
        // 4. 未出现错误，执行删除操作
        rowsAffected, err := article.Delete()

        // 4.1 发生错误
        if err != nil {
            // 应该是 SQL 报错了
            checkError(err)
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "500 服务器内部错误")
        } else {
            // 4.2 未发生错误
            if rowsAffected > 0 {
                // 重定向到文章列表页
                indexURL, _ := router.Get("articles.index").URL()
                http.Redirect(w, r, indexURL.String(), http.StatusFound)
            } else {
                // Edge case
                w.WriteHeader(http.StatusNotFound)
                fmt.Fprint(w, "404 文章未找到")
            }
        }
    }
}

func  main()  {
.
.
.
```

删除的执行逻辑如下：

1. 读取对应的文章数据，看看是否存在；
2. 是的话执行删除；
3. 否的话提示用户 404；
4. 过程中如果发生 SQL 查询错误，就提示用户 500 内部错误。

以上的逻辑在代码里一一对应，请注意看代码注释。都是之前学过的代码，想必大家应该很熟悉，这里就不再浪费篇幅。

删除的逻辑，我们封装到 Article 的 `Delete()` 方法内，我们创建此方法；

*main.go*

```php
.
.
.
// Delete 方法用以从数据库中删除单条记录
func (a Article) Delete() (rowsAffected int64, err error) {
    rs, err := db.Exec("DELETE FROM articles WHERE id = " + strconv.FormatInt(a.ID, 10))

    if err != nil {
        return 0, err
    }

    // √ 删除成功
    if n, _ := rs.RowsAffected(); n > 0 {
        return n, nil
    }

    return 0, nil
}

func main() {
.
.
.
```

这里我们用的是 `Exec()`，一般在 CREATE/UPDATE/DELETE 时使用。这里使用的是纯文本模式的查询模式，因为 ID 我们是从数据库里拿出来的，是自增 ID ，无需担心 SQL 注入，这样可以少发送一次 SQL 请求。

### 创建入口

删除的逻辑有了，接下来我们在文章详情页面添加删除按钮。

开始之前，我们需要修改模板的加载方式。我们将使用 Go template 的自定义函数功能，在模板中生成提交删除表单的链接。

*main.go*

```php
.
.
.
func  articlesShowHandler(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    // 3. 如果出现错误
    if err !=  nil {
        .
        .
        .
    } else {
        // 4. 读取成功，显示文章
        tmpl, err := template.New("show.gohtml").
            Funcs(template.FuncMap{
                "RouteName2URL": RouteName2URL,
                "Int64ToString": Int64ToString,
            }).
            ParseFiles("resources/views/articles/show.gohtml")
        checkError(err)
        err = tmpl.Execute(w, article)
        checkError(err)
    }
}
```

对比之前直接调用 `template.ParseFiles`：

```php
tmpl, err := template.ParseFiles("resources/views/articles/show.gohtml")
```

这一次是使用 `template.New()` 先初始化，然后使用 `Funcs()` 注册函数，再使用 `ParseFiles ()`，需要注意的是 `New()` 的参数是模板名称，需要对应 `ParseFiles()` 中的文件名，否则会无法正确读取到模板，最终显示空白页面。

`Funcs()` 方法的传参是 `template.FuncMap` 类型的 Map 对象。键为模板里调用的函数名称，值为当前上下文的函数名称:

```php
Funcs(template.FuncMap{
    "RouteName2URL": RouteName2URL,
    "Int64ToString": Int64ToString,
}).
```

RouteName2URL 和 Int64ToString 两个函数还未存在，我们需要创建：

*main.go*

```php
.
.
.
// RouteName2URL 通过路由名称来获取 URL
func RouteName2URL(routeName string, pairs ...string) string {
    url, err := router.Get(routeName).URL(pairs...)
    if err != nil {
        checkError(err)
        return ""
    }

    return url.String()
}

// Int64ToString 将 int64 转换为 string
func Int64ToString(num int64) string {
    return strconv.FormatInt(num, 10)
}

func (a Article) Delete() (rowsAffected int64, err error) {
.
.
.
```

两个函数的代码我们之前都介绍过，且每个函数上都有注释，请仔细阅读几遍即可。接下来我们修改 `show.gohtml` ：

*resources/views/articles/show.gohtml*

```php
<!DOCTYPE html>
<html lang="en">

<head>
    <title>{{ .Title }} —— 我的技术博客</title>
    <style type="text/css">
        .error {
            color: red;
        }
    </style>
</head>

<body>
    <p>ID： {{ .ID }}</p>
    <p>标题： {{ .Title }}</p>
    <p>内容：{{ .Body }}</p>

    {{/* 构建删除按钮  */}}
    {{ $idString := Int64ToString .ID  }}
    <form action="{{ RouteName2URL "articles.delete" "id" $idString }}" method="post">
        <button type="submit" onclick="return confirm('删除动作不可逆，请确定是否继续')">删除</button>
    </form>

</body>

</html>
```

首先这是模板注释，请注意 `{{/*` 之间没有空格，同理注释关闭符：

```php
{{/* 构建删除按钮  */}}
```

接下来是模板里设置变量，以及对自定义函数的调用，`.ID` 作为 `Int64ToString` 参数而存在：

```php
 {{ $idString := Int64ToString .ID  }}
```

接下来生成表单请求的链接：

```php
<form action="{{ RouteName2URL "articles.delete" "id" $idString }}" method="post">
```

函数调用 `RouteName2URL` 后面跟着的三个用空格隔开的元素，皆为参数。打开文章详情页 [localhost:3000/articles/1](http://localhost:3000/articles/1) 并查看源码：

![删除文章](https://img.herrluk.icu/typoraPicture/2023-02-05-16:03:52-m5zyWg.png)

可以看到模板注释和变量赋值不会被显示出来，表单的提交链接也是正确的。

### 测试一下

接下来访问 [localhost:3000/articles/1](http://localhost:3000/articles/1) 点击删除按钮，会有类似的弹出层：

![删除文章](https://img.herrluk.icu/typoraPicture/2023-02-05-16:03:52-9krPE8.png)

点击 OK 以后会删除数据，并跳转到列表，可以看到 ID 为 1 的文章已被删除：

![删除文章](https://img.herrluk.icu/typoraPicture/2023-02-05-16:03:53-FjdOfX.png)

至此文章删除功能开发完成。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "删除文章"
```

## sql 知识总结

### 说明

本章零零散散学习了 Go 标准库里 sql 包使用方法，这里做一个总结，把知识点罗列下，方便大家复习。

### 1. sql 驱动

Go 的 sql 包里只包含接口，各个数据库系统的驱动可以在官方维护的 Wiki 里找到 [github.com/golang/go/wiki/SQLDrive...](https://github.com/golang/go/wiki/SQLDrivers) 。

知名数据库各自都有几个驱动可供选择，推荐以下驱动：

- MySQL/MariaDB —— [github.com/go-sql-driver/mysql/](https://github.com/go-sql-driver/mysql/)
- Postgres SQL —— [github.com/lib/pq](https://github.com/lib/pq)
- SQLite3 —— [github.com/mattn/go-sqlite3](https://github.com/mattn/go-sqlite3)
- Oracle —— [github.com/mattn/go-oci8](https://github.com/mattn/go-oci8)
- SQL Server —— [github.com/denisenkom/go-mssqldb](https://github.com/denisenkom/go-mssqldb)

选择时需要考虑的因素有以下几个：

- star 数越多越好
- issue 数越低越好
- 项目维护活跃，最后更新日期越接近越好
- 有清楚的版本区分（查看项目的 Releases 标签）

以上选择方法同样适用于选择其他 Go 第三方开源库。

### 2. sql.DB

`sql.DB` 结构是 `database/sql` 包封装的一个数据库操作对象，包含了操作数据库的基本方法。大部分时间我们操作数据库都使用它。

可以把 `sql.DB` 当做是连接池，它内部会自动维护 SQL 连接的关闭和创建。

### 3. 连接池设置

我们可以通过以下方法来干预连接池，推荐以下设置：

```php
// 设置最大连接数
db.SetMaxOpenConns(100)

// 设置最大空闲连接数
db.SetMaxIdleConns(25)

// 设置每个链接的过期时间
db.SetConnMaxLifetime(5 * time.Minute)
```

### 4. DSN

`DSN` 全称为 `Data Source Name`，表示数据库连接源，用于定义数据库的连接信息，不同数据库的 DSN 格式不同，MySQL 的 DSN 格式如下：

```php
// [用户名[:密码]@][协议(数据库服务器地址)]]/数据库名称?参数列表
[username[:password]@][protocol[(address)]]/dbname[?param1=value1&...&paramN=valueN]
```

上面的一大串字串对人的眼睛不够友好，为了更加直观，我们可以使用 `mysql.Config` 来创建连接信息：

```php
// 设置数据库连接信息
config := mysql.Config{
    User:                 "homestead",
    Passwd:               "secret",
    Addr:                 "127.0.0.1:3306",
    Net:                  "tcp",
    DBName:               "goblog",
    AllowNativePasswords: true,
}

// fmt.Println("conn: ", config.FormatDSN())
```

### 5. 初始化 sql.DB

一般而言，我们使用 `Open()` 方法便可初始化并返回一个 `*sql.DB` 实例，如下：

```php
func Open(driverName, dataSourceName string) (*DB, error)
```

使用 `Open()` 方法只要传入驱动名称及对应的 DSN 便可，使用很简单，也很通用，当需要连接不同数据库时，只需要修改驱动名与 DSN 即可。配合 mysql.Config 使用：

```php
db, err = sql.Open("mysql", config.FormatDSN())
```

使用 `Open()` 时需要知道的是 —— 我们只是做好连接的准备，并未真是连接到数据库上。因未发生连接，所以即使配置信息有误，也不会报错。所以一般我们在使用的时候，会搭配 `Ping()` 进行测试：

```php
err = db.Ping()
checkError(err)
```

`Ping()` 会与数据库服务器发生连接，如果连接信息有错误，err 就会有值，否为 nil。

DB 的连线都是被设计来当作长连接使用的，所以不该频繁的 Open、Close。Open 取得的 db 实例，要重複利用，不应该去重复生成。

### 5. Prepare 和 Stmt

`sql.DB.Prepare()` 方法会返回一個 `sql.Stmt` 对象，与 Stmt 相关的方法如下：

```php
stmt.Exec()
stmt.Query()
stmt.QueryRow()
stmt.Close()
```

> 请注意与 sql.DB 下的方法区分。

做单独的语句查询时，谨记调用 `defer stmt.Close()` 来关闭 SQL 连接。

使用 Prepare 语句会发送两次请求到数据库服务器上，第一次是调用 `Prepare()` 语句时，第二次是调用以上提到的四个 Stmt 方法时：

![sql 知识总结](https://img.herrluk.icu/typoraPicture/2023-02-05-16:04:37-H3F5TK.png)

Prepare 语句可有效防范 SQL 注入攻击。

以下常见的 DB 查询方法中，调用在传参一个以上时，底层皆会使用 Prepare 来发送请求：

```php
func (db *DB) Exec(query string, args ...interface{}) (Result, error)
func (db *DB) Query(query string, args ...interface{}) (*Rows, error)
func (db *DB) QueryRow(query string, args ...interface{}) *Row
```

另外，还有 [翻译：Go 数据库技巧：重复利用 Prepare 后的 stmt 来提高 MySQL 的执行效...](https://learnku.com/go/t/49736) 。

### 6. Exec()

一般增加、删除、更新，或者修改表结构，都使用 `sql.DB` 中的 `Exec()` 方法来处理。

语法如下：

```php
func (db *DB) Exec(query string, args ...interface{}) (Result, error)
```

单参数为**纯文本模式**，不使用 Prepare，只发送一条 SQL 查询：

```php
db.Exec("DELETE FROM articles WHERE id = " + strconv.FormatInt(a.ID, 10))
```

多参数为 **Prepare 模式**，底层使用 Prepare 语句，会发送两条 SQL 查询：

```php
query := "UPDATE articles SET title = ?, body = ? WHERE id = ?"
rs, err := db.Exec(query, title, body, id)
```

第二个及以上的参数为 SQL 占位符对应的数据。

`Exec()` 方法会返回一个 `sql.Result` 类型的实例。

### 7. sql.Result

Result 的定义如下，包含两个方法：

```php
type Result interface {
    LastInsertId() (int64, error)
    RowsAffected() (int64, error)
}
```

`LastInsertId()` 方法只用在 `INSERT` 语句且数据表有自增 ID 时才有返回自增 ID 值，否则返回 0。

`RowsAffected()` 表示影响的数据表行数，我们以此来判断 `SQL` 语句是否执行成功。

SQL 语法正确的情况下 `RowsAffected()` 为 0 ，则表示 SQL 执行成功了，但是数据库里的数据没有任何变更。例如说我们的数据库中并没有 ID 为 6 的数据，这时候执行以下语句：

```php
DELETE FROM articles WHERE id=6
```

就会出现 SQL 执行成功了，但是数据未更改的情况。

### 8. Query()

一般使用 `sql.DB` 中的 `Query()` 来查询得到多条数据。语法如下：

```php
func (db *DB) Query(query string, args ...interface{}) (*Rows, error)
```

如下获取所有文章的例子：：

```php
rows, err := db.Query("SELECT * from articles")
```

`Query()` 方法返回一个 `sql.Rows` 结构体，代表一个查询结果集。

你可能发现了，Query 和 Exec 都可以执行 SQL 语句，**那他们的区别是什么呢？**

Exec 只会返回最后插入 ID 和影响行数，而 Query 会返回数据表里的内容（结果集）。

或者可以这么记：

> Query 中文译为 **查询**，而 Exec 译为 **执行**。想查询数据，使用 Query。想执行命令，使用 Exec。

### 9. sql.Rows

`sql.Rows` 所包含的方法如下：

```php
func (rs *Rows) Close() error                            //关闭结果集
func (rs *Rows) ColumnTypes() ([]*ColumnType, error)    //返回数据表的列类型
func (rs *Rows) Columns() ([]string, error)             //返回数据表列的名称
func (rs *Rows) Err() error                      // 错误集
func (rs *Rows) Next() bool                      // 游标，下一行
func (rs *Rows) Scan(dest ...interface{}) error  // 扫描结构体
func (rs *Rows) NextResultSet() bool            
```

结果集在检出完 err 以后，遍历数据之前，应调用 `defer rows.Close()` 来关闭 SQL 连接。

一般我们会使用 `rows.Next()` 来遍历数据，如：

```php
var articles []Article
//2. 循环读取结果
for rows.Next() {
    var article Article
    // 2.1 扫描每一行的结果并赋值到一个 article 对象中
    err := rows.Scan(&article.ID, &article.Title, &article.Body)
    checkError(err)
    // 2.2 将 article 追加到 articles 的这个数组中
    articles = append(articles, article)
}
// 2.3 检测循环时是否发生错误
err = rows.Err()
checkError(err)
```

循环完毕需检测是否发生错误。

`rows.Scan()` 参数的顺序很重要，需要和查询的结果的 column 对应。

```php
SELECT * from articles
```

而我们的 articles 的表结构为：

```php
CREATE TABLE `articles` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci NOT NULL,
  `body` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;
```

查询到的每一行的 column 顺序是 `id, title, body`，因此 rows.Scan 也需要按照此顺序不然会造成数据读取的错位。

### 10. QueryRow()

如果是读取一行数据，可以使用 `QueryRow()`，语法定义如下：

```php
func (db *DB) QueryRow(query string, args ...interface{}) *Row
```

返回的是一个 `sql.Row` 对象，与其相关的调用有：

```php
func (r *Row) Scan(dest ...interface{}) error
```

`sql.Row` 没有 `Close` 方法，当我们调用 `Scan()` 时就会自动关闭 SQL 连接。所以为了防止忘记关闭而浪费资源，一般需要养成连着调用 `Scan()` 习惯：

```php
article := Article{}
query := "SELECT * FROM articles WHERE id = ?"
err := db.QueryRow(query, id).Scan(&article.ID, &article.Title, &article.Body)
```

以上我们从数据库中读取对应 ID 的一条数据，并立刻调用 `Scan()` 读取数据到 article 变量里。

当出现请求结果不止一条数据的情况，`QueryRow()` 会只使用第一条数据。

### 11. Context 上下文

三个常用的 SQL 请求方法都有其支持上下文的版本，如下：

```php
func (db *DB) Exec(query string, args ...interface{}) (Result, error)
func (db *DB) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)
func (db *DB) Query(query string, args ...interface{}) (*Rows, error)
func (db *DB) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)
func (db *DB) QueryRow(query string, args ...interface{}) *Row
func (db *DB) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row
```

支持 Context 上下文的方法传参标准库 context 里的 context.Context 对象实例。

在一些特殊场景里，我们需要 SQL 请求在执行还未完成时，我们可以取消他们（cancel），或者为请求设置最长执行时间（timeout），就会用到这些方法。

在这里你只需要记住有这些方法即可，手动管理上下文 SQL 请求使用场景较少，篇幅考虑这里不做赘述。

另外需要知道的是，所有的请求方法底层都是用其上下文版本的方法调用，且传入默认的上下文，例如 `Exec()` 的源码：

```php
func (db *DB) Exec(query string, args ...interface{}) (Result, error) {
    return db.ExecContext(context.Background(), query, args...)
}
```

底层调用的是 `ExecContext()` 方法。`context.Background()` 是默认的上下文，这是一个空的 `context` ，我们无法对其进行取消、赋值、设置 deadline 等操作。

### 12. 事务处理 sql.Tx

在前面课程的 SQL 操作中，我们都没有开启事务，如果没有开启事务，当其中某个语句执行错误，则前面已经执行的 SQL 语句无法回滚。

对于一些要求比较严格的业务逻辑来说，如付款、转账等，应该在同一个事务中提交多条 SQL 语句，避免发生执行出错无法回滚事务的情况。

使用以下可以开启事务：

```php
func (db *DB) Begin() (*Tx, error)
func (db *DB) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)
```

`Begin()` 和 `BeginTx()` 方法返回一个 `sql.Tx` 结构体，他支持以上我们提到过的几种查询方法：

```php
func (tx *Tx) Exec(query string, args ...interface{}) (Result, error)
func (tx *Tx) ExecContext(ctx context.Context, query string, args ...interface{}) (Result, error)
func (tx *Tx) Query(query string, args ...interface{}) (*Rows, error)
func (tx *Tx) QueryContext(ctx context.Context, query string, args ...interface{}) (*Rows, error)
func (tx *Tx) QueryRow(query string, args ...interface{}) *Row
func (tx *Tx) QueryRowContext(ctx context.Context, query string, args ...interface{}) *Row

// 预编译 Prepare
func (tx *Tx) Stmt(stmt *Stmt) *Stmt
func (tx *Tx) StmtContext(ctx context.Context, stmt *Stmt) *Stmt
func (tx *Tx) Prepare(query string) (*Stmt, error)
func (tx *Tx) PrepareContext(ctx context.Context, query string) (*Stmt, error)
```

使用这同一个 `sql.Tx` 对数据库进行操作，就会在同一个事务中提交。

当使用 `sql.Tx` 的操作方式操作数据后，需要使用 `sql.Tx` 的 `Commit()` 方法提交事务，如果出错，则可以使用 `sql.Tx` 中的 `Rollback()` 方法回滚事务，保持数据的一致性，下面是这两个方法的定义：

```php
func (tx *Tx) Commit() error
func (tx *Tx) Rollback() error
```

下面是个简单的示例：

```php
func (s Service) DoSomething() (err error) {
    // 1. 创建事务
    tx, err := s.db.Begin()
    if err != nil {
        return
    }
    // 2. 如果请求失败，就回滚所有 SQL 操作，否则提交
    //    defer 会在当前方法的最后执行
    defer func() {
        if err != nil {
            tx.Rollback()
            return err
        }
        err = tx.Commit()
    }()

    // 3. 执行各种请求
    if _, err = tx.Exec(...); err != nil {
        return err
    }
    if _, err = tx.Exec(...); err != nil {
        return err
    }
    // ...
    return nil
}
```

需要注意的是，所有 SQL 操作都必须使用 `tx` 来操作，才能支持事务，如果中间使用 `db.Exec()` 那这条语句是无法回滚的。

### 结语

以上基本上覆盖了大部分 database/sql 标准库的日常使用知识。

这些是 Go 开发者需要掌握的基础知识，是以后使用 ORM 或者其他高级 SQL 工具的基石。

# 7.代码组织

## 代码结构

### 说明

目前我们的所有 Go 代码都写在 *main.go* 中，已有五百多行，严格来讲，目前我们的项目的可维护性极差。不信你试试，需要花多长时间才能找到处理删除文章部分的代码？

### 代码组织的重要性

**为什么我们需要考虑代码结构？**

首先，需要明白一个道理：

> 所有的代码写在一个巨大的 main.go 文件里，Go 编译器也是可以正常执行的。

假如一个项目里有万行的 Go 代码，这些代码其实放到同一个文件里，机器都是可以执行的。但是来了个新人，一看这万行代码的文件，得多崩溃，定位某个功能的代码，都需要花费大量的时间。

优秀的代码组织结构，是为了方便我们快速定位代码，以此来提高开发效率。

需时刻谨记：

> “Any fool can write code that a computer can understand. Good programmers write code that humans can understand.” — Martin Fowler
>
> **任何人都能写机器能识别的代码，而优秀的工程师能写傻瓜都能看懂的代码。**

#### 为什么不从一开始就做好代码结构？

主要是为了演示单文件程序的代码布置，同时也让初学者体验到，大量代码放置于同一个文件中，阅读体验与可维护性得有多差。

#### Go Web 项目都有哪些组织方式？

一般根据项目体积，Go Web 程序的代码组织常见有以下几种方式：

1. **单文件** —— 也称为**反模式**，我们目前的形式，适用于 500 行代码以内小而美的程序
2. **多文件** —— 也称为**扁平模式**，在根目录展开，将处理业务逻辑的代码移到单独的文件中，例如 articles_handler/user_handler 等，适合小型应用或者简单的 API 程序
3. **目录归类** —— 也称为**分层模式**，利用目录进行归类，具备层级关系，适用于代码量多，业务逻辑复杂的场景

因为 goblog 是个全栈的 Web 项目，随着开发的推进，项目会变得很复杂，所以接下来我们将会使用 **目录归类** 的方式来组织项目。

### 如何组织

先来看看当下我们的 main.go 里有什么内容：

1. 应用初始化 —— 数据库连接初始化、路由初始化、配置加载等…
2. 路由 —— 配置 URI 与控制器的对应关系
3. 控制器 —— 处理业务逻辑的 aboutHandler、homeHandler、articlesShowHandler 等
4. 数据库操作 —— 创建表、查询等
5. 数据模型 —— Article
6. 表单验证
7. 辅助函数 —— Int64ToString、RouteName2URL
8. 中间件
9. 错误处理等

可见目前的 goblog 麻雀虽小五脏俱全。

我们将参考知名框架 Laravel 的文件组织结构，以 MVC 为核心来构建我们的 goblog 程序。

选择 Laravel 的原因，除了其目录命名合理以外，其兼顾 Web 、API 、命令行三个入口的设计，也很值得我们借鉴。

#### 为什么选用 MVC ?

选用 MVC 是因其普遍性，这是 Web 开发中最常见的程序组织模式。另外这个模式也有简单易学的特点。

#### 什么是 MVC ？

MVC 模式是一种流行的 Web 应用架构技术，它被命名为模型 - 视图 - 控制器 (Model-View-Controller)。在分离应用程序内部的关注点方面，MVC 是一种强大而简洁的方式，尤其适合应用在 Web 应用程序中。

MVC 将应用程序的用户界面分为三个主要部分：

1. 模型：描述了要处理的数据以及修改和操作数据的业务规则，负责数据存储和读取；
2. 视图：定义应用程序用户界面的显示方式，一般由 HTML 混合动态语法，负责数据展现；
3. 控制器：用于处理来自用户、整个应用程序流以及模型和视图间的衔接。

### 图解一个用户请求

当用户在请求一个网页时，一个完整的访问过程如下：

1. 打开浏览器在地址栏输入 URL 并访问；
2. 程序 **路由器** 将 URL 请求映射到指定控制器上；
3. **控制器** 收到请求，开始进行处理。如果视图需要动态数据进行渲染，则控制器会开始从**模型**中读取数据；
4. 数据读取完毕，将数据传送给**视图**进行渲染；
5. 视图渲染完成，在浏览器上呈现出**完整页面**；

如下图：

![file](https://img.herrluk.icu/typoraPicture/2023-02-06-15:22:31-1z5jRq.png)

### 底层代码存放目录 pkg

一个项目中 MVC 是指的是业务逻辑的代码，而除了支撑业务逻辑代码以外，还有底层的辅助代码。例如路由加载、数据库初始化等。拿知名的 Laravel 框架来举例，业务逻辑的代码是 [github.com/laravel/laravel](https://github.com/laravel/laravel) ，而底层代码是以 Illuminate 为命名空间的包 [github.com/laravel/framework/tree/...](https://github.com/laravel/framework/tree/8.x/src/Illuminate) 。

在我们的项目中，遵循 Go 社区的惯例，这些底层代码我们会归类为各自的包，并放置于 pkg 目录下。

pkg 目录下的包，我们会尽量保持其独立性，这样方便在其他项目中复用。但是最重要的，当前还是以服务 goblog 项目为主。

### 结语

相较于其他 Web 开发语言例如说 PHP ，Go 还是比较年轻的。

PHP 有 Laravel 框架，框架为我们设计好了一切，包括底层的功能代码，以及合理的目录结构，Go 语言目前来讲并没有一个类似于 Laravel 一样优秀的，可以一统江湖的 Web 全栈开发框架。

所以整个 Go 开源社区在做 Web 项目时都是选用开发者自己喜爱的结构。在早期的学习中，建议 Go 初学者多看知名项目的源码，揣摩他们的项目组织结构。

在实际 Go 项目开发中，要灵活运用，不需要太纠结于某个目录应该怎么设计。以项目的大小、业务的复杂度、个人及团队专业技能认知的广度和深度、时间的紧迫度为准。不一定要选最好的，而是要选择最适用的方案。

另外 Go 社区里也推荐阅读下这个项目 —— [golang-standards/project-layout](https://github.com/golang-standards/project-layout/blob/master/README_zh.md)。虽然此项目并非为 Web 开发量身定做，目前来讲也不算标准，但也算是 Go 社区的一次尝试，值得一读。





## 重构与测试

### 说明

开始重构代码之前，我们来想想接下来的流程：

1. 修改代码；
2. 打开浏览器，测试每一个页面是否访问正常；
3. 继续修改代码；
4. 继续重复第二个动作。

可预见的，**打开浏览器访问网页确认修改无误**，这个动作重复性高、效率低下。并且我们目前有 9 个（加上 404 页面有 10 个）页面，如果修改到公共代码的话，还需要一口气访问这些网页来确保无误。

**有没有更加合理的方式来做这件事情？**

当然有，有一个软件开发里很常见的做法 —— **写测试**。

这里的测试指的是**自动化测试**，相较之下，我们一个个打开这 10 个页面，可称为**手动测试**。

自动化测试的好处是可以在执行一个命令后，同时运行多至成百上千个测试，并且在很短的时间内执行完毕。**自动化测试**是软件健壮性的最重要的保障，一般在大公司里，核心业务都有 100% 的测试覆盖率。

### 测试的分类

测试的形式多种多样，以被测试代码的范围来区分，可分为：

1. **单元测试** —— 顾名思义，测试的最小单元，测试底层功能函数，例如你写一个数据库连接的类，类里的每一个方法都可用单元测试来保证其可用性；
2. **集成测试** —— 也称为功能测试，在 Web 开发中测试整个 Web 请求或 HTTP API 请求，会模拟 HTTP 请求到自己提供的服务器上，创建或更改数据，然后检查数据库里这些数据是否变更；
3. **黑盒测试** —— 完全模拟用户测试，把应用连带服务器看成是一个整体，模拟 HTTP 请求，对返回结果进行断言。

**单元测试**适用于测试底层函数，**集成测试** 可模拟表单提交、甚至为应用创建独有的内存数据库、可调用到内部编程接口、更改应用的驱动，功能比较齐全，但是比较难理解，代码写起来也比较复杂，这本身就是一个值得深入学习的课题，本课程不会涉及太深。

**黑盒测试** 与 **集成测试** 一样，都是站在用户角度测试整个应用提供的功能，**黑盒测试** 的好处是代码比较简单，因为模拟用户行为，对新手来讲也比较好理解，缺点就是执行效率低，且无法在代码里自动为其创建专属的**测试环境**。

> **小提示：** 一般来讲，测试环境需要与其他环境区分开，一方面是为了保证测试的准确性，另一方面也是避免污染其他环境。举例说明 —— 假如我们测试文章的创建功能，会模拟用户提交表单，创建一条文章数据，然后访问链接，断言标题是否与提交的表单数据对应上。此时数据库里会多出来一条我们的测试数据，我们称之为 **污染**。

> **小提示：** 什么是断言？断言是在代码层面上，我们用以判断获取到的结果是否符合预期，以此来判断测试是否通过。后面我们会学到具体的操作，一看就懂。

### 开始测试

#### 1. 安装工具

首先安装 [stretchr/testify](https://github.com/stretchr/testify) ，这是一个知名的第三方测试包，我们将用到他的断言（Assertion）功能。

根目录执行以下命令：

```php
$ go get github.com/stretchr/testify
```

打开 go.mod 文件，可以看到 testify 包已经被加载：

*go.mod*

```php
.
.
.
    github.com/stretchr/testify v1.8.0 // indirect
)
```

打开 go.mod 文件会发现加载了很多我们没见过的包，这是 testify 所依赖的包，本节最后我们会用 `go mod tidy` 命令进行整理。

为了方便引用，我们将修改 module 为更加简短的 `goblog`：

*go.mod*

```php
module goblog
.
.
.
```

#### 2. 测试首页

安装成功后开始编写测试，我们先测试 `/` 主页：

*tests/pages_test.go*

```php
package tests

import (
    "net/http"
    "testing"

    "github.com/stretchr/testify/assert"
)

func TestHomePage(t *testing.T) {
    baseURL := "http://localhost:3000"

    // 1. 请求 —— 模拟用户访问浏览器
    var (
        resp *http.Response
        err  error
    )
    resp, err = http.Get(baseURL + "/")

    // 2. 检测 —— 是否无错误且 200
    assert.NoError(t, err, "有错误发生，err 不为空")
    assert.Equal(t, 200, resp.StatusCode, "应返回状态码 200")
}
```

首先，本项目中的所有测试文件都将归类到 `tests` 目录下。

**后缀名 `_test` 是一个特殊标识**，会告知 Go 编译器和工具链这是一个测试文件。Go 编译器在编译时会跳过这些文件，而工具 `go test` 在执行时默认会运行当前目录下所有拥有 `_test` 后缀名的文件。

```php
var (
    resp *http.Response
    err  error
)
resp, err = http.Get(baseURL + "/")
```

`http` 是 Go 标准库里的 `net/http` 包，细心的朋友可能注意到了，它跟我们的 main.go 里用以搭建 HTTP 服务器使用的是同一个包。

**Go 的 http 包兼具 HTTP 服务器和 HTTP 客户端的功能**，HTTP 客户端支持 GET/POST/PUT 等请求方式，常用于访问网页，或者请求第三方 API 。

`http.Get()` 传参的是想要访问的 URL ，因为我们的 main.go 里监听的是本地 3000 端口：

```php
http.ListenAndServe(":3000", removeTrailingSlash(router))
```

所以这里 baseURL 我们设置的值为：

```php
baseURL := "http://localhost:3000"
```

`http.Get()` 返回的是 `*http.Response` 和 error ，如未出现错误 error 为 nil。按住 Ctrl 键（Mac 下按 Command 键）鼠标悬浮在 `*http.Response` 点击进入可查看其属性：

```php
type Response struct {
    Status     string // 响应状态，字符串，"200 OK"
    StatusCode int    // 响应状态码，200、304、404等
    Proto      string // 协议类型，字符串，"HTTP/1.1"
    ProtoMajor int    // 协议的主版本号， 1
    ProtoMinor int    // 协议的副版本号，0
    Header Header     // 响应头
    Body io.ReadCloser  // 响应的body信息
    ContentLength int64 // 响应数据包长度
    TransferEncoding []string  // 传输编码
    Request *Request  // 响应的请求信息
}
```

我们这里对响应的状态码 `resp.StatusCode` 以及错误进行断言：

```php
assert.NoError(t, err, "有错误发生，err 不为空")
assert.Equal(t, 200, resp.StatusCode, "应返回状态码 200")
```

使用 `assert.NoError()` 来断言没有错误发生。第一个 t 为 testing 标准库里的 testing.T 对象，第二个参数为错误对象 err ，第三个参数为出错时显示的信息（选填）。

`assert.Equal()` 会断言两个值相等，第一个参数同上，第二个参数是期待的状态码，第三个参数是请求返回的状态码，第四个参数为出错时显示的信息（选填）。

以下是 testify 的常用断言函数：

```php
// 相等
func Equal(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool
func NotEqual(t TestingT, expected, actual interface{}, msgAndArgs ...interface{}) bool
// 是否为 nil
func Nil(t TestingT, object interface{}, msgAndArgs ...interface{}) bool
func NotNil(t TestingT, object interface{}, msgAndArgs ...interface{}) bool
// 是否为空
func Empty(t TestingT, object interface{}, msgAndArgs ...interface{}) bool
func NotEmpty(t TestingT, object interface{}, msgAndArgs ...interface{}) bool
// 是否存在错误
func NoError(t TestingT, err error, msgAndArgs ...interface{}) bool
func Error(t TestingT, err error, msgAndArgs ...interface{}) bool
// 是否为 0 值
func Zero(t TestingT, i interface{}, msgAndArgs ...interface{}) bool
func NotZero(t TestingT, i interface{}, msgAndArgs ...interface{}) bool
// 是否为布尔值
func True(t TestingT, value bool, msgAndArgs ...interface{}) bool
func False(t TestingT, value bool, msgAndArgs ...interface{}) bool
// 断言长度一致
func Len(t TestingT, object interface{}, length int, msgAndArgs ...interface{}) bool
// 断言包含、子集、非子集
func NotContains(t TestingT, s, contains interface{}, msgAndArgs ...interface{}) bool
func Subset(t TestingT, list, subset interface{}, msgAndArgs ...interface{}) (ok bool)
func NotSubset(t TestingT, list, subset interface{}, msgAndArgs ...interface{}) (ok bool)
// 断言文件和目录存在
func FileExists(t TestingT, path string, msgAndArgs ...interface{}) bool
func DirExists(t TestingT, path string, msgAndArgs ...interface{}) bool
```

混个眼熟即可，实战中使用才能记得住。

#### 3. 执行测试

首先浏览器访问主页 [localhost:3000/](http://localhost:3000/) ，如下：

![重构前的准备 - 测试](https://img.herrluk.icu/typoraPicture/2023-02-06-16:34:21-mTsvI2.png)

因为我尚未执行 `air` 命令来运行我们的程序，所以访问会显示 `ERR_CONNECTION_REFUSED`。

> **注：** 如果你正在运行 air ，请先关闭以保持一致。

Go 的 VSCode 插件包含了测试相关的功能，打开测试文件的情况下，点击测试函数或者文件顶部的测试按钮即可完成测试：

![重构前的准备 - 测试](https://img.herrluk.icu/typoraPicture/2023-02-06-16:34:21-yNM5ak.png)

错误信息如下：

```php
--- FAIL: TestHomePage (0.00s)
    /Users/summer/Code/go/src/github.com/summerblue/goblog/tests/pages_test.go:21: 
            Error Trace:    pages_test.go:21
            Error:          Received unexpected error:
                            Get "http://localhost:3000/": dial tcp [::1]:3000: connect: connection refused
            Test:           TestHomePage
            Messages:       有错误发生，err 不为空
```

测试运行失败时，要仔细观察失败的提示信息，主要是上面这块。其中包括执行哪个文件里的某一行代码，哪一个测试，以及我们自定义的消息。

接下来切换到 `TERMINAL` 标签并运行 `air` 命令：

![重构前的准备 - 测试](https://img.herrluk.icu/typoraPicture/2023-02-06-16:34:21-t9bZzA.png)

浏览器再次访问主页 [localhost:3000/](http://localhost:3000/) ，如下：

![重构前的准备 - 测试](https://img.herrluk.icu/typoraPicture/2023-02-06-16:34:21-ZSE5aE.png)

测试一下：

![重构前的准备 - 测试](https://img.herrluk.icu/typoraPicture/2023-02-06-16:34:21-HhB3MJ.png)

至此我们完成了第一个测试。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "完成第一个测试"
```



## 表组测试

### 说明

上一节我们完成了第一个测试，接下来编写其他页面的测试代码。

### 关于页面

接下来编写关于页面的测试：

*tests/pages_test.go*

```php
.
.
.

func TestAboutPage(t *testing.T) {
    baseURL := "http://localhost:3000"

    // 1. 请求 —— 模拟用户访问浏览器
    var (
        resp *http.Response
        err  error
    )
    resp, err = http.Get(baseURL + "/about")

    // 2. 检测 —— 是否无错误且 200
    assert.NoError(t, err, "有错误发生，err 不为空")
    assert.Equal(t, 200, resp.StatusCode, "应返回状态码 200")
}
```

关于页面的测试，跟首页的测试大部分是相同的，只是函数名称和请求的 URL 不一样。

### 表组测试

Go 语言中，对于具备相同的测试逻辑的场景，我们可以使用简洁紧凑的 **表组测试（Table-Driven Test）** 来编写测试，标准库中的测试也广泛使用此种方式。

我们要定义一个用于表组测试的结构体，其中要包含测试所需的**输入与期望**的输出。

首先来看下我们在 main.go 中所有的路由：

```php
router.HandleFunc("/", homeHandler).Methods("GET").Name("home")
router.HandleFunc("/about", aboutHandler).Methods("GET").Name("about")

router.HandleFunc("/articles/{id:[0-9]+}", articlesShowHandler).Methods("GET").Name("articles.show")
router.HandleFunc("/articles", articlesIndexHandler).Methods("GET").Name("articles.index")
router.HandleFunc("/articles", articlesStoreHandler).Methods("POST").Name("articles.store")
router.HandleFunc("/articles/create", articlesCreateHandler).Methods("GET").Name("articles.create")
router.HandleFunc("/articles/{id:[0-9]+}/edit", articlesEditHandler).Methods("GET").Name("articles.edit")
router.HandleFunc("/articles/{id:[0-9]+}", articlesUpdateHandler).Methods("POST").Name("articles.update")
router.HandleFunc("/articles/{id:[0-9]+}/delete", articlesDeleteHandler).Methods("POST").Name("articles.delete")
router.NotFoundHandler = http.HandlerFunc(notFoundHandler)
```

他们的请求方法不一致，URI 不一致，还有返回的状态码不一致，这可以作为我们的基本结构体。然后所有的结构体组成一个数组，遍历这个数组，对所有元素进行请求和对结果的断言：

*tests/pages_test.go*

```php
package tests

import (
    "fmt"
    "net/http"
    "strconv"
    "testing"

    "github.com/stretchr/testify/assert"
)

func TestAllPages(t *testing.T) {

    baseURL := "http://localhost:3000"

    // 1. 声明加初始化测试数据
    var tests = []struct {
        method   string
        url      string
        expected int
    }{
        {"GET", "/", 200},
        {"GET", "/about", 200},
        {"GET", "/notfound", 404},
        {"GET", "/articles", 200},
        {"GET", "/articles/create", 200},
        {"GET", "/articles/3", 200},
        {"GET", "/articles/3/edit", 200},
        {"POST", "/articles/3", 200},
        {"POST", "/articles", 200},
        {"POST", "/articles/1/delete", 404},
    }

    // 2. 遍历所有测试
    for _, test := range tests {
        t.Logf("当前请求 URL: %v \n", test.url)
        var (
            resp *http.Response
            err  error
        )
        // 2.1 请求以获取响应
        switch {
        case test.method == "POST":
            data := make(map[string][]string)
            resp, err = http.PostForm(baseURL+test.url, data)
        default:
            resp, err = http.Get(baseURL + test.url)
        }
        // 2.2 断言
        assert.NoError(t, err, "请求 "+test.url+" 时报错")
        assert.Equal(t, test.expected, resp.StatusCode, test.url+" 应返回状态码 "+strconv.Itoa(test.expected))
    }
}
```

TestHomePage 和 TestAboutPage 已经被去除掉，换为 TestAllPages。

Struct 是我们上面提到过的三个不一样的地方：

```php
struct {
    method   string    // 请求方法
    url      string    // URI
    expected int       // 状态码
}
```

其他代码我们之前讲解过，请配合代码中的注释进行阅读。

数组里的最后三个：

```php
{"POST", "/articles/3", 200},
{"POST", "/articles", 200},
{"POST", "/articles/1/delete", 404},
```

第一个是编辑文章表单提交的链接，第二个是创建文章表单提交的链接，第三个是删除文章提交的链接。

前两个链接，模拟表单提交的话，如不提供数据，会返回 200 状态码，加上表单提示：

```php
$ curl -i -X POST http://localhost:3000/articles
```

返回：

```php
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf-8
Date: Mon, 12 Oct 2020 07:33:33 GMT
Content-Length: 497

<!DOCTYPE html>
<html lang="en">
<head>
    <title>创建文章 —— 我的技术博客</title>
    <style type="text/css">.error {color: red;}</style>
</head>
<body>
    <form action="/articles" method="post">
        <p><input type="text" name="title" value=""></p>

        <p class="error">标题不能为空</p>

        <p><textarea name="body" cols="30" rows="10"></textarea></p>

        <p class="error">内容不能为空</p>

        <p><button type="submit">提交</button></p>
    </form>
</body>
</html>%
```

删除文章如果不存在，也会返回 404，为了不污染开发环境的测试，我们只需要测试到这个链接是可以返回，且可以正常处理逻辑的即可。

### 跑一下测试

运行测试后，会显示 OK：

![表组测试](https://img.herrluk.icu/typoraPicture/2023-02-06-16:47:34-kmM05q.png)

这就是我们期待的效果，在重构代码时，如果想确保代码正常工作，就过来测试一下。

接下来我们修改下代码，测试看出现错误不一致的情况，修改这一行：

```php
{"GET", "/notfound", 404},
```

为：

```php
{"GET", "/notfound", 200},
```

再次运行测试，可以看到测试失败，以及失败后的详细信息：

![表组测试](https://img.herrluk.icu/typoraPicture/2023-02-06-16:47:34-thdJp4.png)

以下的这些输出：

```php
/Users/summer/Code/go/src/github.com/summerblue/goblog/tests/pages_test.go:36: 当前请求 URL: / 
/Users/summer/Code/go/src/github.com/summerblue/goblog/tests/pages_test.go:36: 当前请求 URL: /about 
/Users/summer/Code/go/src/github.com/summerblue/goblog/tests/pages_test.go:36: 当前请求 URL: /notfound 
.
.
```

是我们调用了标准库里的辅助方法打印出来的数据：

```php
t.Logf("当前请求 URL: %v \n", test.url)
```

当我们执行 `go test` 时，除了失败，是不会打印出来信息的，只有当我们设置了 -v 参数以后，才会显示：

![表组测试](https://img.herrluk.icu/typoraPicture/2023-02-06-16:47:34-jcDjxv.png)

以上命令中 `./tests` 是指定测试文件存放路径，`-v` 是详细打印的意思，会打印出调用的测试函数以及终端的输出。

修改回来：

```php
{"GET", "/notfound", 404},
```

再次运行：

![表组测试](https://img.herrluk.icu/typoraPicture/2023-02-06-16:47:34-0LDuCI.png)

### testing.T

上面我们使用了 `t.Logf()` 方法，Go 的标准库 testing 包提供了很多辅助方法。

通过阅读官方文档，看下 testing.T 中可导出方法如下：

```php
// 获取测试名称
method (*T) Name() string
// 打印日志
method (*T) Log(args ...interface{})
// 打印日志，支持 Printf 格式化打印
method (*T) Logf(format string, args ...interface{})
// 反馈测试失败，但不退出测试，继续执行
method (*T) Fail()
// 反馈测试失败，立刻退出测试
method (*T) FailNow()
// 反馈测试失败，打印错误
method (*T) Error(args ...interface{})
// 反馈测试失败，打印错误，支持 Printf 的格式化规则
method (*T) Errorf(format string, args ...interface{})
// 检测是否已经发生过错误
method (*T) Failed() bool
// 相当于 Error + FailNow，表示这是非常严重的错误，打印信息结束需立刻退出。
method (*T) Fatal(args ...interface{})
// 相当于 Errorf + FailNow，与 Fatal 类似，区别在于支持 Printf 格式化打印信息；
method (*T) Fatalf(format string, args ...interface{})
// 跳出测试，从调用 SkipNow 退出，如果之前有错误依然提示测试报错
method (*T) SkipNow()
// 相当于 Log 和 SkipNow 的组合
method (*T) Skip(args ...interface{})
// 与Skip，相当于 Logf 和 SkipNow 的组合，区别在于支持 Printf 格式化打印
method (*T) Skipf(format string, args ...interface{})
// 用于标记调用函数为 helper 函数，打印文件信息或日志，不会追溯该函数。
method (*T) Helper()
// 标记测试函数可并行执行，这个并行执行仅仅指的是与其他测试函数并行，相同测试不会并行。
method (*T) Parallel()
// 可用于执行子测试
method (*T) Run(name string, f func(t *T)) bool
```

同样的，混个脸熟即可。

### 测试与重构

就如软件大师 [Kent Beck](https://baike.baidu.com/item/Kent Beck/13006051?fr=aladdin) 在《重构 Refactoring》一书中描述的：

- 先让代码工作起来 —— 如果代码不能工作，就不能产生价值
- 然后再试图将它变好 —— 通过对代码进行重构，让我们自己和其他人更好地理解代码，并能按照需求不断地修改代码。
- 最后再试着让它运行得更快 —— 按照性能提升的需求来重构代码。

有了测试作为铺垫，可以放心地重构我们的项目了。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "完成代码测试"
```



## 开始重构

### 说明

本节我们开始来重构，像我们这种要大刀阔斧修改整个项目的代码组织时，最好是先从底层的代码先入手。

所谓底层代码，就是被依赖的代码。例如辅助方法、公用方法等。

在我们的 main.go 中：

- RouteName2URL
- Int64ToString
- getRouteVariable
- initDB
- checkError

等，可以从这些代码开始重构。

### 路由包 route

我们先来抽离 RouteName2URL 函数：

*pkg/route/router.go*

```php
package route

// RouteName2URL 通过路由名称来获取 URL
func RouteName2URL(routeName string, pairs ...string) string {
    url, err := Router.Get(routeName).URL(pairs...)
    if err != nil {
        // checkError(err)
        return ""
    }

    return url.String()
}
```

VSCode 里可以看到 RouteName2URL 和 Router 会出现下划线，鼠标放上去可以看到错误提示：

![开始重构](https://img.herrluk.icu/typoraPicture/2023-02-06-17:16:32-0qWpz0.png)

如果你仔细看，会发现下划线的颜色不一样，RouteName2URL 是黄色的下划线，表示提示、建议：

```php
func name will be used as route.RouteName2URL by other packages, and that stutters; consider calling this Name2URL
```

这个插件很智能地建议我们将函数命名为 Name2URL ，这样别人调用的时候是 `route.Name2URL` 这样会更加顺口。

Router 下划线的颜色是红色，表示错误提示：

```php
undefined: Router
```

Router 未定义，因为我们是在 main.go 的最顶部定义了包范围的变量 Router，而在包 route 里我们无法使用此变量。

接下来我们尝试解决这些问题：

*pkg/route/router.go*

```php
package route

import "github.com/gorilla/mux"

// Router 路由对象
var Router *mux.Router

// Initialize 初始化路由
func Initialize() {
    Router = mux.NewRouter()
}

// Name2URL 通过路由名称来获取 URL
func Name2URL(routeName string, pairs ...string) string {
    url, err := Router.Get(routeName).URL(pairs...)
    if err != nil {
        // checkError(err)
        return ""
    }

    return url.String()
}
```

我们将 Router 挪过来，且新增了 `Initialize()` 函数，用以做一些路由初始化相关的事情。

`checkError(err)` 调用我们后面再想办法来解决，目前先注释掉。

接下来修改 main.go ，需要做以下几件事情：

- 将 `RouteName2URL` 函数的定义移除
- 使用 `route.Name2URL` 来代替 `RouteName2URL`
- 去除顶部的 router 初始化，改用 `route.Router`

*main.go*

```php
package main

import (
    .
    .
    .
)

var router *mux.Router
var db *sql.DB
.
.
.

func  articlesShowHandler(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    if err !=  nil {
        .
        .
        .
    } else {
        // 4. 读取成功，显示文章
        tmpl, err := template.New("show.gohtml").
            Funcs(template.FuncMap{
                "RouteName2URL": route.Name2URL,
                "Int64ToString": Int64ToString,
            }).
            ParseFiles("resources/views/articles/show.gohtml")
        .
        .
        .
    }
}
.
.
.
func  main() {
    initDB()
    createTables()

    route.Initialize()
    router = route.Router
    .
    .
    .
}
```

### 运行测试

修改完成后，运行测试检测一下：

![开始重构](https://img.herrluk.icu/typoraPicture/2023-02-06-17:16:32-7uoEOF.png)

测试通过，我们先将修改的代码做下版本标记：

```php
$ git add .
$ git commit -m "重构 RouteName2URL"
```

### 重构 getRouteVariable

将 getRouteVariable 挪到我们的 route 包里，且作为可导出的函数，首字母要大写：

*pkg/route/router.go*

```php
.
.
.
// GetRouteVariable 获取 URI 路由参数
func GetRouteVariable(parameterName string, r *http.Request) string {
    vars := mux.Vars(r)
    return vars[parameterName]
}
```

接下来删除 main.go 中的 getRouteVariable 函数定义，并更改调用为 `route.GetRouteVariable()`。

在 VSCode 中，按住 Ctrl+f （Mac 下按 Command + f），查找关键词 `getRouteVariable` ，将所有出现的地方替换为 `route.GetRouteVariable`:

![开始重构](https://img.herrluk.icu/typoraPicture/2023-02-06-17:16:32-EcvjsV.png)

修改完成后保存，并打开 tests/pages_test.go ，运行测试。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "重构 GetRouteVariable"
```

## 数据库初始化

### 说明

这一节我们来重构数据库初始化相关的代码。

### initDB 和 createTables

接下来我们新建 database 包，并把初始化的两个函数放进去：

*pkg/database/database.go*

```php
package database

import (
    "database/sql"
    "goblog/pkg/logger"
    "time"

    "github.com/go-sql-driver/mysql"
)

func initDB() {

    var err error

    // 设置数据库连接信息
    config := mysql.Config{
        User:                 "homestead",
        Passwd:               "secret",
        Addr:                 "127.0.0.1:33060",
        Net:                  "tcp",
        DBName:               "goblog",
        AllowNativePasswords: true,
    }

    // 准备数据库连接池
    db, err = sql.Open("mysql", config.FormatDSN())
    logger.LogError(err)

    // 设置最大连接数
    db.SetMaxOpenConns(100)
    // 设置最大空闲连接数
    db.SetMaxIdleConns(25)
    // 设置每个链接的过期时间
    db.SetConnMaxLifetime(5 * time.Minute)

    // 尝试连接，失败会报错
    err = db.Ping()
    logger.LogError(err)
}

func createTables() {
    createArticlesSQL := `CREATE TABLE IF NOT EXISTS articles(
    id bigint(20) PRIMARY KEY AUTO_INCREMENT NOT NULL,
    title varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
    body longtext COLLATE utf8mb4_unicode_ci
); `

    _, err := db.Exec(createArticlesSQL)
    logger.LogError(err)
}
```

打开 VSCode 的 `PROBLEMS` 错误信息显示框里，可以看到提示 `undefined: db`：

![重构数据库](https://img.herrluk.icu/typoraPicture/2023-02-06-20:24:46-fP472k.png)

我们在重构 route 包时遇到相同的问题，接下来使用同样的方法来解决。

修改后如下：

*pkg/database/database.go*

```php
package database

import (
    "database/sql"
    "goblog/pkg/logger"
    "time"

    "github.com/go-sql-driver/mysql"
)

// DB 数据库对象
var DB *sql.DB

// Initialize 初始化数据库
func Initialize() {
    initDB()
    createTables()
}

func initDB() {

    var err error

    // 设置数据库连接信息
    config := mysql.Config{
        User:                 "root",
        Passwd:               "secret",
        Addr:                 "127.0.0.1:3306",
        Net:                  "tcp",
        DBName:               "goblog",
        AllowNativePasswords: true,
    }

    // 准备数据库连接池
    DB, err = sql.Open("mysql", config.FormatDSN())
    logger.LogError(err)

    // 设置最大连接数
    DB.SetMaxOpenConns(100)
    // 设置最大空闲连接数
    DB.SetMaxIdleConns(25)
    // 设置每个链接的过期时间
    DB.SetConnMaxLifetime(5 * time.Minute)

    // 尝试连接，失败会报错
    err = DB.Ping()
    logger.LogError(err)
}

func createTables() {
    createArticlesSQL := `CREATE TABLE IF NOT EXISTS articles(
    id bigint(20) PRIMARY KEY AUTO_INCREMENT NOT NULL,
    title varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
    body longtext COLLATE utf8mb4_unicode_ci
); `

    _, err := DB.Exec(createArticlesSQL)
    logger.LogError(err)
}
```

注意 DB 对象和 `Initialize()` 函数我们要对外开放，让 main.go 里可以直接调用，所以必须使用首字母大写的方式。

首先在 main.go 里删除掉 `initDB()` 和 `createTables()` 两个函数的定义及其调用。

然后修改 main 函数，新增调用：

*main.go*

```php
.
.
.
func main() {

    database.Initialize()
    db = database.DB

    route.Initialize()
    router = route.Router
    .
    .
    .
}
```

main 包里的 db 和 router 只是一个过渡，后面我们将代码挪出 main 包以后，这两个变量将会被删除。

修改以后打开 tests/pages_test.go 文件，运行测试，可以看到测试通过：

![重构数据库](https://img.herrluk.icu/typoraPicture/2023-02-06-20:24:46-P9lD03.png)

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "重构  initDB 和 createTables"
```

# 8. 重构为 MVC

## 路由和控制器

### 说明

从这一节开始，我们要将业务代码从 main.go 中移走。

本小节我们从首页、关于和 404 页面开始，因为这三个页面都是静态页面，比较简单。

### 路由文件

我们会将 main.go 里的路由信息，一点点挪到我们将要新建的 `routes/web.go` 路由文件中：

*routes/web.go*

```php
package routes

import (
    "net/http"

    "github.com/gorilla/mux"
)

// RegisterWebRoutes 注册网页相关路由
func RegisterWebRoutes(r *mux.Router) {

    // 静态页面
    r.HandleFunc("/", homeHandler).Methods("GET").Name("home")
    r.HandleFunc("/about", aboutHandler).Methods("GET").Name("about")
    r.NotFoundHandler = http.HandlerFunc(notFoundHandler)
}
```

路由文件 routes/web.go 的存放位置非常直观，当你想要修改路由时候，第一时间会想到这里。我们现在的 routes 包里只有 `RegisterWebRoutes()`，后面项目发展中如果需要 API 相关路由，我们可创建 `RegisterAPIRoutes()` 函数，并放置于 routes/api.go 文件中。

当前 VSCode 会有错误提示 `homeHandler` 未定义，这是因为函数作用域问题， main 包定义的 homeHandler 等控制器方法，我们无法读到。

### 注册路由

我们会将上面三个 Handler 放到统一的专门处理静态页面的控制器中，在那之前，我们先来将注册路由先：

*pkg/route/router.go*

```php
.
.
.
// Initialize 初始化路由
func Initialize() {
    Router = mux.NewRouter()
    routes.RegisterWebRoutes(Router)
}
.
.
.
```

需要注意的是，我们的 `Initialize()` 方法已经在 main 包里调用。

### 控制器 pages_controller

如上文提到的，我们会使用 `PagesController` 来处理所有静态页面。接下来创建文件，并将 `homeHandler` 、`aboutHandler` 和 `notFoundHandler` 挪到此文件中：

*app/http/controllers/pages_controller.go*

```php
package controllers

import (
    "fmt"
    "net/http"
)

// PagesController 处理静态页面
type PagesController struct {
}

// Home 首页
func (*PagesController) Home(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "<h1>Hello, 欢迎来到 goblog！</h1>")
}

// About 关于我们页面
func (*PagesController) About(w http.ResponseWriter, r *http.Request) {
    fmt.Fprint(w, "此博客是用以记录编程笔记，如您有反馈或建议，请联系 "+
        "<a href=\"mailto:summer@example.com\">summer@example.com</a>")
}

// NotFound 404 页面
func (*PagesController) NotFound(w http.ResponseWriter, r *http.Request) {
    w.WriteHeader(http.StatusNotFound)
    fmt.Fprint(w, "<h1>请求页面未找到 :(</h1><p>如有疑惑，请联系我们。</p>")
}
```

#### app 目录

关于文件的存放位置 `app/http/controllers`，我们一下子创建了三层目录，这个目录结构参考了知名的 Web 开发框架 Laravel ，不熟悉 Laravel 的朋友，这里大致讲解下这三层目录分别的作用是：

- `app` 目录存放业务逻辑相关的代码，子目录还会有 models 等目录，相对于 pkg 目录存放底层代码来讲，不同的项目，这个 app 目录下的代码会有很大差异。
- `app/http` 目录存放 controllers 、requests（表单验证）、middlewares 等跟处理 HTTP 请求相关的代码；
- `app/http/controllers` 目录存放着处理 HTTP 请求的控制器，每一个控制器文件里包含多个方法，这些方法是最终处理用户请求并返回响应的地方。

#### 下划线命名 pages_controller.go

Go 中关于文件命名规则官方没有具体的说明，所以有过很多争论。不过 Go 标准库和第三方库大部分采用了下划线分隔法，因此这里我们推荐**小写＋下划线分割**。（相关讨论请见 [doc: filename conventions](https://github.com/golang/go/issues/36060)）

#### 类方法

请注意这里应用到了 Go 的类方法写法，方便我们在同一个包 `controllers` 下面，对函数进行归类。以上代码可以理解为 Home/About/NotFound 方法都是属于 PagesController 的。

### 注册控制器

有了 PagesController，接下来矫正 `RegisterWebRoutes()` 中的报错：

*routes/web.go*

```php
.
.
.
// RegisterWebRoutes 注册网页相关路由
func RegisterWebRoutes(r *mux.Router) {

    // 静态页面
    pc := new(controllers.PagesController)
    r.NotFoundHandler = http.HandlerFunc(pc.NotFound)
    r.HandleFunc("/", pc.Home).Methods("GET").Name("home")
    r.HandleFunc("/about", pc.About).Methods("GET").Name("about")
}
```

实例化 `controllers.PagesController` 后，将对应的方法指定到对应路由上，搞定。

使用了控制器的方法名，更加简短，读起来也更加顺口。

### 删除路由

请进入 main.go 的 main 方法中，将以下几个多余的路由删除：

```php
router.HandleFunc("/", homeHandler).Methods("GET").Name("home")
router.HandleFunc("/about", aboutHandler).Methods("GET").Name("about")

// 自定义 404 页面
router.NotFoundHandler = http.HandlerFunc(notFoundHandler)
```

删除成功后请保存修改。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "重构至 PagesController"
```

## 循环引用

### 说明

上节我们在重构几个静态页面时，也构建了我们的 MVC 雏形 —— 控制器加路由。

这一节开始，我们将接触模型和视图。

我们会先从 `articles.show` 开始，慢慢将 main.go 里的控制器逻辑移到专属的文章控制器中。

### 注册路由

前往我们的专属路由文件里注册路由：

*routes/web.go*

```php
.
.
.
func  RegisterWebRoutes(r *mux.Router) {
    .
    .
    .

    // 文章相关页面
    ac := new(controllers.ArticlesController)
    r.HandleFunc("/articles/{id:[0-9]+}", ac.Show).Methods("GET").Name("articles.show")
}
```

随后请前往 main.go 文件中，将我们已不再需要的代码删除：

```php
router.HandleFunc("/articles/{id:[0-9]+}", articlesShowHandler).Methods("GET").Name("articles.show")
```

### ArticlesController 控制器

ArticlesController 还不存在，接下来新建此文件和 `Show` 方法：

*app/http/controllers/articles_controller.go*

```php
package controllers

import (
    "net/http"
)

// ArticlesController 文章相关页面
type ArticlesController struct {
}

// Show 文章详情页面
func (*ArticlesController) Show(w http.ResponseWriter, r *http.Request) {

}
```

架子搭好了，进入 main.go 里，找到 `articlesShowHandler` 将内容复制到刚刚创建的 `Show` 方法中：

*app/http/controllers/articles_controller.go*

```php
.
.
.
func (*ArticlesController) Show(w http.ResponseWriter, r *http.Request) {
    // 1. 获取 URL 参数
    id := route.GetRouteVariable("id", r)

    // 2. 读取对应的文章数据
    article, err := getArticleByID(id)

    // 3. 如果出现错误
    if err != nil {
        if err == sql.ErrNoRows {
            // 3.1 数据未找到
            w.WriteHeader(http.StatusNotFound)
            fmt.Fprint(w, "404 文章未找到")
        } else {
            // 3.2 数据库错误
            logger.LogError(err)
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "500 服务器内部错误")
        }
    } else {
        // 4. 读取成功，显示文章
        tmpl, err := template.New("show.gohtml").
            Funcs(template.FuncMap{
                "RouteName2URL": route.Name2URL,
                "Int64ToString": types.Int64ToString,
            }).
            ParseFiles("resources/views/articles/show.gohtml")
        logger.LogError(err)
        err = tmpl.Execute(w, article)
        logger.LogError(err)
    }
}
```

> **注：**黏贴的同时，请将 main.go 里的 `articlesShowHandler` 函数删除，我们已经不再需要此函数了。

### import cycle not allowed 循环导入问题

保存文件时，我们可以看到命令行里会有错误提示：

![数据模型 GORM](https://img.herrluk.icu/typoraPicture/2023-02-07-15:01:30-E6Zxhl.png)

关注这块内容：

```php
package goblog
        imports goblog/pkg/route
        imports goblog/routes
        imports goblog/app/http/controllers
        imports goblog/pkg/route: import cycle not allowed
failed to build, error: exit status 1
```

**循环导入**是 Go 语言中常见的一个报错。

分解下问题 —— 在我们的 goblog 项目中导入依赖是这样的：

1. main 包里面引入 goblog/pkg/route ，调用 route.Initialize 进行路由初始化；
2. goblog/pkg/route 里 Initialize 函数加载了 goblog/routes 注册路由 `routes.RegisterWebRoutes(Router)`；
3. goblog/routes 包里加载了控制器的包 goblog/app/http/controllers
4. 控制器包里再次使用了路由工具包 goblog/pkg/route **！！出现循环引用问题了！！**

Go 编译器不允许这样做是出于编译性能考虑。允许循环引用会使**编译时间激增**，一旦某个包更新，整个依赖循环都需要重新编译。

解决方法很简单，我们重新组织下代码即可，保持自上而下的依赖关系。目前我们的 goblog/pkg/route 里面做了两件事情：

1. 路由初始化 —— 注册路由
2. 提供路由相关的工具方法

路由初始化更加贴近我们的业务逻辑，可以抽出来放到专门负责初始化的包里，并将 pkg/route 从最顶级的 main 包里移除。这样 pkg/route 只存放路由相关工具方法，供控制器调用。

### 路由初始化

新建 bootstrap 包，这个包将用来存放程序初始化相关逻辑，例如路由初始化、数据库初始化、配置信息初始化等。

新建以下文件：

*bootstrap/route.go*

```php
package bootstrap

import (
    "goblog/routes"

    "github.com/gorilla/mux"
)

// SetupRoute 路由初始化
func SetupRoute() *mux.Router {
    router := mux.NewRouter()
    routes.RegisterWebRoutes(router)
    return router
}
```

接下来修改 main.go，将以下两行：

```php
route.Initialize()
router = route.Router
```

替换为：

```php
router = bootstrap.SetupRoute()
```

接下来修改 pkg 里的 route 包，将初始化的代码删除，只保留两个工具函数：

*pkg/route/router.go*

```php
package route

import (
    "net/http"

    "github.com/gorilla/mux"
)

// Name2URL 通过路由名称来获取 URL
func Name2URL(routeName string, pairs ...string) string {
    var route *mux.Router
    url, err := route.Get(routeName).URL(pairs...)
    if err != nil {
        // checkError(err)
        return ""
    }

    return url.String()
}

// GetRouteVariable 获取 URI 路由参数
func GetRouteVariable(parameterName string, r *http.Request) string {
    vars := mux.Vars(r)
    return vars[parameterName]
}
```

保存文件后， air 自动编译还是会出现循环引用错误，这是因为我们的 main 包里仍然在使用 `route.GetRouteVariable()` 函数。

打开 main.go 文件，你可以看到所有调用 `route.GetRouteVariable()` 的地方都是 Handler，这些 Handler 将会一个个被我们重构到专属的控制器里，然而目前来讲，为了保持 **最小化修改** 这个重构的最佳实践，我们可以先使用折中方案 —— 将 `GetRouteVariable()` 方法重新移回 main.go 中，并将这个本地的方法替换掉 `route.GetRouteVariable()` 的调用。

具体操作如下。

main.go 里新增 `getRouteVariable()` 方法，因为不需要导出，函数名首字母小写：

*main.go*

```php
.
.
.
func getRouteVariable(parameterName string, r *http.Request) string {
    vars := mux.Vars(r)
    return vars[parameterName]
}

func main() {
    .
    .
    .
}
```

接下来是在 main.go 文件中查找关键词 `route.GetRouteVariable`，并将所有出现的地方替换为 `getRouteVariable` ，修改完成后保存文件。

可以看到 air 自动编译报了另一个错误，这很好，说明我们已经解决了循环引用的问题：

![数据模型 GORM](https://img.herrluk.icu/typoraPicture/2023-02-07-15:01:30-NdPlPw.png)

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "解决循环引用问题"
```

## 集成 GORM

### 说明

本节我们将一起来看下如何在项目中集成 GORM 。

### GORM

在接下来的开发中，我们将会在项目中集成 [GORM](https://github.com/go-gorm/gorm) （ [《GORM 中文文档》](https://learnku.com/docs/gorm/v2) ） 。GORM 取名自 Go ORM，是 Go 生态圈里最知名的 ORM 方案。

#### 什么是 ORM ？

ORM 全称是：Object Relational Mapping (对象关系映射)，其主要作用是在编程中，把面向对象的概念跟数据库中表的概念对应起来。举例来说就是，我定义一个对象（结构体），那就对应着一张表，这个对象的实例，就对应着表中的一条记录。

#### 为什么要使用 GORM？

本项目使用 GORM 的理由：

1. 现代化，面对对象
2. 多数据库支持，为高负载做好准备
3. 提高项目安全性
4. 提升开发效率和项目的可维护性

我们都知道，在正式环境中直接使用 SQL 来查询数据库是很危险的，处理不好就有被注入式攻击的风险。而且组装 SQL 语句也容易出错和减低代码的可维护性。所以需要一个工具来管理数据库语句的组装和操作。

GORM 是目前比较成熟的 Go 语言数据库管理库，它可以很方便的把 Go 的结构体和数据库表绑定，从而简化获取数据的操作。

GORM 功能包括下面：

- 全功能 ORM
- 关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)
- Create，Save，Update，Delete，Find 中钩子方法
- 支持 `Preload`、`Joins` 的预加载
- 事务，嵌套事务，Save Point，Rollback To Saved Point
- Context，预编译模式，DryRun 模式
- 批量插入，FindInBatches，Find/Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD
- SQL 构建器，Upsert，数据库锁，Optimizer/Index/Comment Hint，命名参数，子查询
- 复合主键，索引，约束
- Auto Migration
- 自定义 Logger
- 灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…
- 每个特性都经过了测试的重重考验
- 开发者友好

以上列表熟悉下即可，后面的项目开发中使用到自然就会记住了，脱离实战记忆没有意义。

### 如何在项目中使用 GORM?

GORM 中既包含了高级的接口，同时也支持原生 SQL 的执行，这足以应付大部分的 Web 开发场景。所以我们将弃用 database/sql 只选用 GORM 就够了。

先来规划一下，使用 GORM 需要哪些元素。

**初始化** ： 首先我们需要在 bootstrap 目录下新建一个文件来负责数据库的初始化，连接池配置等信息。与路由初始化类似，我们会在 main.go 中对数据库初始化的函数进行调用。

**模型文件**：模型文件里会有两部分的代码，一部分是迎合 GORM 逻辑的定制的配置信息（字段定制、关联关系、钩子等），一部分是项目内部调用的接口，例如根据 ID 获取文章我们可以这样调用 `article.Get(2)`。

以 article 模型为例，创建 app/models/article/article.go 来放置模型配置信息，创建 app/models/article/crud.go 来放置负责数据库操作的方法。

**基础模型**：目前我们只有 article 模型，后面还会有 user 模型和 comment 模型，因此需要有一个基础模型来放置共享的模型配置信息。

此外，一般我们会使用 `gorm.Open()` 来创建一个 `gorm.DB` 连接池对象，并存储在变量中，这个变量我们需要保存起来在整个项目范围内可用，基础模型也可以用以存放此变量。存放路径 pkg/model/model.go 。

### 安装 GORM

首先安装 GORM:

```php
$ go get -u gorm.io/gorm
```

在安装 GORM 的同时，我们还需要安装 GORM 的 MySQL 的数据库驱动

```php
$ go get -u gorm.io/driver/mysql
```

### 创建基础模型

*pkg/model/model.go*

```php
package model

import (
    "goblog/pkg/logger"

    "gorm.io/gorm"

    // GORM 的 MySQL 数据库驱动导入
    "gorm.io/driver/mysql"
)

// DB gorm.DB 对象
var DB *gorm.DB

// ConnectDB 初始化模型
func ConnectDB() *gorm.DB {

    var err error

    config := mysql.New(mysql.Config{
        DSN: "root:secret@tcp(127.0.0.1:3306)/goblog?charset=utf8&parseTime=True&loc=Local",
    })

    // 准备数据库连接池
    DB, err = gorm.Open(config, &gorm.Config{})

    logger.LogError(err)

    return DB
}
```

DSN 信息与我们在 pkg/database/database.go 里的 mysql.Config 调用类似：

```php
config := mysql.Config{
    User:                 "root",
    Passwd:               "secret",
    Addr:                 "127.0.0.1:3306",
    Net:                  "tcp",
    DBName:               "goblog",
    AllowNativePasswords: true,
}
```

DB 变量是一个 `*gorm.DB` 对象，我们会在模型文件中大量使用到。`ConnectDB()` 方法，将会在数据库初始化中使用。

### 数据库初始化

数据库初始化的逻辑我们将放到 bootstrap 包里：

*bootstrap/db.go*

```php
package bootstrap

import (
    "goblog/pkg/model"
    "time"
)

// SetupDB 初始化数据库和 ORM
func SetupDB() {

    // 建立数据库连接池
    db := model.ConnectDB()

    // 命令行打印数据库请求的信息
    sqlDB, _ := db.DB()

    // 设置最大连接数
    sqlDB.SetMaxOpenConns(100)
    // 设置最大空闲连接数
    sqlDB.SetMaxIdleConns(25)
    // 设置每个链接的过期时间
    sqlDB.SetConnMaxLifetime(5 * time.Minute)
}
```

`*gorm.DB` 对象有一个方法 `DB()` 可以直接获取到 database/sql 包里的 `*sql.DB` 对象。

从上面代码不难看出，**GORM 底层也是使用 database/sql 来管理连接池**。三个连接池的设置方法之前我们已经讲过，这里不再赘述。

接下来在 main.go 中调用进行初始化：

*main.go*

```php
.
.
.
func main() {

    database.Initialize()
    db = database.DB

    bootstrap.SetupDB()
    router = bootstrap.SetupRoute()
    .
    .
    .
}
```

database/sql 部分的初始化代码，为了保持持续程序的正常工作，暂时保留着。原则是一点点进行重构，而不是一口气修改一大堆代码而破坏系统的正常运行，在重构任何系统时这都是一个很重要的原则。

### go mod tidy

因为本节课我们引入了新的依赖，为了保证 go.mod 文件的整洁，在提交代码之前运行 `go mod tidy` 命令：

```php
$ go mod tidy
```

查看 go.mod 文件，可以看到 require 指令被分为两个区块，第一个区块是我们直接依赖，第二区块是间接依赖（后面跟着 `// indirect` 注释）：

*go.mod*

```php
module goblog

go 1.17

require (
    github.com/go-sql-driver/mysql v1.6.0
    github.com/gorilla/mux  v1.8.0
    .
    .
    ,
)

require (
    github.com/davecgh/go-spew v1.1.1 // indirect
    github.com/fsnotify/fsnotify v1.5.1 // indirect
    .
    .
    .
)
```

**提示：** 保持 go.mod 文件的整洁是很有必要的。当其他团队成员来查看我们项目，或者多年你以后你查看自己的项目，打开 go.mod 文件一眼扫过去就知道依赖了哪些项目。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "集成 GORM"
```

## article模型

### 说明

本节我们来解决命令行里 air 自动编译项目 `undefined: getArticleByID` 的报错。

### 新建模型

`getArticleByID()` 是我们在 main.go 中创建的函数，用以获取 ID 对应的文章。

接下来我们使用 GORM 来实现相同的功能，首先创建 Article 模型文件：

*app/models/article/article.go*

```php
package article

// Article 文章模型
type Article struct {
    ID    uint64 
    Title string
    Body  string
}
```

注意我们将 ID 从 int64 修改为 uint64 ，因为数据库的 ID 为大于 0 的自增整数，所以我们使用更加合适的 uint64 来设定。

下面简单介绍下 Go 里面的整型。

整型分为以下两个大类： 按长度分为：int8、int16、int32、int64 对应的无符号整型：uint8、uint16、uint32、uint64。

**Go 整数具体数值区间如下**：

| 类型   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| uint8  | 无符号 8 位整型 (0 到 255)                                   |
| uint16 | 无符号 16 位整型 (0 到 65535)                                |
| uint32 | 无符号 32 位整型 (0 到 4294967295)                           |
| uint64 | 无符号 64 位整型 (0 到 18446744073709551615)                 |
| int8   | 有符号 8 位整型 (-128 到 127)                                |
| int16  | 有符号 16 位整型 (-32768 到 32767)                           |
| int32  | 有符号 32 位整型 (-2147483648 到 2147483647)                 |
| int64  | 有符号 64 位整型 (-9223372036854775808 到 9223372036854775807) |
| int    | 根据宿主机的机器字长决定，32 位的机器就是 int32，64 位就是 int64 |
| uint   | 根据宿主机的机器字长决定，32 位的机器就是 uint32，64 位就是 uint64 |

由于 Go 语言中各 int 类型的取值范围不同，各 int 类型间进行转换时会出现截断问题，使用时请谨慎。

接下来创建获取文章的方法：

*app/models/article/crud.go*

```php
package article

import (
    "goblog/pkg/model"
    "goblog/pkg/types"
)

// Get 通过 ID 获取文章
func Get(idstr string) (Article, error) {
    var article Article
    id := types.StringToUint64(idstr)
    if err := model.DB.First(&article, id).Error; err != nil {
        return article, err
    }

    return article, nil
}
```

`First()` 是 gorm.DB 提供的用以从结果集中获取第一条数据的查询方法，需要注意的是第二个参数可以传参整型或者字符串 ID，但是传字符串会有 SQL 注入的风险，所以安全起见，我们使用 `StringToUint64` 做类型转换。

`.Error` 是 GORM 的错误处理机制。与常见的 Go 代码不同，因 GORM 提供的是链式 API，如果遇到任何错误，GORM 会设置 `*gorm.DB` 的 Error 字段，您需要像这样检查它。

在 GORM 中，当 `First`、`Last`、`Take` 方法找不到记录时，GORM 会返回 `ErrRecordNotFound` 错误。

`types.StringToUint64()` 是需要我们新增的函数：

*pkg/types/converter.go*

```php
.
.
.

// StringToUint64 将字符串转换为 uint64
func StringToUint64(str string) uint64 {
    i, err := strconv.ParseUint(str, 10, 64)
    if err != nil {
        logger.LogError(err)
    }
    return i
}
```

StringToUint64 将字符串转换为 uint64 类型，且内部做好了错误处理。

接下来是修改控制器的调用：

*app/http/controllers/articles_controller.go*

```php
.
.
.

// Show 文章详情页面
func (*ArticlesController) Show(w http.ResponseWriter, r *http.Request) {

    .
    .
    .

    // 2. 读取对应的文章数据
    article, err := article.Get(id)

    .
    .
    .
}
```

修改后浏览器里刷新 [localhost:3000/articles/3](http://localhost:3000/articles/3) 页面，页面无法展示。

#### invalid memory address or nil pointer dereference

命令行可以看见 air 的报错信息：

```php
$ air 
.
.
.
2022/08/17 08:44:14 template: show.gohtml:20:21: executing "show.gohtml" at <RouteName2URL "articles.delete" "id" $idString>: error calling RouteName2URL: runtime error: invalid memory address or nil pointer dereference
```

RouteName2URL 用的是 `route.Name2URL()` 方法，我来看下此方法：

```php
// Name2URL 通过路由名称来获取 URL
func Name2URL(routeName string, pairs ...string) string {
    var route *mux.Router
    url, err := route.Get(routeName).URL(pairs...)
    if err != nil {
        // checkError(err)
        return ""
    }

    return url.String()
}
```

问题出在 `route` 变量上，我们只声明，没有初始化。这个变量的值，应该与 `bootstrap.SetupRoute()` 里的 router 变量一致。

我们需要有一套机制来将 `bootstrap.SetupRoute()` 里的 router 变量传给 route.Name2URL 。

重构 route 包：

*pkg/route/router.go*

```php
package route

import (
    "goblog/pkg/logger"
    "net/http"

    "github.com/gorilla/mux"
)

var route *mux.Router

// SetRoute 设置路由实例，以供 Name2URL 等函数使用
func SetRoute(r *mux.Router) {
    route = r
}

// Name2URL 通过路由名称来获取 URL
func Name2URL(routeName string, pairs ...string) string {
    url, err := route.Get(routeName).URL(pairs...)
    if err != nil {
        logger.LogError(err)
        return ""
    }

    return url.String()
}
.
.
.
```

这样的话就可以通过 `SetRoute` 来传参对象变量了：

*bootstrap/route.go*

```php
.
.
.
// SetupRoute 路由初始化
func SetupRoute() *mux.Router {
    router := mux.NewRouter()
    routes.RegisterWebRoutes(router)

    route.SetRoute(router)

    return router
}
```

浏览器打开 [localhost:3000/articles/3](http://localhost:3000/articles/3) ，页面仍然无法访问。

#### wrong type for value; expected int64; got uint64

查看命令行 air 命令的输出：

```php
$ air
.
.
.
2022/08/17 08:53:35 template: show.gohtml:19:34: executing "show.gohtml" at <.ID>: wrong type for value; expected int64; got uint64
```

查看 show.gohtml 代码：

```php
{{/* 构建删除按钮  */}}
{{ $idString := Int64ToString .ID  }}
<form action="{{ RouteName2URL "articles.delete" "id" $idString }}" method="post">
    <button type="submit" onclick="return confirm('删除动作不可逆，请确定是否继续')">删除</button>
</form>
```

可以看到这一行 `$idString := Int64ToString .ID` 出了问题，因为上面我们将 ID 从 int64 改为 uint64 ，这里需要一并修改。

新增方法：

*pkg/types/converter.go*

```php
.
.
.

// Uint64ToString 将 uint64 转换为 string
func Uint64ToString(num uint64) string {
    return strconv.FormatUint(num, 10)
}
```

控制器将 Int64ToString 改为 Uint64ToString：

*app/http/controllers/articles_controller.go*

```php
.
.
.
// Show 文章详情页面
func (*ArticlesController) Show(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    } else {
        // 4. 读取成功，显示文章
        tmpl, err := template.New("show.gohtml").
            Funcs(template.FuncMap{
                "RouteName2URL":  route.Name2URL,
                "Uint64ToString": types.Uint64ToString,
            }).
```

模板里同样修改 Int64ToString 为 Uint64ToString：

*resources/views/articles/show.gohtml*

```php
    {{/* 构建删除按钮  */}}
    {{ $idString := Uint64ToString .ID  }}
    <form action="{{ RouteName2URL "articles.delete" "id" $idString }}" method="post">
        <button type="submit" onclick="return confirm('删除动作不可逆，请确定是否继续')">删除</button>
    </form>
```

再次刷新 [localhost:3000/articles/3](http://localhost:3000/articles/3) ，即可看到删除按钮：

![Article 模型](https://img.herrluk.icu/typoraPicture/2023-02-07-15:10:08-fqzl4B.png)

问题解决。

### 文章不存在的情况

试试访问不存在的文章 [localhost:3000/articles/1000](http://localhost:3000/articles/1000) ，可见：

![Article 模型](https://img.herrluk.icu/typoraPicture/2023-02-07-15:10:08-voncpl.png)

查看命令行输出：

![Article 模型](https://img.herrluk.icu/typoraPicture/2023-02-07-15:10:08-4Ism59.png)

> record not found

数据不存在，以下代码：

```php
if err != nil {
    if err == sql.ErrNoRows {
        // 3.1 数据未找到
        w.WriteHeader(http.StatusNotFound)
        fmt.Fprint(w, "404 文章未找到")
    } else {
        // 3.2 数据库错误
        logger.LogError(err)
        w.WriteHeader(http.StatusInternalServerError)
        fmt.Fprint(w, "500 服务器内部错误")
    }
}
```

看来是走了 3.2 的情况，按下 Ctrl （Mac 下按 Command 键）+ 点击 `LogError` 进入名称，进入查看函数声明。原来是我们使用 `log.Fatal()` 来输出错误信息：

```php
// LogError 当存在错误时记录日志
func LogError(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
```

鼠标悬停在 `log.Fatal()` 方法调用上，可以看到介绍：

> Fatal is equivalent to Print() followed by a call to os.Exit(1).

打印数据以后程序就退出了。这跟我们的预期不一致，当存在错误时，我们希望记录下来，然后程序继续执行。

修改一下：

*pkg/logger/logger.go*

```php
package logger

import "log"

// LogError 当存在错误时记录日志
func LogError(err error) {
    if err != nil {
        log.Println(err)
    }
}
```

`log.Println()` 会在 `log.Print()` 的基础上增加回车换行符。`ln` 是 `line` 的简写。

浏览器访问不存在的文章 [localhost:3000/articles/1000](http://localhost:3000/articles/1000) ，这次可以看到显示内部错误：

![Article 模型](https://img.herrluk.icu/typoraPicture/2023-02-07-15:10:08-elorTU.png)

然而这并非我们想看到的结果，我们希望看到的是 `404 文章未找到` 。问题主要出在这个判断上：

```php
if err == sql.ErrNoRows {
```

上面我们已经讲过了，针对结果集为空的情况，GORM 有单独的错误类型 —— `gorm.ErrRecordNotFound` ，修改判断：

*app/http/controllers/articles_controller.go*

```php
.
.
.

// Show 文章详情页面
func (*ArticlesController) Show(w http.ResponseWriter, r *http.Request) {

    .
    .
    .

    // 3. 如果出现错误
    if err != nil {
        if err == gorm.ErrRecordNotFound {
            // 3.1 数据未找到
            .
            .
            .
        } else {
            // 3.2 数据库错误
            .
            .
            .
        }
    } else {
        // 4. 读取成功，显示文章
        .
        .
        .
    }
}
```

浏览器访问不存在的文章 [localhost:3000/articles/1000](http://localhost:3000/articles/1000) ，结果符合预期：

![Article 模型](https://img.herrluk.icu/typoraPicture/2023-02-07-15:10:08-3VsSwA.png)

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "新建 Article 模型"
```

## 重构文章列表

### 说明

本节一起来将 main 中的文章列表逻辑挪到文章控制器里。

### 路由

先把 main.go 里的路由：

```php
router.HandleFunc("/articles", articlesIndexHandler).Methods("GET").Name("articles.index")
```

剪切到 web.go 中，并稍作修改：

*routes/web.go*

```php
.
.
.
func  RegisterWebRoutes(r *mux.Router) {
    .
    .
    .
    r.HandleFunc("/articles", ac.Index).Methods("GET").Name("articles.index")
}
```

### 控制器方法

接下来添加控制器方法，将 main.go 中 articlesIndexHandler 函数剪切并黏贴到控制器中：

*app/http/controllers/articles_controller.go*

```php
// Index 文章列表页
func (*ArticlesController) Index(w http.ResponseWriter, r *http.Request) {

    // 1. 获取结果集
    articles, err := article.GetAll()

    if err != nil {
        // 数据库错误
        logger.LogError(err)
        w.WriteHeader(http.StatusInternalServerError)
        fmt.Fprint(w, "500 服务器内部错误")
    } else {
        // 2. 加载模板
        tmpl, err := template.ParseFiles("resources/views/articles/index.gohtml")
        logger.LogError(err)

        // 3. 渲染模板，将所有文章的数据传输进去
        err = tmpl.Execute(w, articles)
        logger.LogError(err)
    }
}
```

获取文章列表那块我们封装到模型的 GetAll 方法里。接下来创建这个方法：

*app/models/article/crud.go*

```php
// GetAll 获取全部文章
func GetAll() ([]Article, error) {
    var articles []Article
    if err := model.DB.Find(&articles).Error; err != nil {
        return articles, err
    }
    return articles, nil
}
```

将 map 类型的 Article 对象传参到 `Find()` 方法内，即可获取到所有文章数据。以上等同于之前的：

```php
// 1. 执行查询语句，返回一个结果集
rows, err := db.Query("SELECT * from articles")
logger.LogError(err)
defer rows.Close()

var articles []Article
//2. 循环读取结果
for rows.Next() {
    var article Article
    // 2.1 扫码每一行的结果并赋值到一个 article 对象中
    err := rows.Scan(&article.ID, &article.Title, &article.Body)
    logger.LogError(err)
    // 2.2 将 article 追加到 articles 的这个数组中
    articles = append(articles, article)
}
// 2.3 检测循环时是否发生错误
err = rows.Err()
logger.LogError(err)
```

可见，除了代码精简、可读性以外，不需要时刻记住关闭连接，也是使用 GORM 的优势之一。

### 测试一下

重构完成，接下来使用浏览器访问 [localhost:3000/articles](http://localhost:3000/articles) ：

![重构文章列表](https://img.herrluk.icu/typoraPicture/2023-02-08-15:04:58-LqEoxG.png)

没有数据。

### 调试程序

我们来调试一下，看看哪里出了问题。

首先我们重构了数据库读取的逻辑，很有可能是这块有问题。但是我们做了很多 err 的检测，有错误的话会在命令里显示，然而我们的命令行是正常的。

GORM 提供了一个调试功能，允许我们在命令行里查看请求的 SQL 信息，我们将其开启：

*pkg/model/model.go*

```php
package model

import (
    "goblog/pkg/logger"

    "gorm.io/gorm"
    gormlogger "gorm.io/gorm/logger"

    // GORM 的 MSYQL 数据库驱动导入
    "gorm.io/driver/mysql"
)

// DB gorm.DB 对象
var DB *gorm.DB

// ConnectDB 初始化模型
func ConnectDB() *gorm.DB {

    var err error

    config := mysql.New(mysql.Config{
        DSN: "root:secret@tcp(127.0.0.1:3306)/goblog?charset=utf8&parseTime=True&loc=Local",
    })

    // 准备数据库连接池
    DB, err = gorm.Open(config, &gorm.Config{
        Logger: gormlogger.Default.LogMode(gormlogger.Info),
    })

    logger.LogError(err)

    return DB
}
```

注意顶部的 import 语句，导入 gorm/logger 时，因 goblog/pkg/logger 名称冲突，故为其指定名称：

```php
gormlogger "gorm.io/gorm/logger"
```

gorm.Config 允许我们为设置初始化配置信息，其中 Logger 可用来指定和配置 GORM 的调试器，例如说命令行打印 SQL 语句等。

LogMode 里填写的是日志级别，分别如下：

- Silent —— 静默模式，不打印任何信息
- Error —— 发生错误了才打印
- Warn —— 发生警告级别以上的错误才打印
- Info —— 打印所有信息，包括 SQL 语句

默认使用的是 Warn ，我们将其改为 Info。

浏览器里刷新 [localhost:3000/articles](http://localhost:3000/articles) 页面，命令行可见：

![重构文章列表](https://img.herrluk.icu/typoraPicture/2023-02-08-15:04:59-hXnlOw.png)

```php
[1.202ms] [rows:2] SELECT * FROM `articles`
```

`[rows:2]` 意味着从数据库了成功取出了两条数据。

我们试着在控制器里打印一下 articles 变量：

*app/http/controllers/articles_controller.go*

```php
.
.
.
// Index 文章列表页
func (*ArticlesController) Index(w http.ResponseWriter, r *http.Request) {

    // 1. 获取结果集
    articles, err := article.GetAll()

    fmt.Println("文章数据：", articles)

    .
    .
    .
}
```

浏览器里刷新 [localhost:3000/articles](http://localhost:3000/articles) 页面，观察命令行：

![重构文章列表](https://img.herrluk.icu/typoraPicture/2023-02-08-15:04:59-AeX0Vp.png)

数据没问题。我们再往下看，应该是模板里面有问题：

*resources/views/articles/index.gohtml*

```php
<!DOCTYPE html>
<html lang="en">
<head>
    <title>所有文章 —— 我的技术博客</title>
    <style type="text/css">.error {color: red;}</style>
</head>
<body>
    <h1>所有文章</h1>
    <ul>
        {{ range $key, $article := . }}
            <li><a href="{{ $article.Link }}"><strong>{{ $article.ID }}</strong>: {{ $article.Title }}</a></li>
        {{ end }}
    </ul>
</body>
</html>
```

看到了 `$article.Link` 这是一个对象方法，我们还未创建，前往 main 里，将以下方法：

```php
// Link 方法用来生成文章链接
func (a Article) Link() string {
    showURL, err := router.Get("articles.show").URL("id", strconv.FormatInt(a.ID, 10))
    if err != nil {
        logger.LogError(err)
        return ""
    }
    return showURL.String()
}
```

剪切到模型中，并稍作修改:

*app/models/article/article.go*

```php
.
.
.
// Link 方法用来生成文章链接
func (article Article) Link() string {
    return route.Name2URL("articles.show", "id", strconv.FormatUint(article.ID, 10))
}
```

因为上面我们修改了 ID 类型为 Uint64 ，`strconv.FormatInt(article.ID, 10)` 代码已经不适用，改为 `strconv.FormatUint(article.ID, 10)`

浏览器里刷新 [localhost:3000/articles](http://localhost:3000/articles) 页面：

![重构文章列表](https://img.herrluk.icu/typoraPicture/2023-02-08-15:04:59-WxbfFf.png)

问题解决。

### 清理代码

#### 1. 删除调试信息

请前往 *app/http/controllers/articles_controller.go*，删除一下这一行：

```php
fmt.Println("文章数据：", articles)
```

#### 2. 日志级别

日常开发，日志级别为 Warn 即可，否则命令太多信息会反而容易让我们错过重要的信息。请前往 *pkg/model/model.go* 将以下一行的 `gormlogger.Info` 改为 `gormlogger.Warn`：

```php
Logger: gormlogger.Default.LogMode(gormlogger.Warn),
```

### 删除无用代码

打开 main.go，请确保 articlesIndexHandler 和 Link 这两个函数均已删除。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "重构文章列表页面"
```

## 重构创建文章

### 说明

上一节我们处理好文章显示相关的逻辑，本节我们来重构文章创建部分的功能。

### 路由

在 main.go 中，剪切以下两行代码：

```php
router.HandleFunc("/articles", articlesStoreHandler).Methods("POST").Name("articles.store")
router.HandleFunc("/articles/create", articlesCreateHandler).Methods("GET").Name("articles.create")
```

加以修改并注册到我们的 web.go 文件中：

*routes/web.go*

```php
.
.
.
// RegisterWebRoutes 注册网页相关路由
func  RegisterWebRoutes(r *mux.Router) { 
    .
    .
    .
    r.HandleFunc("/articles/create", ac.Create).Methods("GET").Name("articles.create")
    r.HandleFunc("/articles", ac.Store).Methods("POST").Name("articles.store")
}
```

VSCode 会提示 ac.Create 和 ac.Store 不存在，接下来我们逐个创建。

### 表单页面

*app/http/controllers/articles_controller.go*

```php
.
.
.

// ArticlesFormData 创建博文表单数据
type ArticlesFormData struct {
    Title, Body string
    URL         string
    Errors      map[string]string
}

// Create 文章创建页面
func (*ArticlesController) Create(w http.ResponseWriter, r *http.Request) {

    storeURL := route.Name2URL("articles.store")
    data := ArticlesFormData{
        Title:  "",
        Body:   "",
        URL:    storeURL,
        Errors: nil,
    }
    tmpl, err := template.ParseFiles("resources/views/articles/create.gohtml")
    if err != nil {
        panic(err)
    }

    err = tmpl.Execute(w, data)
    if err != nil {
        panic(err)
    }
}

// Store 文章创建页面 
func (*ArticlesController)  Store(w http.ResponseWriter, r *http.Request)  {
    // 占位符，让 Go 编译器通过
}
```

新建文章的表单页面比较简单，把生成 storeURL 的调用改为 `route.Name2URL` 即可。

浏览器尝试访问 [localhost:3000/articles/create](http://localhost:3000/articles/create) ：

![重构创建文章](https://img.herrluk.icu/typoraPicture/2023-02-08-15:29:31-EUbLBo.png)

符合预期。接下来处理保存文章的逻辑。

### 保存文章

前往 main.go 中将 `articlesStoreHandler` 的声明复制到文章控制器中并稍加修改，替换掉上面创建的 `Store` 方法：

*app/http/controllers/articles_controller.go*

```php
.
.
.

func validateArticleFormData(title string, body string) map[string]string {
    errors := make(map[string]string)
    // 验证标题
    if title == "" {
        errors["title"] = "标题不能为空"
    } else if utf8.RuneCountInString(title) < 3 || utf8.RuneCountInString(title) > 40 {
        errors["title"] = "标题长度需介于 3-40"
    }

    // 验证内容
    if body == "" {
        errors["body"] = "内容不能为空"
    } else if utf8.RuneCountInString(body) < 10 {
        errors["body"] = "内容长度需大于或等于 10 个字节"
    }

    return errors
}

// Store 文章创建页面
func (*ArticlesController) Store(w http.ResponseWriter, r *http.Request) {

    title := r.PostFormValue("title")
    body := r.PostFormValue("body")

    errors := validateArticleFormData(title, body)

    // 检查是否有错误
    if len(errors) == 0 {
        lastInsertID, err := saveArticleToDB(title, body)
        if lastInsertID > 0 {
            fmt.Fprint(w, "插入成功，ID 为"+strconv.FormatUint(lastInsertID, 10))
        } else {
            logger.LogError(err)
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "500 服务器内部错误")
        }
    } else {

        storeURL := route.Name2URL("articles.store")

        data := ArticlesFormData{
            Title:  title,
            Body:   body,
            URL:    storeURL,
            Errors: errors,
        }
        tmpl, err := template.ParseFiles("resources/views/articles/create.gohtml")

        logger.LogError(err)

        err = tmpl.Execute(w, data)
        logger.LogError(err)
    }
}
```

validateArticleFormData 我们先复制一份过来，后面再尝试对表单验证这块做修改，目前先专注于让**程序可以正常运转**上。

saveArticleToDB 提示不存在，我们需要在 Article 模型中创建。因为是属于 CRUD 一类的操作，我们放置于 crud.go 文件中：

*app/models/article/crud.go*

```php
.
.
.

// Create 创建文章，通过 article.ID 来判断是否创建成功
func (article *Article) Create() (err error) {
    result := model.DB.Create(&article)
    if err = result.Error; err != nil {
        logger.LogError(err)
        return err
    }

    return nil
}
```

为了方便调用，我们将 Create 函数定义为 Article 的对象方法，这样就可以直接调用 GORM 的 `Create()` 直接传参当前对象指针执行创建操作。

GORM 的 `Create()` 有几个返回值可供判断：

```php
article.ID             // 返回插入数据的主键
result.Error           // Create结果返回 error
result.RowsAffected    // 返回插入记录的条数
```

在创建拥有自增 ID 的数据模型时，我们常用 ID 的值来判断是否插入成功，这个判断可以放置于控制器中。所以模型的 Create 方法，我们使用链式调用，可以这么写：

*app/models/article/crud.go*

```php
.
.
.

// Create 创建文章，通过 article.ID 来判断是否创建成功
func (article *Article) Create() (err error) {
    if err = model.DB.Create(&article).Error; err != nil {
        logger.LogError(err)
        return err
    }

    return nil
}
```

接下来修改 Store 里的调用：

*app/http/controllers/articles_controller.go*

```php
.
.
.
// Store 文章创建页面
func (*ArticlesController) Store(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    // 检查是否有错误
    if len(errors) == 0 {
        _article := article.Article{
            Title: title,
            Body:  body,
        }
        _article.Create()
        if _article.ID > 0 {
            fmt.Fprint(w, "插入成功，ID 为"+strconv.FormatUint(_article.ID, 10))
        } else {
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "创建文章失败，请联系管理员")
        }
    } else {
    .
    .
    .
}
```

### 浏览器测试一下

打开 [localhost:3000/articles/create](http://localhost:3000/articles/create) ，并写入内容，可以尝试填入不符合要求的内容：

![重构创建文章](https://img.herrluk.icu/typoraPicture/2023-02-08-15:29:31-5Vi2kt.png)

填入符合要求的内容提交以后：

![重构创建文章](https://img.herrluk.icu/typoraPicture/2023-02-08-15:29:31-28ywSm.png)

一切符合预期。

### 删除无用代码

最后请前往 main.go 中，删除 articlesCreateHandler 和 articlesStoreHandler 两个函数定义。

另外 main.go 中的 saveArticleToDB 函数，也不会用到，请删除。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "重构创建文章"
```

## 重构更新文章

### 说明

上节我们重构了创建文章，本节将重构更新文章功能。

### 路由

前往 main.go 中：

```php
router.HandleFunc("/articles/{id:[0-9]+}/edit", articlesEditHandler).Methods("GET").Name("articles.edit")
router.HandleFunc("/articles/{id:[0-9]+}", articlesUpdateHandler).Methods("POST").Name("articles.update")
```

将以上两行代码剪切到 web.go 路由文件中：

*routes/web.go*

```php
.
.
.

// RegisterWebRoutes 注册网页相关路由
func RegisterWebRoutes(r *mux.Router) {
    .
    .
    .

    r.HandleFunc("/articles/{id:[0-9]+}/edit", ac.Edit).Methods("GET").Name("articles.edit")
    r.HandleFunc("/articles/{id:[0-9]+}", ac.Update).Methods("POST").Name("articles.update")
}
```

VSCode 编辑器会提示 Edit 和 Update 方法不存在，接下来创建他们。

### 更新文章表单

我们先来处理更新文章的表单页面。

前往 main.go 中，将 articlesEditHandler 剪切到文章控制器并稍加修改：

*app/http/controllers/articles_controller.go*

```php
.
.
.


// Edit 文章更新页面
func (*ArticlesController) Edit(w http.ResponseWriter, r *http.Request) {

    // 1. 获取 URL 参数
    id := route.GetRouteVariable("id", r)

    // 2. 读取对应的文章数据
    article, err := article.Get(id)

    // 3. 如果出现错误
    if err != nil {
        if err == gorm.ErrRecordNotFound {
            // 3.1 数据未找到
            w.WriteHeader(http.StatusNotFound)
            fmt.Fprint(w, "404 文章未找到")
        } else {
            // 3.2 数据库错误
            logger.LogError(err)
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "500 服务器内部错误")
        }
    } else {
        // 4. 读取成功，显示编辑文章表单
        updateURL := route.Name2URL("articles.update", "id", id)
        data := ArticlesFormData{
            Title:  article.Title,
            Body:   article.Body,
            URL:    updateURL,
            Errors: nil,
        }
        tmpl, err := template.ParseFiles("resources/views/articles/edit.gohtml")
        logger.LogError(err)

        err = tmpl.Execute(w, data)
        logger.LogError(err)
    }
}
```

VSCode 会提示 getRouteVariable 、getArticleByID 和 router 不存在，分别替换成我们现有的方案即可。

需要注意的是错误判断那里需要使用 `err == gorm.ErrRecordNotFound` 进行处理。

### 更新文章

接下来处理更新文章方法。

同样的，把 main.go 中的 articlesUpdateHandler 剪切到控制器中，然后跟着 VSCode 的错误提示一个个进行修改：

```php
// Update 更新文章
func (*ArticlesController) Update(w http.ResponseWriter, r *http.Request) {

    // 1. 获取 URL 参数
    id := route.GetRouteVariable("id", r)

    // 2. 读取对应的文章数据
    _article, err := article.Get(id)

    // 3. 如果出现错误
    if err != nil {
        if err == gorm.ErrRecordNotFound {
            // 3.1 数据未找到
            w.WriteHeader(http.StatusNotFound)
            fmt.Fprint(w, "404 文章未找到")
        } else {
            // 3.2 数据库错误
            logger.LogError(err)
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "500 服务器内部错误")
        }
    } else {
        // 4. 未出现错误

        // 4.1 表单验证
        title := r.PostFormValue("title")
        body := r.PostFormValue("body")

        errors := validateArticleFormData(title, body)

        if len(errors) == 0 {

            // 4.2 表单验证通过，更新数据
            _article.Title = title
            _article.Body = body

            rowsAffected, err := _article.Update()

            if err != nil {
                // 数据库错误
                w.WriteHeader(http.StatusInternalServerError)
                fmt.Fprint(w, "500 服务器内部错误")
                return
            }

            // √ 更新成功，跳转到文章详情页
            if rowsAffected > 0 {
                showURL := route.Name2URL("articles.show", "id", id)
                http.Redirect(w, r, showURL, http.StatusFound)
            } else {
                fmt.Fprint(w, "您没有做任何更改！")
            }
        } else {

            // 4.3 表单验证不通过，显示理由

            updateURL := route.Name2URL("articles.update", "id", id)
            data := ArticlesFormData{
                Title:  title,
                Body:   body,
                URL:    updateURL,
                Errors: errors,
            }
            tmpl, err := template.ParseFiles("resources/views/articles/edit.gohtml")
            logger.LogError(err)

            err = tmpl.Execute(w, data)
            logger.LogError(err)
        }
    }
}
```

需要注意的是 gorm.ErrRecordNotFound 的使用。

主要重点在注释 `4.2 表单验证通过，更新数据` 那块，我们调用了 `_article.Update()` 方法，此方法未定义，前往模型中创建：

*app/models/article/crud.go*

```php
.
.
.
// Update 更新文章
func (article *Article) Update() (rowsAffected int64, err error) {
    result := model.DB.Save(&article)
    if err = result.Error; err != nil {
        logger.LogError(err)
        return 0, err
    }

    return result.RowsAffected, nil
}
```

我们调用 GORM 的 `Save()` 方法进行更新处理，返回结果有两个元素可以判断：

```php
result.RowsAffected // 更新的记录数
result.Error        // 更新的错误
```

我们返回的是 `result.RowsAffected`，文章控制器里接收到返回值后，即可对更新结果进行判断，如果 err 不为 nil 即数据库发生错误，如果 rowsAffected 大于零则更新成功：

```php
if err != nil {
    // 数据库错误
    w.WriteHeader(http.StatusInternalServerError)
    fmt.Fprint(w, "500 服务器内部错误")
    return
}

// √ 更新成功，跳转到文章详情页
if rowsAffected > 0 {
    showURL := route.Name2URL("articles.show", "id", id)
    http.Redirect(w, r, showURL, http.StatusFound)
} else {
    fmt.Fprint(w, "您没有做任何更改！")
}
```

### 测试一下

访问 [localhost:3000/articles/3/edit](http://localhost:3000/articles/3/edit) ，修改内容并提交，看看内容是否修改：

![重构更新文章](https://img.herrluk.icu/typoraPicture/2023-02-08-15:30:26-HD1MFH.png)

如果不修改内容进行提交，也会有相应的提示：

![重构更新文章](https://img.herrluk.icu/typoraPicture/2023-02-08-15:30:26-aCt2VQ.png)

### 删除无用代码

前往 main.go 中，请确保 articlesEditHandler 、 articlesUpdateHandler、validateArticleFormData、ArticlesFormData struct 已删除。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "重构更新文章"
```

## 重构删除文章

### 说明

上节我们处理了文章更新相关逻辑，本节我们将继续重构文章删除功能。

### 路由

前往 main.go 中，将以下这一行剪切：

```php
router.HandleFunc("/articles/{id:[0-9]+}/delete", articlesDeleteHandler).Methods("POST").Name("articles.delete")
```

黏贴到 web.go 路由文件中并稍作修改：

*routes/web.go*

```php
.
.
.
// RegisterWebRoutes 注册网页相关路由
func RegisterWebRoutes(r *mux.Router) {
    .
    .
    .
    r.HandleFunc("/articles/{id:[0-9]+}/delete", ac.Delete).Methods("POST").Name("articles.delete")
}
```

### 控制器

接下来将 main.go 中的 articlesDeleteHandler 复制到文章控制器中，并跟着 VSCode 的错误提示走，一步步进行修改：

*app/http/controllers/articles_controller.go*

```php
.
.
.

// Delete 删除文章
func (*ArticlesController) Delete(w http.ResponseWriter, r *http.Request) {

    // 1. 获取 URL 参数
    id := route.GetRouteVariable("id", r)

    // 2. 读取对应的文章数据
    _article, err := article.Get(id)

    // 3. 如果出现错误
    if err != nil {
        if err == gorm.ErrRecordNotFound {
            // 3.1 数据未找到
            w.WriteHeader(http.StatusNotFound)
            fmt.Fprint(w, "404 文章未找到")
        } else {
            // 3.2 数据库错误
            logger.LogError(err)
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "500 服务器内部错误")
        }
    } else {
        // 4. 未出现错误，执行删除操作
        rowsAffected, err := _article.Delete()

        // 4.1 发生错误
        if err != nil {
            // 应该是 SQL 报错了
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "500 服务器内部错误")
        } else {
            // 4.2 未发生错误
            if rowsAffected > 0 {
                // 重定向到文章列表页
                indexURL := route.Name2URL("articles.index")
                http.Redirect(w, r, indexURL, http.StatusFound)
            } else {
                // Edge case
                w.WriteHeader(http.StatusNotFound)
                fmt.Fprint(w, "404 文章未找到")
            }
        }
    }
}
```

`_article.Delete()` 还未创建，前往模型文件中：

*app/models/article/crud.go*

```php
.
.
.
// Delete 删除文章
func (article *Article) Delete() (rowsAffected int64, err error) {
    result := model.DB.Delete(&article)
    if err = result.Error; err != nil {
        logger.LogError(err)
        return 0, err
    }

    return result.RowsAffected, nil
}
```

### 测试一下

打开 [localhost:3000/articles](http://localhost:3000/articles) ，点击任意一篇文章，注意看文章的 ID 是多少，点击删除按钮：

![重构删除文章](https://img.herrluk.icu/typoraPicture/2023-02-08-15:34:39-ccWlss.png)

点击确定，成功的话会跳转到列表页，可以看到刚刚的文章已经被删除。

### 清理无用代码

前往 main.go 文件，确保 articlesDeleteHandler、getArticleByID、Delete 方法，Article struct，以及 getRouteVariable 均被删除。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "重构删除文章"
```

## 重构中间件

### 说明

经过前几节的重构， main.go 中的代码逐渐变少，主要还剩下中间件，这些代码也需要有单独的存放目录，以应付项目长期的发展需要。

### middlewares 包

我们将两个中间件移出来放到单独的目录下，为方便管理，每个中间件都使用独立的文件：

*app/http/middlewares/force_html.go*

```php
package middlewares

import "net/http"

// ForceHTML 强制标头返回 HTML 内容类型
func ForceHTML(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 1. 设置标头
        w.Header().Set("Content-Type", "text/html; charset=utf-8")
        // 2. 继续处理请求
        next.ServeHTTP(w, r)
    })
}
```

*app/http/middlewares/remove_trailing_slash.go*

```php
package middlewares

import (
    "net/http"
    "strings"
)

// RemoveTrailingSlash 除首页以外，移除所有请求路径后面的斜杆
func RemoveTrailingSlash(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // 1. 除首页以外，移除所有请求路径后面的斜杆
        if r.URL.Path != "/" {
            r.URL.Path = strings.TrimSuffix(r.URL.Path, "/")
        }

        // 2. 将请求传递下去
        next.ServeHTTP(w, r)
    })
}
```

### 使用中间件

一般中间件我们是在需要的地方使用，目前来讲，以上定义的两个中间件都是全局中间件，也就是说所有的路由都会使用到，我们直接在注册路由的地方使用：

*routes/web.go*

```php
.
.
.

// RegisterWebRoutes 注册网页相关路由
func RegisterWebRoutes(r *mux.Router) {
    .
    .
    .

    // 中间件：强制内容类型为 HTML
    r.Use(middlewares.ForceHTML)
}
```

以上我们只使用了 ForceHTML 中间件，之前我们已经提过，RemoveTrailingSlash 比较特殊，需要将 router 作为传参才能生效，只能修改 main.go 中的代码，我们顺便将无用的代码移除，稍加整理代码如下：

*main.go*

```php
package main

import (
    "goblog/app/http/middlewares"
    "goblog/bootstrap"
    "goblog/pkg/logger"
    "net/http"
)

func main() {
    bootstrap.SetupDB()
    router := bootstrap.SetupRoute()

    err := http.ListenAndServe(":3000", middlewares.RemoveTrailingSlash(router))
    logger.LogError(err)
}
```

可以看到，我们的 main 里的代码非常干净、清爽，这是最佳实践 —— **永远让你的入口文件保持干净**。

### 测试一下

接下来试试访问这两个路由，确保我们的中间件能正常生效：

- [localhost:3000/articles](http://localhost:3000/articles)
- [localhost:3000/articles/](http://localhost:3000/articles/)

以上两个 URL 访问的结果都应该是一样的。

至此我们所有重构任务已完成，最后运行一下 tests/pages_test.go ，应该会得到：

```php
Running tool: /opt/homebrew/bin/go test -timeout 30s -run ^TestAllPages$ goblog/tests -count=1 -v

=== RUN   TestAllPages
    /Users/summer/Code/go/src/goblog/tests/pages_test.go:35: 当前请求 URL: /
    /Users/summer/Code/go/src/goblog/tests/pages_test.go:35: 当前请求 URL: /about
    /Users/summer/Code/go/src/goblog/tests/pages_test.go:35: 当前请求 URL: /notfound
    /Users/summer/Code/go/src/goblog/tests/pages_test.go:35: 当前请求 URL: /articles
    /Users/summer/Code/go/src/goblog/tests/pages_test.go:35: 当前请求 URL: /articles/create
    /Users/summer/Code/go/src/goblog/tests/pages_test.go:35: 当前请求 URL: /articles/3
    /Users/summer/Code/go/src/goblog/tests/pages_test.go:35: 当前请求 URL: /articles/3/edit
    /Users/summer/Code/go/src/goblog/tests/pages_test.go:35: 当前请求 URL: /articles/3
    /Users/summer/Code/go/src/goblog/tests/pages_test.go:35: 当前请求 URL: /articles
    /Users/summer/Code/go/src/goblog/tests/pages_test.go:35: 当前请求 URL: /articles/1/delete
--- PASS: TestAllPages (0.02s)
PASS
ok      goblog/tests    0.311s
```

完美。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "重构中间件"
```

# 9. 前端美化

## 集成 Bootstrap

### 说明

本节课我们将集成 Bootstrap 前端 UI 框架，来让页面更加美观。

### 下载 Bootstrap

前往 [github.com/twbs/bootstrap](https://github.com/twbs/bootstrap) 下载源码，如下图：

![集成 Bootstrap](https://img.herrluk.icu/typoraPicture/2023-02-10-18:42:12-jpF4BV.png)

下载完成后解压，前往解压后的目录下，进入 dist 目录（distribution 的缩写），定位到下图两个文件：

![集成 Bootstrap](https://img.herrluk.icu/typoraPicture/2023-02-10-18:42:12-ATtYvV.png)

项目根下创建 public 目录，将他们分别移动到以下位置：

```php
public
├── css
│   └── bootstrap.min.css
└── js
    └── bootstrap.min.js
```

### 访问静态文件

网页加载样式文件的前提是这些文件能被访问到：

- [localhost:3000/css/bootstrap.min.cs...](http://localhost:3000/css/bootstrap.min.css)
- [localhost:3000/js/bootstrap.min.js](http://localhost:3000/js/bootstrap.min.js)

目前这两个文件皆为 404 的响应，那是因为我们还未注册路由。

下面我们先注册路由：

*routes/web.go*

```php
.
.
.
// RegisterWebRoutes 注册网页相关路由
func RegisterWebRoutes(r *mux.Router) {

    .
    .
    .

    // 静态资源
    r.PathPrefix("/css/").Handler(http.FileServer(http.Dir("./public")))
    r.PathPrefix("/js/").Handler(http.FileServer(http.Dir("./public")))

    // 中间件：强制内容类型为 HTML
    r.Use(middlewares.ForceHTML)
}
```

`PathPrefix()` 匹配参数里 `/css/` 前缀的 URI ， 链式调用 `Handler()` 指定处理器为 `http.FileServer()`。

`http.FileServer()` 是文件目录处理器，参数 `http.Dir("./public")` 是指定在此目录下寻找文件。

此时访问以下两个文件应能正常访问：

- [localhost:3000/css/bootstrap.min.cs...](http://localhost:3000/css/bootstrap.min.css)
- [localhost:3000/js/bootstrap.min.js](http://localhost:3000/js/bootstrap.min.js)

### 集成到模板中

先从文章列表页入手，我们在顶部和底部加载 Bootstrap 文件，且为其组织简单的结构：

*resources/views/articles/index.gohtml*

```php
<!DOCTYPE html>
<html lang="en">

<head>
  <title>所有文章 —— 我的技术博客</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
</head>

<body>

  <div class="container-sm">
    <div class="row mt-5">

      <div class="col-md-3 blog-sidebar">
        <div class="p-4 mb-3 bg-white rounded shadow-sm">
          <h1>GoBlog</h1>
          <p class="mb-0">摒弃世俗浮躁，追求技术精湛</p>
        </div>

        <div class="p-4 bg-white rounded shadow-sm mb-3">
          <h5>分类</h5>
          <ol class="list-unstyled mb-0">
            <li><a href="#">未分类</a></li>
            <li><a href="#">模板</a></li>
            <li><a href="#">数据库</a></li>
          </ol>
        </div>

        <div class="p-4 bg-white rounded shadow-sm mb-3">
          <h5>作者</h5>
          <ol class="list-unstyled mb-0">
            <li><a href="#">Summer</a></li>
            <li><a href="#">Aufree</a></li>
            <li><a href="#">Monkey</a></li>
          </ol>
        </div>

        <div class="p-4 bg-white rounded shadow-sm mb-3">
          <h5>链接</h5>
          <ol class="list-unstyled">
            <li><a href="#">关于我们</a></li>
            <li><a href="#">注册</a></li>
            <li><a href="#">登录</a></li>
          </ol>
        </div>
      </div><!-- /.blog-sidebar -->

      <div class="col-md-9 blog-main">

        {{ range $key, $article := . }}

          <div class="blog-post bg-white p-5 rounded shadow mb-4">
            <h3 class="blog-post-title"><a href="{{ $article.Link }}" class="text-dark text-decoration-none">{{ $article.Title }}</a></h3>
            <p class="blog-post-meta text-secondary">发布于 <a href="" class="font-weight-bold">2020-09-05</a> by <a href="#" class="font-weight-bold">Summer</a></p>

            <hr>
            {{ $article.Body }}

          </div><!-- /.blog-post -->

        {{ end }}


        <nav class="blog-pagination mb-5">
          <a class="btn btn-outline-primary" href="#">下一页</a>
          <a class="btn btn-outline-secondary disabled" href="#" tabindex="-1" aria-disabled="true">上一页</a>
        </nav>

      </div><!-- /.blog-main -->

    </div>
  </div>

  <script src="/js/bootstrap.min.js"></script>

</body>

</html>
```

保存成功后，浏览器访问 [localhost:3000/articles](http://localhost:3000/articles) ：

![集成 Bootstrap](https://img.herrluk.icu/typoraPicture/2023-02-10-18:42:12-UrFKLR.png)

查看下页面源码，访问 js 和 css 文件发现一切正常。

审查页面元素，查看响应标头：

![集成 Bootstrap](https://img.herrluk.icu/typoraPicture/2023-02-10-18:42:12-PUPrxg.png)

发现服务端返回的内容类型标头是：

```php
Content-Type: text/html; charset=utf-8
```

问题出在我们强制将所有 HTTP 响应类型设置为 HTML。我们知道，服务端响应的 `Content-Type` 是用来告知浏览器如何处理响应内容的，我们需要为其设置正确的响应标头。

先来看看那段强制内容类型标头为 HTML 的代码，并将其注释掉：

*routes/web.go*

```php
.
.
.

// RegisterWebRoutes 注册网页相关路由
func RegisterWebRoutes(r *mux.Router) {

    .
    .
    .

    // 中间件：强制内容类型为 HTML
    // r.Use(middlewares.ForceHTML)
}
```

先来一起回忆下，之前我们设置 ForceHTML 中间件的目的是为了让 HTML 页面得以正常渲染。

再次刷新 [localhost:3000/articles](http://localhost:3000/articles) ：

![集成 Bootstrap](https://img.herrluk.icu/typoraPicture/2023-02-10-18:42:12-yjyT2x.png)

样式标头正常，页面也能正常渲染。点击查看 articles 页面返回的标头：

![集成 Bootstrap](https://img.herrluk.icu/typoraPicture/2023-02-10-18:42:12-zFIFOD.png)

也正常。也就是说，我们将 ForceHTML 去除后，仍然能正常解析 HTML。

看下我们渲染模板的代码：

*app/http/controllers/articles_controller.go*

```php
.
.
.
// Index 文章列表页
func (*ArticlesController) Index(w http.ResponseWriter, r *http.Request) {

    // 1. 获取结果集
    articles, err := article.GetAll()

    if err != nil {
        // 数据库错误
        logger.LogError(err)
        w.WriteHeader(http.StatusInternalServerError)
        fmt.Fprint(w, "500 服务器内部错误")
    } else {
        // 2. 加载模板
        tmpl, err := template.ParseFiles("resources/views/articles/index.gohtml")
        logger.LogError(err)

        // 3. 渲染模板，将所有文章的数据传输进去
        err = tmpl.Execute(w, articles)
        logger.LogError(err)
    }
}
.
.
.
```

渲染模板的调用 `tmpl.Execute(w, articles)`，`Execute()` 在执行时会设置正确的 HTML 标头。

而解析静态文件所用到的 `http.FileServer()` 内部也会根据文件后缀设置正确的标头。

所以标头这块不需要我们干预。

### 自定义样式文件

目前页面有点偏白，我们加个背景颜色：

*public/css/app.css*

```php
body {
    background-color: #F0F2F5;
}
```

加载我们上面的自定义样式表：

*resources/views/articles/index.gohtml*

```php
.
.
.

<head>
  <title>所有文章 —— 我的技术博客</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/app.css" rel="stylesheet">
</head>
.
.
.
```

刷新页面：

![集成 Bootstrap](https://img.herrluk.icu/typoraPicture/2023-02-10-18:42:12-MS8onO.png)

好看一点了。

目前页面上有一些未开发的功能，如分类、作者、创建时间等，我们将在后面的课程中处理。Web 开发就是这样，先把想要的元素写上去，然后再为其开发功能。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "美化文章列表页"
```

## 编码格式 EditorConfig

### 说明

这一节我们来聊一下，如何统一编码格式。

项目中 `.go` 后缀名的 Go 代码有我们之前安装的 [vscode-go](https://github.com/golang/vscode-go) 插件在强制编码格式，我们无需担心。

现在我们需要考虑的是，`.gohtml` 缩进使用的是 VSCode 默认的 4 个空格长度的 Tab，因为 HTML 层级较多，我们一般推荐使用 2 个空格长度的缩进，以方便在同一个视窗中看到更多的代码。

### EditorConfig

你可能说，VSCode 编辑器设定一下就可以了。但是你同事或者其他的项目参与人员，可能不知道怎么设置，你还得通知到他们统一起来，如果是开源项目，这基本上是不可实现的。

通用的做法是利用 Editor Config 工具，大部分的编辑器都支持此插件，有些编辑器还内置了这个插件。

在 VSCode 的插件管理页面，搜索 `EditorConfig`，然后点击安装：

![切割模板](https://img.herrluk.icu/typoraPicture/2023-02-10-18:51:25-pOM9fW.png)

接下来根目录下创建 .editorconfig 文件：

*.editorconfig*

```php
; https://editorconfig.org/

root = true

[*.gohtml]
; 设定文件编码
charset = utf-8
; 移除文件尾部多余的空格
trim_trailing_whitespace = true
; 使用空格来做缩进
indent_style = space
; 缩进长度为两个空格
indent_size = 2
```

这样 EditorConfig 插件就会根据我们的配置来规范代码格式。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "新增 EditorConfig"
```

## 切割模版

### 说明

按照一般的逻辑，美化完文章列表页后，接下来就是文章内容页和创建页面。

但是我们停下来想一想，以我们现在的结构，如果我们要美化文章内容页，需要将 resources/views/articles/index.gohtml 文件所有内容复制一遍，然后再修改核心内容部分，这样会造成很多重复的代码，不方便维护。

事实上，我们可以共享头部、尾部和左边导航栏。接下来一起来拆分模板。

### 模板结构

文章的列表页、详情页、创建页和修改页，皆使用同一套布局，我们将统一放置于 resources/views/layouts 目录下，另外为了方便维护，我们将左边栏也划分出来。

*resources/views/layouts/app.gohtml*

```php
{{define "app"}}
<!DOCTYPE html>
<html lang="en">

<head>
  <title>{{template "title" .}}</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/app.css" rel="stylesheet">
</head>

<body>

  <div class="container-sm">
    <div class="row mt-5">

      {{template "sidebar" .}}

      {{template "main" .}}

    </div>
  </div>

  <script src="/js/bootstrap.min.js"></script>

</body>

</html>
{{end}}
```

Go 标准库的模板分层使用很简单，只要是两个关键词 `define` 和 `template` 。

`{{define ... }}` 是定义模板，而 `{{template ...}}` 是使用模板。

`{{define ... }}` 跟着的参数是模板的名称，而 `{{template ...}}` 有两个参数，第一个是模板，第二个是传给模板使用的数据。

**main** 模板和 **title** 模板在布局文件 `app.gohtml` 中，我们可以把他们理解为内容的占位符。所有继承此布局文件的模板，都会定义各自的 **main** 和 **title** 模板。本文随后会有例子。

接下来创建 `sidebar` 模板：

*resources/views/layouts/sidebar.gohtml*

```php
{{define "sidebar"}}
<div class="col-md-3 blog-sidebar">
  <div class="p-4 mb-3 bg-white rounded shadow-sm">
    <h1><a href="/" class="link-dark text-decoration-none">GoBlog</a></h1>
    <p class="mb-0">摒弃世俗浮躁，追求技术精湛</p>
  </div>

  <div class="p-4 bg-white rounded shadow-sm mb-3">
    <h5>分类</h5>
    <ol class="list-unstyled mb-0">
      <li><a href="#">未分类</a></li>
      <li><a href="#">模板</a></li>
      <li><a href="#">数据库</a></li>
    </ol>
  </div>

  <div class="p-4 bg-white rounded shadow-sm mb-3">
    <h5>作者</h5>
    <ol class="list-unstyled mb-0">
      <li><a href="#">Summer</a></li>
      <li><a href="#">Aufree</a></li>
      <li><a href="#">Monkey</a></li>
    </ol>
  </div>

  <div class="p-4 bg-white rounded shadow-sm mb-3">
    <h5>链接</h5>
    <ol class="list-unstyled">
      <li><a href="#">关于我们</a></li>
      <li><a href="#">注册</a></li>
      <li><a href="#">登录</a></li>
    </ol>
  </div>
</div>
{{end}}
```

上面的 **sidebar** 模板目前来讲，只供我们在布局文件中使用。

接下来是文章列表页：

*resources/views/articles/index.gohtml*

```php
{{define "title"}}
所有文章 —— 我的技术博客
{{end}}

{{define "main"}}
<div class="col-md-9 blog-main">

  {{ range $key, $article := . }}

    <div class="blog-post bg-white p-5 rounded shadow mb-4">
      <h3 class="blog-post-title"><a href="{{ $article.Link }}" class="text-dark text-decoration-none">{{ $article.Title }}</a></h3>
      <p class="blog-post-meta text-secondary">发布于 <a href="" class="font-weight-bold">2020-09-05</a> by <a href="#" class="font-weight-bold">Summer</a></p>

      <hr>
      {{ $article.Body }}

    </div><!-- /.blog-post -->

  {{ end }}


  <nav class="blog-pagination mb-5">
    <a class="btn btn-outline-primary" href="#">下一页</a>
    <a class="btn btn-outline-secondary disabled" href="#" tabindex="-1" aria-disabled="true">上一页</a>
  </nav>

</div><!-- /.blog-main -->
{{end}}
```

不难发现，有了共享模板，`index.gohtml` 的内容精简很多，精简意味着方便修改和维护。

### 渲染模板

有了模板分层，接下来我们需要告诉模板引擎如何渲染。

下面是我们之前的渲染，只适合渲染一个文件：

```php
// 2. 加载模板
tmpl, err := template.ParseFiles("resources/views/articles/index.gohtml")
logger.LogError(err)

// 3. 渲染模板，将所有文章的数据传输进去
err = tmpl.Execute(w, articles)
logger.LogError(err)
```

现在我们的将模板划分了三个文件，需要都加载这些文件：

*app/http/controllers/articles_controller.go*

```php
.
.
.
// Index 文章列表页
func (*ArticlesController) Index(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    } else {
        // ---  2. 加载模板 ---

        // 2.0 设置模板相对路径
        viewDir := "resources/views"

        // 2.1 所有布局模板文件 Slice
        files, err := filepath.Glob(viewDir + "/layouts/*.gohtml")
        logger.LogError(err)

        // 2.2 在 Slice 里新增我们的目标文件
        newFiles := append(files, viewDir+"/articles/index.gohtml")

        // 2.3 解析模板文件
        tmpl, err := template.ParseFiles(newFiles...)
        logger.LogError(err)

        // 2.4 渲染模板，将所有文章的数据传输进去
        err = tmpl.ExecuteTemplate(w, "myapp", articles)
        logger.LogError(err)
    }
}
```

以上就是加载所有相关模板文件，再解析，然后渲染。`filepath.Glob()` 这是我们第一次使用 filepath 包，此包是 Go 提供的统一不同系统的路径处理包。`Glob()` 方法会生成与传参匹配的文件名称 Slice。

`template.ParseFiles(newFiles...)` 的 `ParseFiles()` 是可变参数方法，三个点是 Go 提供的语法糖。

Slice 后加三个点，可以自动将 Slice 分解，并作为可变函数的参数。以下代码示例方便大家理解：

```php
params := []string{"g.txt", "h.txt", "i.txt"}
tmpl, err := template.ParseFiles(params...)
// 上面代码等同下面
tmpl, err := template.ParseFiles("g.txt", "h.txt", "i.txt")
```

回到我们的逻辑代码。渲染模板那块，也使用了新的 `ExecuteTemplate()` 方法，此方法声明如下：

```php
func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error {
```

第一个参数和最后一个参数与 `tmpl.Execute()` 方法一致。中间参数 `name` 是最终我们想要渲染的**模板名称**。

注意这里是模板关键词 `define` 定义的模板名称，不是模板文件名称。

保存修改后，打开浏览器 [localhost:3000/articles](http://localhost:3000/articles) ：

![切割模板](https://img.herrluk.icu/typoraPicture/2023-02-10-18:57:12-LBrb9J.png)

空白页面。这是正常的。因为我们在 `app.gohtml` 定义的是：

```php
{{define "app"}}
```

而我们加载的是：

```php
err = tmpl.ExecuteTemplate(w, "myapp", articles)
```

这是一个比较容易混淆的概念，新手容易将 `tmpl.ExecuteTemplate()` 的中间参数理解为是文件名称，为了加深印象，让读者尝试下错误的情况。

请模板名称修改为以下：

```php
err = tmpl.ExecuteTemplate(w, "app", articles)
```

再次刷新浏览器 [localhost:3000/articles](http://localhost:3000/articles) ：

![切割模板](https://img.herrluk.icu/typoraPicture/2023-02-10-18:57:12-PH7Kt6.png)

可以看到成功加载。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "切割模板"
```



## 文章内容页

### 说明

上节我们重构了文章列表页面模板，本节将修改文章内容页模板以适应新的布局。

### 修改模板

首先修改文章显示的模板：

*resources/views/articles/show.gohtml*

```php
{{define "title"}}
{{ .Title }}
{{end}}

{{define "main"}}
<div class="col-md-9 blog-main">

    <div class="blog-post bg-white p-5 rounded shadow mb-4">
      <h3 class="blog-post-title">{{ .Title }}</h3>
      <p class="blog-post-meta text-secondary">发布于 <a href="" class="font-weight-bold">2020-09-05</a> by <a href="#" class="font-weight-bold">Summer</a></p>

      <hr>
      {{ .Body }}

      {{/* 构建删除按钮  */}}
      {{ $idString := Uint64ToString .ID  }}
      <form class="mt-4" action="{{ RouteName2URL "articles.delete" "id" $idString }}" method="post">
          <button type="submit" onclick="return confirm('删除动作不可逆，请确定是否继续')">删除</button>
      </form>

    </div><!-- /.blog-post -->
</div>

{{end}}
```

跟文章列表页的 `index.gohtml` 一样，我们使用模板关键词 `define` 定义了 `title` 和 `main` 模板，以供 `app` 模板使用。

### 模板渲染

接下来修改模板渲染：

*app/http/controllers/articles_controller.go*

```php
.
.
.
// Show 文章详情页面
func (*ArticlesController) Show(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    } else {
        // ---  4. 读取成功，显示文章 ---

        // 4.0 设置模板相对路径
        viewDir := "resources/views"

        // 4.1 所有布局模板文件 Slice
        files, err := filepath.Glob(viewDir + "/layouts/*.gohtml")
        logger.LogError(err)

        // 4.2 在 Slice 里新增我们的目标文件
        newFiles := append(files, viewDir+"/articles/show.gohtml")

        // 4.3 解析模板文件
        tmpl, err := template.New("show.gohtml").
            Funcs(template.FuncMap{
                "RouteName2URL": route.Name2URL,
                "Uint64ToString": types.Uint64ToString,
            }).ParseFiles(newFiles...)
        logger.LogError(err)

        // 4.4 渲染模板，将所有文章的数据传输进去
        err = tmpl.ExecuteTemplate(w, "app", article)
        logger.LogError(err)
    }
}
.
.
.
```

大部分的代码跟文章列表的渲染类似，在 `4.3 解析模板` 注释那里有些许不同，因为我们使用了自定义模板函数。

### 浏览器试一下

![文章内容页](https://img.herrluk.icu/typoraPicture/2023-02-10-19:36:08-ggLygN.png)

一切如预期。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "文章内容页"
```



## 模型基类和 pkg/view 包

### 说明

目前渲染视图那里有很多重复代码。为了方便维护，我们需将这些代码抽象出来。

### 计划一下

文章列表和内容页的渲染代码大同小异，我们先来看下差异。

**文章内容页：**

```php
// ---  4. 读取成功，显示文章 ---

// 4.0 设置模板相对路径
viewDir := "resources/views"

// 4.1 所有布局模板文件 Slice
files, err := filepath.Glob(viewDir + "/layouts/*.gohtml")
logger.LogError(err)

// 4.2 在 Slice 里新增我们的目标文件
newFiles := append(files, viewDir+"/articles/show.gohtml")

// 4.3 解析模板文件
tmpl, err := template.New("show.gohtml").
    Funcs(template.FuncMap{
        "RouteName2URL": route.Name2URL,
        "Uint64ToString": types.Uint64ToString,
    }).ParseFiles(newFiles...)
logger.LogError(err)

// 4.4 渲染模板，将所有文章的数据传输进去
err = tmpl.ExecuteTemplate(w, "app", article)
logger.LogError(err)
```

**文章列表页：**

```php
// ---  2. 加载模板 ---

// 2.0 设置模板相对路径
viewDir := "resources/views"

// 2.1 所有布局模板文件 Slice
files, err := filepath.Glob(viewDir + "/layouts/*.gohtml")
logger.LogError(err)

// 2.2 在 Slice 里新增我们的目标文件
newFiles := append(files, viewDir+"/articles/index.gohtml")

// 2.3 解析模板文件
tmpl, err := template.ParseFiles(newFiles...)
logger.LogError(err)

// 2.4 渲染模板，将所有文章的数据传输进去
err = tmpl.ExecuteTemplate(w, "app", article)
logger.LogError(err)
```

区别在于 `ParseFiles` 那里，内容页自定义模板方法 `RouteName2URL` 用以生成删除链接，代码如下：

```php
{{/* 构建删除按钮  */}}
{{ $idString := Uint64ToString .ID  }}
<form class="mt-4" action="{{ RouteName2URL "articles.delete" "id" $idString }}" method="post">
  <button type="submit" onclick="return confirm('删除动作不可逆，请确定是否继续')">删除</button>
</form>
```

现在我们统一使用了数据模型，`Uint64ToString` 方法可以去掉，只需要我们统一为所有模型新增一个方法，用以获取字符串的 ID 值即可。

我们先来假设这个方法存在，取名为 `GetStringID()` ，模板即可修改为：

*resources/views/articles/show.gohtml*

```php
.
.
.
      {{/* 构建删除按钮  */}}
      <form class="mt-4" action="{{ RouteName2URL "articles.delete" "id" .GetStringID }}" method="post">
          <button type="submit" onclick="return confirm('删除动作不可逆，请确定是否继续')">删除</button>
      </form>
.
.
.
```

渲染部分的代码也删除 `Uint64ToString` 的设置：

*app/http/controllers/articles_controller.go*

```php
.
.
.
func (*ArticlesController) Show(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    } else {
        // ---  4. 读取成功，显示文章 ---
        .
        .
        .
        // 4.3 解析模板文件
        tmpl, err := template.New("show.gohtml").
            Funcs(template.FuncMap{
                "RouteName2URL": route.Name2URL,
            }).ParseFiles(newFiles...)
        .
        .
        .
    }
}
```

### 模型基类

这里需要我们考虑一下 `GetStringID()` 方法的存放位置。虽然我们可以将其放到 Article 模型里，以供这次使用，但是其他模型也会需要用到此方法，**如何在多个模型里共享方法？**

我们可以使用模型基类来解决。基类里存放项目模型里共用的方法和属性。

创建基类：

*app/models/model.go*

```php
package models

import (
    "goblog/pkg/types"
)

// BaseModel 模型基类
type BaseModel struct {
    ID uint64
}

// GetStringID 获取 ID 的字符串格式
func (a BaseModel) GetStringID() string {
    return types.Uint64ToString(a.ID)
}
```

至此基类创建完毕。

### 加载模型基类

接下来在 Article 模型中加载模型基类：

*app/models/article/article.go*

```php
.
.
.
// Article 文章模型
type Article struct {
    models.BaseModel

    Title string
    Body  string
}
.
.
.
```

修改完成后，刷新页面，确保一切正常：

![pgk/view 包](https://img.herrluk.icu/typoraPicture/2023-02-10-19:43:39-3LPuiy.png)

### pkg/view 包

铺垫工作做好了，接下来开始抽象 view 包。

将文章控制器 Show 方法里的渲染代码提取出来，并稍作修改：

*pkg/view/view.go*

```php
package view

import (
    "goblog/pkg/logger"
    "goblog/pkg/route"
    "html/template"
    "io"
    "path/filepath"
    "strings"
)

// Render 渲染视图
func Render(w io.Writer, name string, data interface{}) {
    // 1 设置模板相对路径
    viewDir := "resources/views/"

    // 2. 语法糖，将 articles.show 更正为 articles/show
    name = strings.Replace(name, ".", "/", -1)

    // 3 所有布局模板文件 Slice
    files, err := filepath.Glob(viewDir + "layouts/*.gohtml")
    logger.LogError(err)

    // 4 在 Slice 里新增我们的目标文件
    newFiles := append(files, viewDir+name+".gohtml")

    // 5 解析所有模板文件
    tmpl, err := template.New(name + ".gohtml").
        Funcs(template.FuncMap{
            "RouteName2URL": route.Name2URL,
        }).ParseFiles(newFiles...)
    logger.LogError(err)

    // 6 渲染模板
    err = tmpl.ExecuteTemplate(w, "app", data)
    logger.LogError(err)
}
```

代码逻辑上，新增了语法糖，自动将 articles.show 更正为 articles/show。用到了 strings 包的 `Replace()` 方法，此方法定义如下：

```php
func Replace(s, old, new string, n int) string
```

n 是允许替换的次数，设置为 -1 意味着替换所有。

接下来修改控制器：

*app/http/controllers/articles_controller.go*

```php
.
.
.
// Show 文章详情页面
func (*ArticlesController) Show(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    } else {
        // ---  4. 读取成功，显示文章 ---
        view.Render(w, "articles.show", article)
    }
}

// Index 文章列表页
func (*ArticlesController) Index(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    } else {
        // ---  2. 加载模板 ---
        view.Render(w, "articles.index", articles)
    }
}
```

太棒了，代码非常简洁。接下来尝试访问这两个页面 [localhost:3000/articles](http://localhost:3000/articles) ：

![模型基类和 pkg/view 包](https://img.herrluk.icu/typoraPicture/2023-02-10-19:43:39-DvQLxl.png)

随便点击一篇文章，一切正常：

![模型基类和 pkg/view 包](https://img.herrluk.icu/typoraPicture/2023-02-10-19:43:39-EaSthV.png)

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "模型基类和 view 包"
```

## 美化文章表单页

### 说明

本节来继续优化创建和编辑文章相关页面。

### 创建表单页面

基于 Bootstrap 的结构对创建页面模板进行优化：

*resources/views/articles/create.gohtml*

```php
{{define "title"}}
创建文章
{{end}}

{{define "main"}}
<div class="col-md-9 blog-main">
  <div class="blog-post bg-white p-5 rounded shadow mb-4">

    <h3>新建文章</h3>

    <form action="{{ RouteName2URL "articles.store" }}" method="post">

      <div class="form-group mt-3">
        <label for="title">标题</label>
        <input type="text" class="form-control {{if .Errors.title }}is-invalid {{end}}" name="title" value="{{ .Title }}" required>
        {{ with .Errors.title }}
          <div class="invalid-feedback">
            {{ . }}
          </div>
        {{ end }}
      </div>

      <div class="form-group mt-3">
        <label for="body">内容</label>
        <textarea name="body" cols="30" rows="10" class="form-control {{if .Errors.body }}is-invalid {{end}}">{{ .Body }}</textarea>
        {{ with .Errors.body }}
          <div class="invalid-feedback">
            {{ . }}
          </div>
        {{ end }}
      </div>

      <button type="submit" class="btn btn-primary mt-3">提交</button>

    </form>

  </div><!-- /.blog-post -->
</div>

{{end}}
```

注意 form 元素那里我们使用了 `RouteName2URL`。

```php
{{if .Errors.title }}is-invalid {{end}}
```

模板的 `if` 判断语句，如果发生错误，就显示 `is-invalid` CSS 类。

### 创建页面的控制器方法

因为不需要传参 URL 参数，模板里我们直接使用 `RouteName2URL` 生成 URL，代码可以变得很简洁：

*app/http/controllers/articles_controller.go*

```php
.
.
.
// Create 文章创建页面
func (*ArticlesController) Create(w http.ResponseWriter, r *http.Request) {
    view.Render(w, "articles.create", ArticlesFormData{})
}
.
.
.
// Store 文章创建页面
func (*ArticlesController) Store(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    } else {
        view.Render(w, "articles.create", ArticlesFormData{
            Title:  title,
            Body:   body,
            Errors: errors,
        })
    }
}
```

### 开始测试

1. 访问 [localhost:3000/articles/create](http://localhost:3000/articles/create)
2. 填写简单内容提交，应能看到错误提示
3. 填写符合要求的内容，应能看到提示创建成功。

![美化文章表单页](https://img.herrluk.icu/typoraPicture/2023-02-10-19:51:14-JMezxy.png)

### 编辑文章视图

接下来修改编辑页面。

同样的，我们先从模板文件入手：

*resources/views/articles/edit.gohtml*

```php
{{define "title"}}
编辑文章
{{end}}

{{define "main"}}
<div class="col-md-9 blog-main">
  <div class="blog-post bg-white p-5 rounded shadow mb-4">

    <h3>编辑文章</h3>

    <form action="{{ RouteName2URL "articles.update" "id" .Article.GetStringID }}" method="post">

      {{template "form-fields" . }}

      <button type="submit" class="btn btn-primary mt-3">更新</button>

    </form>

  </div><!-- /.blog-post -->
</div>

{{end}}
```

### 共用表单字段

我们留意到创建和编辑页面，表单内部的内容是一样的，所以抽出来放到模板里来共享：

*resources/views/articles/_form_field.gohtml*

```php
{{define "form-fields"}}
  <div class="form-group mt-3">
    <label for="title">标题</label>
    <input type="text" class="form-control {{if .Errors.title }}is-invalid {{end}}" name="title" value="{{ .Title }}" required>
    {{ with .Errors.title }}
      <div class="invalid-feedback">
        {{ . }}
      </div>
    {{ end }}
  </div>

  <div class="form-group mt-3">
    <label for="body">内容</label>
    <textarea name="body" cols="30" rows="10" class="form-control {{if .Errors.body }}is-invalid {{end}}">{{ .Body }}</textarea>
    {{ with .Errors.body }}
      <div class="invalid-feedback">
        {{ . }}
      </div>
    {{ end }}
  </div>
{{ end }}
```

创建文章页面也一并修改：

*resources/views/articles/create.gohtml*

```php
{{define "title"}}
创建文章
{{end}}

{{define "main"}}
<div class="col-md-9 blog-main">
  <div class="blog-post bg-white p-5 rounded shadow mb-4">

    <h3>新建文章</h3>

    <form action="{{ RouteName2URL "articles.store" }}" method="post">

      {{template "form-fields" . }}

      <button type="submit" class="btn btn-primary mt-3">提交</button>

    </form>

  </div><!-- /.blog-post -->
</div>

{{end}}
```

### 重构 Render 方法

Go 模板引擎渲染时需要加载所有相关的模板，但是在我们之前订阅的 `view.Render()` 方法中：

```php
func Render(w io.Writer, name string, data interface{})
```

只能接受一个模板名称，然而在编辑页面中，需要加载两个模板文件：

- `articles/_form_field.gohtml`
- `articles/edit.gohtml`

我们需要重新修改 Render 以满足需求：

*pkg/view/view.go*

```php
package view

import (
    "goblog/pkg/logger"
    "goblog/pkg/route"
    "html/template"
    "io"
    "path/filepath"
    "strings"
)

// Render 渲染视图
func Render(w io.Writer, data interface{}, tplFiles ...string) {
    // 1 设置模板相对路径
    viewDir := "resources/views/"

    // 2. 遍历传参文件列表 Slice，设置正确的路径，支持 dir.filename 语法糖
    for i, f := range tplFiles {
        tplFiles[i] = viewDir + strings.Replace(f, ".", "/", -1) + ".gohtml"
    }

    // 3. 所有布局模板文件 Slice
    layoutFiles, err := filepath.Glob(viewDir + "layouts/*.gohtml")
    logger.LogError(err)

    // 4. 合并所有文件
    allFiles := append(layoutFiles, tplFiles...)

    // 5 解析所有模板文件
    tmpl, err := template.New("").
        Funcs(template.FuncMap{
            "RouteName2URL": route.Name2URL,
        }).ParseFiles(allFiles...)
    logger.LogError(err)

    // 6 渲染模板
    err = tmpl.ExecuteTemplate(w, "app", data)
    logger.LogError(err)
}
```

修改后的 Render 方法支持 `tplFiles...` 不限参数传参，需要多少个模板，直接作为参数附加即可。

接下来修改控制器里的方法：

*app/http/controllers/articles_controller.go*

```php
.
.
.
// ArticlesFormData 创建博文表单数据
type ArticlesFormData struct {
    Title, Body string
    Article     article.Article
    Errors      map[string]string
}
.
.
.
// Edit 文章更新页面
func (*ArticlesController) Edit(w http.ResponseWriter, r *http.Request) {

    // 1. 获取 URL 参数
    id := route.GetRouteVariable("id", r)

    // 2. 读取对应的文章数据
    _article, err := article.Get(id)

    // 3. 如果出现错误
    if err != nil {
        if err == gorm.ErrRecordNotFound {
            // 3.1 数据未找到
            w.WriteHeader(http.StatusNotFound)
            fmt.Fprint(w, "404 文章未找到")
        } else {
            // 3.2 数据库错误
            logger.LogError(err)
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "500 服务器内部错误")
        }
    } else {
        // 4. 读取成功，显示编辑文章表单
        view.Render(w, ArticlesFormData{
            Title:   _article.Title,
            Body:    _article.Body,
            Article: _article,
            Errors:  nil,
        }, "articles.edit", "articles._form_field")
    }
}
.
.
.
```

ArticlesFormData 中，因为我们的 URL 都使用自定义模板方法 RouteName2URL 来生成，所以废弃掉。新增了 Article 对象，方便模板中使用。

处理更新提交过的来表单，也需要修改模板加载逻辑：

*app/http/controllers/articles_controller.go*

```php
.
.
.
// Update 更新文章
func (*ArticlesController) Update(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
        } else {
            // 4.3 表单验证不通过，显示理由
            view.Render(w, ArticlesFormData{
                Title:   title,
                Body:    body,
                Article: _article,
                Errors:  errors,
            }, "articles.edit", "articles._form_field")
        }
    }
}
.
.
.
```

接下来是创建相关的控制器逻辑，也需要加载 `_form_field.gohtml` 模板：

*app/http/controllers/articles_controller.go*

```php
.
.
.
// Create 文章创建页面
func (*ArticlesController) Create(w http.ResponseWriter, r *http.Request) {
    view.Render(w, ArticlesFormData{}, "articles.create", "articles._form_field")
}
.
.
.
// Store 文章创建页面
func (*ArticlesController) Store(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    } else {
        view.Render(w, ArticlesFormData{
            Title:  title,
            Body:   body,
            Errors: errors,
        }, "articles.create", "articles._form_field")
    }
}
.
.
.
```

另外，其他使用了 `view.Render()` 的地方，因为我们重构了此方法，所以把所有调用的地方都修改下：

*app/http/controllers/articles_controller.go*

```php
// Show 文章详情页面
func (*ArticlesController) Show(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    } else {
        // ---  4. 读取成功，显示文章 ---
        view.Render(w, article, "articles.show")
    }
}

// Index 文章列表页
func (*ArticlesController) Index(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    } else {
        // ---  2. 加载模板 ---
        view.Render(w, articles, "articles.index")
    }
}
```

为了方便进入编辑页面，我们修改下文章显示页面：

*resources/views/articles/show.gohtml*

```php
{{define "title"}}
{{ .Title }}
{{end}}

{{define "main"}}
<div class="col-md-9 blog-main">

    <div class="blog-post bg-white p-5 rounded shadow mb-4">
      <h3 class="blog-post-title">{{ .Title }}</h3>
      <p class="blog-post-meta text-secondary">发布于 <a href="" class="font-weight-bold">2020-09-05</a> by <a href="#" class="font-weight-bold">Summer</a></p>

      <hr>
      {{ .Body }}

      {{/* 构建删除按钮  */}}
      <form class="mt-4" action="{{ RouteName2URL "articles.delete" "id" .GetStringID }}" method="post">
          <button type="submit" onclick="return confirm('删除动作不可逆，请确定是否继续')" class="btn btn-outline-danger btn-sm">删除</button>
          <a href="{{ RouteName2URL "articles.edit" "id" .GetStringID }}" class="btn btn-outline-secondary btn-sm">编辑</a>
      </form>

    </div><!-- /.blog-post -->
</div>

{{end}}
```

新增了编辑链接：

![美化文章表单页](https://img.herrluk.icu/typoraPicture/2023-02-10-19:51:14-thbvMG.png)

点击进入编辑页面，提交不合规的内容，成功显示提示：

![美化文章表单页](https://img.herrluk.icu/typoraPicture/2023-02-10-19:51:14-tYgQ26.png)

合理的内容修改，也可以成功提交。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "美化文章表单页"
```



# 10.注册登录

## 注册表单

### 说明

从这一节开始，我们来开发注册和登录功能。

让我们先从构建注册表单开始。

### 注册路由

我们假设 AuthController 已经存在，利用注册路由来设计 URL 、路由名称以及对应的控制器方法：

*routes/web.go*

```php
.
.
.
// RegisterWebRoutes 注册网页相关路由
func  RegisterWebRoutes(r *mux.Router) {
    .
    .
    .
    r.HandleFunc("/articles/{id:[0-9]+}/delete", ac.Delete).Methods("POST").Name("articles.delete")

    // 用户认证
    auc := new(controllers.AuthController)
    r.HandleFunc("/auth/register", auc.Register).Methods("GET").Name("auth.register")
    r.HandleFunc("/auth/do-register", auc.DoRegister).Methods("POST").Name("auth.doregister")

    .
    .
    .
}
```

### 控制器

新建控制器文件，并创建以上的两个方法：

*app/http/controllers/auth_controller.go*

```php
package controllers

import (
    "goblog/pkg/view"
    "net/http"
)

// AuthController 处理用户认证
type AuthController struct {
}

// Register 注册页面
func (*AuthController) Register(w http.ResponseWriter, r *http.Request) {
    view.Render(w, ArticlesFormData{}, "auth.register")
}

// DoRegister 处理注册逻辑
func (*AuthController) DoRegister(w http.ResponseWriter, r *http.Request) {
    // 
}
```

以上还不是最终代码，存在两个问题：

1. 注册登录页面不需要左边导航栏，需使用不同的布局文件；
2. `ArticlesFormData` 只限于在文章控制器中使用，在此处显得格格不入，需使用更加通用的数据格式，以便在所有控制器中使用。

我们先来处理第一个问题。

### 简单布局

注册登录相关页面，都会使用此视图：

*resources/views/layouts/simple.gohtml*

```php
{{define "simple"}}
<!DOCTYPE html>
<html lang="en">

<head>
  <title>{{template "title" .}}</title>
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link href="/css/app.css" rel="stylesheet">
</head>

<body>

  <div class="container-sm">
    <div class="row  mt-5">

      <div class="col-md-8 offset-md-2 blog-main">
        {{template "main" .}}
      </div>

    </div>
  </div>

  <script src="/js/bootstrap.min.js"></script>

</body>

</html>
{{end}}
```

注册表单模板：

*resources/views/auth/register.gohtml*

```php
{{define "title"}}
注册
{{end}}

{{define "main"}}
<div class="blog-post bg-white p-5 rounded shadow mb-4">

  <h3 class="mb-5 text-center">用户注册</h3>

  <form action="{{ RouteName2URL "auth.doregister" }}" method="post">

    <div class="form-group row mb-3">
      <label for="name" class="col-md-4 col-form-label text-md-right">姓名</label>
      <div class="col-md-6">
        <input id="name" type="text" class="form-control" name="name" value="" required="" autofocus="">
      </div>
    </div>

    <div class="form-group row mb-3">
      <label for="email" class="col-md-4 col-form-label text-md-right">E-mail</label>
      <div class="col-md-6">
        <input id="email" type="email" class="form-control" name="email" value="" required="">
      </div>
    </div>

    <div class="form-group row mb-3">
      <label for="password" class="col-md-4 col-form-label text-md-right">密码</label>
      <div class="col-md-6">
        <input id="password" type="password" class="form-control" name="password" required="">
      </div>
    </div>

    <div class="form-group row mb-3">
      <label for="password-confirm" class="col-md-4 col-form-label text-md-right">确认密码</label>
      <div class="col-md-6">
        <input id="password-confirm" type="password" class="form-control" name="password_confirmation" required="">
      </div>
    </div>

    <div class="form-group row mb-3 mb-0 mt-4">
      <div class="col-md-6 offset-md-4">
        <button type="submit" class="btn btn-primary">
          注册
        </button>
      </div>
    </div>

  </form>

</div>


<div class="mb-3">
  <a href="/" class="text-sm text-muted"><small>返回首页</small></a>
  <a href="/" class="text-sm text-muted float-right"><small>登录</small></a>
</div>

{{end}}
```

注册登录等相关页面，我们都放置于 `auth` 目录下。

### 渲染简单视图

我们将在保留 `Render` 的同时创建 `RenderSimple` 方法，用以渲染使用了简单布局模板：

*pkg/view/view.go*

```php
package view

import (
    "goblog/pkg/logger"
    "goblog/pkg/route"
    "html/template"
    "io"
    "path/filepath"
    "strings"
)

// Render 渲染通用视图
func Render(w io.Writer, data interface{}, tplFiles ...string) {
    RenderTemplate(w, "app", data, tplFiles...)
}

// RenderSimple 渲染简单的视图
func RenderSimple(w io.Writer, data interface{}, tplFiles ...string) {
    RenderTemplate(w, "simple", data, tplFiles...)
}

// RenderTemplate 渲染视图
func RenderTemplate(w io.Writer, name string, data interface{}, tplFiles ...string) {
    // 1 设置模板相对路径
    viewDir := "resources/views/"

    // 2. 遍历传参文件列表 Slice，设置正确的路径，支持 dir.filename 语法糖
    for i, f := range tplFiles {
        tplFiles[i] = viewDir + strings.Replace(f, ".", "/", -1) + ".gohtml"
    }

    // 3. 所有布局模板文件 Slice
    layoutFiles, err := filepath.Glob(viewDir + "layouts/*.gohtml")
    logger.LogError(err)

    // 4. 合并所有文件
    allFiles := append(layoutFiles, tplFiles...)

    // 5 解析所有模板文件
    tmpl, err := template.New("").
        Funcs(template.FuncMap{
            "RouteName2URL": route.Name2URL,
        }).ParseFiles(allFiles...)
    logger.LogError(err)

    // 6 渲染模板
    err = tmpl.ExecuteTemplate(w, name, data)
    logger.LogError(err)
}
```

抽出来 `RenderTemplate()` 方法作为底层方法，将布局模板的名称变量化，`Render` 和 `RenderSimple` 调用此方法，并传参对应的布局名称，代码很好理解。

### 通用化传参数据格式

第一个问题已解决，接下来处理第二个问题。

先来看下 ArticlesFormData 的定义：

```php
// ArticlesFormData 创建博文表单数据
type ArticlesFormData struct {
    Title, Body string
    Article     article.Article
    Errors      map[string]string
}
```

不论从类型命名，到数据格式，都不够通用。

既然是传参给视图的数据，那我们将放置于 pkg/view 包里。因为经常使用，我们命名可以尽量简短点：

*pkg/view/view.go*

```php
package view

import (
    "goblog/pkg/logger"
    "goblog/pkg/route"
    "html/template"
    "io"
    "path/filepath"
    "strings"
)

// D 是 map[string]interface{} 的简写
type D map[string]interface{}

.
.
.
```

注意这里我们再次使用万能类型 `interface{}`，这是一个很常见的使用场景。

使用时：

```php
view.D{
    "Title":  title,
    "Body":   body,
    "Errors": errors,
}
```

等同于：

```php
ArticlesFormData{
    Title:  title,
    Body:   body,
    Errors: errors,
}
```

更加灵活、通用。

重新改写控制器：

*app/http/controllers/auth_controller.go*

```php
.
.
.
// Register 注册页面
func (*AuthController) Register(w http.ResponseWriter, r *http.Request) {
    view.RenderSimple(w, view.D{}, "auth.register")
}
.
.
.
```

### 小作业

请参考上文提到的 `view.D` 与 `ArticlesFormData` 的使用方法，独自重构 `articles_controller.go` 中的 ArticlesFormData 调用。

分两步：

- 删除 `ArticlesFormData`
- 根据命令行错误提示一个个修改为 `view.D`，直到编译通过

### 查看最终页面

首先添加注册入口链接：

*resources/views/layouts/sidebar.gohtml*

```php
.
.
.
    <ol class="list-unstyled">
      <li><a href="#">关于我们</a></li>
      <li><a href="{{ RouteName2URL "auth.register" }}">注册</a></li>
      <li><a href="#">登录</a></li>
    </ol>
.
.
.
```

访问页面：

![注册表单](https://img.herrluk.icu/typoraPicture/2023-02-11-17:51:06-p6eiYd.png)

点击进入：

![注册表单](https://img.herrluk.icu/typoraPicture/2023-02-11-17:51:06-bXomwm.png)

至此注册表单构建完成。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "注册页面"
```



## 创建用户

### 说明

上一节我们构建了注册表单，本节将开始处理表单提交以后的逻辑。

### 伪代码

打开授权控制器，定位到 `DoRegister()` 方法，我们先写伪代码：

*app/http/controllers/auth_controller.go*

```php
.
.
.
// DoRegister 处理注册逻辑
func (*AuthController) DoRegister(w http.ResponseWriter, r *http.Request) {
    // 1. 表单验证
    // 2. 验证通过 —— 入库，并跳转到首页
    // 3. 表单不通过 —— 重新显示表单
}
```

在编码开始时写一些伪代码，有利于整理思路。

表单验证以及验证不通过这块，我们下一节再来做，这一节，我们先专注于入库。

### 用户模型

接下来我们创建用户模型：

*app/models/user/user.go*

```php
package user

import (
    "goblog/app/models"
    "time"
)

// User 用户模型
type User struct {
    models.BaseModel

    Name     string
    Email    string
    Password string
}
```

与 Article 同样的使用模型基类 BaseModel，里面有我们的 ID。

还有两个字段 `CreatedAt` 和 `UpdatedAt` 也属于通用字段，Article 里也会使用到（文章的创建和更新时间），以后其他数据模型我们也会希望有数据创建的时间，所以统一添加到基类里：

*app/models/model.go*

```php
package models

import (
    "goblog/pkg/types"
    "time"
)

// BaseModel 模型基类
type BaseModel struct {
    ID uint64

    CreatedAt time.Time
    UpdatedAt time.Time
}
.
.
.
```

### 创建表结构

模型设计好了以后，接下来是创建对应的数据库表和字段。

GORM 自带了自动迁移功能，可以针对设置的模型 Struct 来自动创建数据表结构。免去了我们手动维护 SQL 的烦恼，自动迁移也有统一多个数据库系统的好处。

使用自动迁移很简单，只需要调用 `AutoMigrate()` 方法并将数据模型 Struct 传参进去即可。

因为这是一个全局动作，我们这个操作放置于数据库初始化的地方：

*bootstrap/db.go*

```php
package bootstrap

import (
    "goblog/app/models/article"
    "goblog/app/models/user"
    "goblog/pkg/model"
    "time"

    "gorm.io/gorm"
)

// SetupDB 初始化数据库和 ORM
func SetupDB() {
    .
    .
    .
    // 创建和维护数据表结构
    migration(db)
}

func migration(db *gorm.DB) {

    // 自动迁移
    db.AutoMigrate(
        &user.User{},
        &article.Article{},
    )
}
```

**注意： 请确保 goblog/app/models/user 被正确 import。如果错误 import 了，且 users 表字段不对，可直接在数据库视图工具里删除 users 表，然后重新启动 air。GORM 会在程序运行时运行迁移逻辑。**

GORM 的自动迁移工具不支持版本，只能保持字段与传参的 Struct 一致，无法删除字段。所以我们将自动迁移的代码封装到 `migration()` 方法里，以后遇到需要删除字段的情况，将这些代码写到此方法即可。

保存文件后，命令行的 air 会自动编译，此时数据库的表结构将会自动生成，我们使用 SQL 视图工具查看：

![创建用户](https://img.herrluk.icu/typoraPicture/2023-02-11-18:55:39-eWeTNg.png)

可以看到我们的 users 表已经生成。

#### 字段标签

不过 name 、email、password 的字段类型不符合我们的要求，我们可以通过设置 GORM 模型的 Struct Tag 来解决。修改下我们的模型：

*app/models/user/user.go*

```php
package user

import (
    "goblog/app/models"
)

// User 用户模型
type User struct {
    models.BaseModel

    Name     string `gorm:"column:name;type:varchar(255);not null;unique"`
    Email    string `gorm:"column:email;type:varchar(255);default:NULL;unique;"`
    Password string `gorm:"column:password;type:varchar(255)"`
}
```

模型基类里也要做修改：

*app/models/model.go*

```php
package models

import (
    "goblog/pkg/types"
    "time"
)

// BaseModel 模型基类
type BaseModel struct {
    ID uint64 `gorm:"column:id;primaryKey;autoIncrement;not null"`

    CreatedAt time.Time `gorm:"column:created_at;index"`
    UpdatedAt time.Time `gorm:"column:updated_at;index"`
}
.
.
.
```

上面使用 Struct 元素类型后面跟着 `gorm:` 开头的就是 GORM 提供的字段标签。用以告知 GORM 在迁移时，如何正确的设置数据库字段。

声明 GORM 数据模型时，字段标签是可选的，GORM 支持以下：（注：名大小写不敏感，但建议使用 `camelCase` 风格）

| 标签名         | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| column         | 指定 db 列名                                                 |
| type           | 列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：`not null`、`size`, `autoIncrement`… 像 `varbinary(8)` 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：`MEDIUMINT UNSINED not NULL AUTO_INSTREMENT` |
| size           | 指定列大小，例如：`size:256`                                 |
| primaryKey     | 指定列为主键                                                 |
| unique         | 指定列为唯一                                                 |
| default        | 指定列的默认值                                               |
| precision      | 指定列的精度                                                 |
| scale          | 指定列大小                                                   |
| not null       | 指定列为 NOT NULL                                            |
| autoIncrement  | 指定列为自动增长                                             |
| embedded       | 嵌套字段                                                     |
| embeddedPrefix | 嵌入字段的列名前缀                                           |
| autoCreateTime | 创建时追踪当前时间，对于 `int` 字段，它会追踪时间戳秒数，您可以使用 `nano`/`milli` 来追踪纳秒、毫秒时间戳，例如：`autoCreateTime:nano` |
| autoUpdateTime | 创建 / 更新时追踪当前时间，对于 `int` 字段，它会追踪时间戳秒数，您可以使用 `nano`/`milli` 来追踪纳秒、毫秒时间戳，例如：`autoUpdateTime:milli` |
| index          | 根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 [索引](https://gorm.io/zh_CN/docs/indexes.html) 获取详情 |
| uniqueIndex    | 与 `index` 相同，但创建的是唯一索引                          |
| check          | 创建检查约束，例如 `check:age > 13`，查看 [约束](https://gorm.io/zh_CN/docs/constraints.html) 获取详情 |
| <-             | 设置字段写入的权限， `<-:create` 只创建、`<-:update` 只更新、`<-:false` 无写入权限、`<-` 创建和更新权限 |
| ->             | 设置字段读的权限，`->:false` 无读权限                        |
| -              | 忽略该字段，`-` 无读写权限                                   |

接下来看下数据表结构：

![创建用户](https://img.herrluk.icu/typoraPicture/2023-02-11-18:55:39-qXhEP2.png)

可以看到字段类型符合我们的预期。

上图数字 4 标记的地方是数据库索引，可以看到 GORM 也都正确地设置了。

> **注意：** 如果你看到的表结构不符预期，请确保 bootstrap/db.go 文件中顶部 import 的是 `goblog/app/models/user` 而不是 `os/user`。如果之前是 `os/user`，请删除 users 数据表，保存下文件触发 air 重新运行项目，即可生成正确的表结构。

### 插入数据

新建创建用户的方法：

*app/models/user/crud.go*

```php
package user

import (
    "goblog/pkg/logger"
    "goblog/pkg/model"
)

// Create 创建用户，通过 User.ID 来判断是否创建成功
func (user *User) Create() (err error) {
    if err = model.DB.Create(&user).Error; err != nil {
        logger.LogError(err)
        return err
    }

    return nil
}
```

控制器里调用：

*app/http/controllers/auth_controller.go*

```php
.
.
.
// DoRegister 处理注册逻辑
func (*AuthController) DoRegister(w http.ResponseWriter, r *http.Request) {

    // 0. 初始化变量
    name := r.PostFormValue("name")
    email := r.PostFormValue("email")
    password := r.PostFormValue("password")

    // 1. 表单验证
    // 2. 验证通过 —— 入库，并跳转到首页
    _user := user.User{
        Name:     name,
        Email:    email,
        Password: password,
    }
    _user.Create()

    if _user.ID > 0 {
        fmt.Fprint(w, "插入成功，ID 为"+_user.GetStringID())
    } else {
        w.WriteHeader(http.StatusInternalServerError)
        fmt.Fprint(w, "创建用户失败，请联系管理员")
    }

    // 3. 表单不通过 —— 重新显示表单
}
```

**注意： 请确保 goblog/app/models/user 被正确 import。**

代码我们之前创建文章的时候都分解过，应该很容易看懂。

打开注册页面 [localhost:3000/auth/register](http://localhost:3000/auth/register) ，填入简单的信息：

![创建用户](https://img.herrluk.icu/typoraPicture/2023-02-11-18:55:39-LMpHwH.png)

提交成功后查看数据库：

![创建用户](https://img.herrluk.icu/typoraPicture/2023-02-11-18:55:39-pNfgT9.png)

成功插入数据。

**注意：**目前我们的密码是明文的，本节的目标是跑通数据入库的流程，后面会讲到如何正确存储密码。

数据验证我们会在下一节进行讲解。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "创建用户"
```

## 注册表单验证

### 说明

用户的数据是不能信任的，本节我们来做表单验证。

### 安装 govalidator

表单验证 Web 开发中常见的功能，Go 生态圈已经有很好的解决方案，我们无需重新发明轮子。

比较知名的有 [asaskevich/govalidator](https://github.com/asaskevich/govalidator) 和 [thedevsaddam/govalidator](https://github.com/thedevsaddam/govalidator) ，两个都值得使用，后者借鉴了 Laravel，比较简单易用，本项目将采用此包。

安装：

```php
$ go get github.com/thedevsaddam/govalidator
```

### 集成到控制器中

我们会先写比较粗糙的代码，快速跑通，看看怎么使用这个工具，然后再一步一步优化代码：

*app/http/controllers/auth_controller.go*

```php
.
.
.

type userForm struct {
    Name            string `valid:"name"`
    Email           string `valid:"email"`
    Password        string `valid:"password"`
    PasswordConfirm string `valid:"password_confirm"`
}

// DoRegister 处理注册逻辑
func (*AuthController) DoRegister(w http.ResponseWriter, r *http.Request) {

    // 1. 初始化数据
    _user := userForm{
        Name:            r.PostFormValue("name"),
        Email:           r.PostFormValue("email"),
        Password:        r.PostFormValue("password"),
        PasswordConfirm: r.PostFormValue("password_confirm"),
    }

    // 2. 表单规则
    rules := govalidator.MapData{
        "name":             []string{"required", "alpha_num", "between:3,20"},
        "email":            []string{"required", "min:4", "max:30", "email"},
        "password":         []string{"required", "min:6"},
        "password_confirm": []string{"required"},
    }

    // 3. 配置选项
    opts := govalidator.Options{
        Data:          &_user,
        Rules:         rules,
        TagIdentifier: "valid", // Struct 标签标识符
    }

    // 4. 开始认证
    errs := govalidator.New(opts).ValidateStruct()

    if len(errs) > 0 {
        // 4.1 有错误发生，打印数据
        data, _ := json.MarshalIndent(errs, "", "  ")
        fmt.Fprint(w, string(data))
    } else {
        // _user.Create()

        // if _user.ID > 0 {
        //     fmt.Fprint(w, "插入成功，ID 为"+_user.GetStringID())
        // } else {
        //     w.WriteHeader(http.StatusInternalServerError)
        //     fmt.Fprint(w, "注册失败，请联系管理员")
        // }
    }

    // 5. 表单不通过 —— 重新显示表单
}
```

`4.1 有错误发生，打印数据` 我们第一次使用 json 包的 `json.MarshalIndent()` 方法，一般此方法用来将 Go 对象格式成为 JSON 字符串，并加上合理的缩进。

后面 `_user.Create()` 我们先注释掉。

请阅读上面的代码注释，`2. 表单规则` 那块代码，是设置具体的字段验证规则，非常直观。

所有的验证规则，请参考 [项目文档](https://github.com/thedevsaddam/govalidator#validation-rules) 。

我们用到的规则如下：

| 规则名称     | 作用                     |
| ------------ | ------------------------ |
| required     | 字段必须有值             |
| alpha_num    | 只允许英文字母和数字混合 |
| between:3,20 | 字段长度介于 3 ~ 20 之间 |
| min:4        | 最少四个字符             |
| max:30       | 最大 30 个字符           |
| email        | 必须为 Email             |

文件保存后，我们测试一下，打开注册页面，随便填写一些内容，然后点提交：

![表单验证](https://img.herrluk.icu/typoraPicture/2023-02-11-19:06:50-iyNL3K.png)

可以正常工作。

### 定制错误消息

目前错误信息是英文的，接下来我们定制错误消息：

*app/http/controllers/auth_controller.go*

```php
.
.
.
// DoRegister 处理注册逻辑
func (*AuthController) DoRegister(w http.ResponseWriter, r *http.Request) {
    // 1. 初始化数据
    .
    .
    .

    // 2. 表单规则
    .
    .
    .

    // 3. 定制错误消息
    messages := govalidator.MapData{
        "name": []string{
            "required:用户名为必填项",
            "alpha_num:格式错误，只允许数字和英文",
            "between:用户名长度需在 3~20 之间",
        },
        "email": []string{
            "required:Email 为必填项",
            "min:Email 长度需大于 4",
            "max:Email 长度需小于 30",
            "email:Email 格式不正确，请提供有效的邮箱地址",
        },
        "password": []string{
            "required:密码为必填项",
            "min:长度需大于 6",
        },
        "password_confirm": []string{
            "required:确认密码框为必填项",
        },
    }

    // 4. 配置选项
    opts := govalidator.Options{
        Data:          &_user,
        Rules:         rules,
        TagIdentifier: "valid", // Struct 标签标识符
        Messages:      messages,
    }
    .
    .
    .
}
```

请注意我们在 `4. 配置选项` 那里新增了一个 `Messages` 元素。

错误消息的定制方式是字段与规则一一对应，请仔细阅读源码，很好理解。

再次刷新页面注册表单的提交页面：

![表单验证](https://img.herrluk.icu/typoraPicture/2023-02-11-19:06:50-bcYU4Z.png)

可见中文提示。

### 表单请求

为方便维护，接下来我们将思考如何把表单验证逻辑从控制器中移出，只剩下一个简单的调用。

首先是 `1. 初始化数据` ，这部分是对表单字段进行赋值，后面创建用户时，也需要编写类似的代码。我们尝试删除 `userForm` struct 并在模型中新增对应的标签：

*app/models/user/user.go*

```php
.
.
.
// User 用户模型
type User struct {
    models.BaseModel

    Name     string `gorm:"column:name;type:varchar(255);not null;unique" valid:"name"`
    Email    string `gorm:"column:email;type:varchar(255);default:NULL;unique;" valid:"email"`
    Password string `gorm:"column:password;type:varchar(255)" valid:"password"`
    // gorm:"-" —— 设置 GORM 在读写时略过此字段
    PasswordConfirm string ` gorm:"-" valid:"password_confirm"`
}
```

字段标签有点长，我们考虑精简一下。GORM 默认会将键小写化作为字段名称，`column` 项可去除，另外默认是允许 NULL 的，故 `default:NULL` 项也可去除。

精简后最终代码：

*app/models/user/user.go*

```php
.
.
.
// User 用户模型
type User struct {
    models.BaseModel

    Name     string `gorm:"type:varchar(255);not null;unique" valid:"name"`
    Email    string `gorm:"type:varchar(255);unique;" valid:"email"`
    Password string `gorm:"type:varchar(255)" valid:"password"`

    // gorm:"-" —— 设置 GORM 在读写时略过此字段，仅用于表单验证
    PasswordConfirm string `gorm:"-" valid:"password_confirm"`
}
```

**注意：** `PasswordConfirm` 字段我们使用了 GORM 的字段标示 `-`，这个配置告诉 GORM 在执行数据库读写操作时，略过此字段。因为此字段只在表单验证中使用。

接下来控制器中删除 `userForm` 声明，并将 `1. 初始化数据` 修改如下：

```php
// 1. 初始化数据
_user := user.User{
    Name:            r.PostFormValue("name"),
    Email:           r.PostFormValue("email"),
    Password:        r.PostFormValue("password"),
    PasswordConfirm: r.PostFormValue("password_confirm"),
}
```

使用到了 `user.User` ，**注意顶部 import 的是 `"goblog/app/models/user"` 否则会编译错误。**

#### 独立的表单请求文件

接下来我们需要将表单验证逻辑从控制器中迁出。参考 Laravel ，我们将每一个表单所需的验证独立存放于一个文件内，放置于 `app/requests` 目录下。考虑到后面随着业务逻辑慢慢增多，单独文件会让我们的程序架构更加清晰。

这一次处理的是注册表单，我们就给文件取名 `user_registration.go`：

*app/requests/user_registration.go*

```php
package requests

import (
    "goblog/app/models/user"

    "github.com/thedevsaddam/govalidator"
)

// ValidateRegistrationForm 验证表单，返回 errs 长度等于零即通过
func ValidateRegistrationForm(data user.User) map[string][]string {

    // 1. 定制认证规则
    rules := govalidator.MapData{
        "name":             []string{"required", "alpha_num", "between:3,20"},
        "email":            []string{"required", "min:4", "max:30", "email"},
        "password":         []string{"required", "min:6"},
        "password_confirm": []string{"required"},
    }

    // 2. 定制错误消息
    messages := govalidator.MapData{
        "name": []string{
            "required:用户名为必填项",
            "alpha_num:格式错误，只允许数字和英文",
            "between:用户名长度需在 3~20 之间",
        },
        "email": []string{
            "required:Email 为必填项",
            "min:Email 长度需大于 4",
            "max:Email 长度需小于 30",
            "email:Email 格式不正确，请提供有效的邮箱地址",
        },
        "password": []string{
            "required:密码为必填项",
            "min:长度需大于 6",
        },
        "password_confirm": []string{
            "required:确认密码框为必填项",
        },
    }

    // 3. 配置初始化
    opts := govalidator.Options{
        Data:          &data,
        Rules:         rules,
        TagIdentifier: "valid", // 模型中的 Struct 标签标识符
        Messages:      messages,
    }

    // 4. 开始验证
    errs := govalidator.New(opts).ValidateStruct()

    // 5. 因 govalidator 不支持 password_confirm 验证，我们自己写一个
    if data.Password != data.PasswordConfirm {
        errs["password_confirm"] = append(errs["password_confirm"], "两次输入密码不匹配！")
    }

    return errs
}
```

注意函数名称命名规则是 `Validate{表单名称}Form` ，如注册表单就是 `ValidateRegistrationForm`。

接下来修改 DoRegister 方法，臃肿的代码可以精简为以下：

*app/http/controllers/auth_controller.go*

```php
.
.
.
// DoRegister 处理注册逻辑
func (*AuthController) DoRegister(w http.ResponseWriter, r *http.Request) {

    // 1. 初始化数据
    _user := user.User{
        Name:            r.PostFormValue("name"),
        Email:           r.PostFormValue("email"),
        Password:        r.PostFormValue("password"),
        PasswordConfirm: r.PostFormValue("password_confirm"),
    }

    // 2. 表单规则
    errs := requests.ValidateRegistrationForm(_user)

    if len(errs) > 0 {
        // 3. 有错误发生，打印数据
        data, _ := json.MarshalIndent(errs, "", "  ")
        fmt.Fprint(w, string(data))
    } else {
        // 4. 验证成功，创建数据
        _user.Create()

        if _user.ID > 0 {
            http.Redirect(w, r, "/", http.StatusFound)
        } else {
            w.WriteHeader(http.StatusInternalServerError)
            fmt.Fprint(w, "注册失败，请联系管理员")
        }
    }
}
```

再次刷新浏览器，可以看到一切工作正常：

![表单验证](https://img.herrluk.icu/typoraPicture/2023-02-11-19:06:50-OdQetq.png)

### 友好的错误提示

表单验证有错误了，当然不是直接打印 JSON 数据，而是要给用户友好的提醒。

具体做法是将错误信息和用户提交过来的信息传入模板里进行渲染。

控制器先设定好逻辑：

*app/http/controllers/auth_controller.go*

```php
.
.
.
func (*AuthController) DoRegister(w http.ResponseWriter, r *http.Request) {
    .
    .
    .
    if len(errs) > 0 {
        // 3. 表单不通过 —— 重新显示表单
        view.RenderSimple(w, view.D{
            "Errors": errs,
            "User":   _user,
        }, "auth.register")
    } else {
        .
        .
        .
    }
}
```

注册模板修改如下：

*resources/views/auth/register.gohtml*

```php
{{define "title"}}
注册
{{end}}

{{define "main"}}
<div class="blog-post bg-white p-5 rounded shadow mb-4">

  <h3 class="mb-5 text-center">用户注册</h3>

  <form action="{{ RouteName2URL "auth.doregister" }}" method="post">

    <div class="form-group row mb-3">
      <label for="name" class="col-md-4 col-form-label text-md-right">姓名</label>
      <div class="col-md-6">
        <input id="name" type="text" class="form-control {{if .Errors.name }}is-invalid {{end}}" name="name" value="{{ .User.Name }}" required="" autofocus="">
        {{ with .Errors.name }}
          <div class="invalid-feedback">
            {{ range $message := . }}
              <p>{{ $message }}</p>
            {{ end }}
          </div>
        {{ end }}
      </div>
    </div>

    <div class="form-group row mb-3">
      <label for="email" class="col-md-4 col-form-label text-md-right">E-mail</label>
      <div class="col-md-6">
        <input id="email" type="email" class="form-control {{if .Errors.email }}is-invalid {{end}}" name="email" value="{{ .User.Email }}" required="">
        {{ with .Errors.email }}
          <div class="invalid-feedback">
            {{ range $message := . }}
              <p>{{ $message }}</p>
            {{ end }}
          </div>
        {{ end }}
      </div>
    </div>

    <div class="form-group row mb-3">
      <label for="password" class="col-md-4 col-form-label text-md-right">密码</label>
      <div class="col-md-6">
        <input id="password" type="password" class="form-control {{if .Errors.password }}is-invalid {{end}}" name="password" value="{{ .User.Password }}" required="">
        {{ with .Errors.password }}
          <div class="invalid-feedback">
            {{ range $message := . }}
              <p>{{ $message }}</p>
            {{ end }}
          </div>
        {{ end }}
      </div>
    </div>

    <div class="form-group row mb-3">
      <label for="password-confirm" class="col-md-4 col-form-label text-md-right">确认密码</label>
      <div class="col-md-6">
        <input id="password-confirm" type="password" class="form-control {{if .Errors.password_confirm }}is-invalid {{end}}" name="password_confirm" value="{{ .User.PasswordConfirm }}" required="">
        {{ with .Errors.password_confirm }}
          <div class="invalid-feedback">
            {{ range $message := . }}
              <p>{{ $message }}</p>
            {{ end }}
          </div>
        {{ end }}
      </div>
    </div>

    <div class="form-group row mb-3 mb-0 mt-4">
      <div class="col-md-6 offset-md-4">
        <button type="submit" class="btn btn-primary">
          注册
        </button>
      </div>
    </div>

  </form>

</div>


<div class="mb-3">
  <a href="/" class="text-sm text-muted"><small>返回首页</small></a>
  <a href="/" class="text-sm text-muted float-right"><small>登录</small></a>
</div>

{{end}}
```

刷新页面：

![表单验证](https://img.herrluk.icu/typoraPicture/2023-02-11-19:06:50-ibJH1o.png)

模板代码里有很多重复代码：

```php
<div class="invalid-feedback">
    {{ range $message := . }}
      <p>{{ $message }}</p>
    {{ end }}
</div>
```

我们可以将其独立到一个模板里，然后在使用到的地方使用 `template` 关键词进行加载：

*resources/views/layouts/_form_error_feedback.gohtml*

```php
{{define "invalid-feedback"}}
<div class="invalid-feedback">
  {{ range $message := . }}
    <p>{{ $message }}</p>
  {{ end }}
</div>
{{end}}
```

修改模板：

*resources/views/auth/register.gohtml*

```php
{{define "title"}}
注册
{{end}}

{{define "main"}}
<div class="blog-post bg-white p-5 rounded shadow mb-4">

  <h3 class="mb-5 text-center">用户注册</h3>

  <form action="{{ RouteName2URL "auth.doregister" }}" method="post">

    <div class="form-group row mb-3">
      <label for="name" class="col-md-4 col-form-label text-md-right">姓名</label>
      <div class="col-md-6">
        <input id="name" type="text" class="form-control {{if .Errors.name }}is-invalid {{end}}" name="name" value="{{ .User.Name }}" required="" autofocus="">
        {{ with .Errors.name }}
          {{ template "invalid-feedback" . }}
        {{ end }}
      </div>
    </div>

    <div class="form-group row mb-3">
      <label for="email" class="col-md-4 col-form-label text-md-right">E-mail</label>
      <div class="col-md-6">
        <input id="email" type="email" class="form-control {{if .Errors.email }}is-invalid {{end}}" name="email" value="{{ .User.Email }}" required="">
        {{ with .Errors.email }}
          {{ template "invalid-feedback" . }}
        {{ end }}
      </div>
    </div>

    <div class="form-group row mb-3">
      <label for="password" class="col-md-4 col-form-label text-md-right">密码</label>
      <div class="col-md-6">
        <input id="password" type="password" class="form-control {{if .Errors.password }}is-invalid {{end}}" name="password" value="{{ .User.Password }}" required="">
        {{ with .Errors.password }}
          {{ template "invalid-feedback" . }}
        {{ end }}
      </div>
    </div>

    <div class="form-group row mb-3">
      <label for="password-confirm" class="col-md-4 col-form-label text-md-right">确认密码</label>
      <div class="col-md-6">
        <input id="password-confirm" type="password" class="form-control {{if .Errors.password_confirm }}is-invalid {{end}}" name="password_confirm" value="{{ .User.PasswordConfirm }}" required="">
        {{ with .Errors.password_confirm }}
          {{ template "invalid-feedback" . }}
        {{ end }}
      </div>
    </div>

    <div class="form-group row mb-3 mb-0 mt-4">
      <div class="col-md-6 offset-md-4">
        <button type="submit" class="btn btn-primary">
          注册
        </button>
      </div>
    </div>

  </form>

</div>


<div class="mb-3">
  <a href="/" class="text-sm text-muted"><small>返回首页</small></a>
  <a href="/" class="text-sm text-muted float-right"><small>登录</small></a>
</div>

{{end}}
```

可以看到 `{{ template "invalid-feedback" . }}` 的使用，再次刷新页面：

![表单验证](https://img.herrluk.icu/typoraPicture/2023-02-11-19:06:50-avI66P.png)

工作正常。

**提示：** 因为我们将 `invalid-feedback` 当做通用组件放置于 `resources/views/layouts` 目录中，此目录里的所有文件都会被自动加载，代码逻辑请见自定义包 `pkg/view` 里的 `RenderTemplate` 方法。

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "注册表单验证"
```

## 自定义验证规则

### 说明

目前我们的表单验证还未完整，当数据库里有相同**用户名或者邮箱**时，用户提交注册，会显示：

![用户名和邮箱唯一](https://img.herrluk.icu/typoraPicture/2023-02-18-23:04:24-dcd8tJ.png)

在看下命令行终端：

![用户名和邮箱唯一](https://img.herrluk.icu/typoraPicture/2023-02-18-23:04:24-crajVi.png)

这是因为我们在创建用户模型时，使用 GORM 的字段标签，为 Email 和用户名字段设置了 `unique` 属性。

接下来我们优化反馈逻辑，在用户名或者邮箱已存在的情况，给予用户提示。

### 添加自定义规则

参考 [项目首页文档](https://github.com/thedevsaddam/govalidator#add-custom-rules) 创建自定义规则：

*app/requests/request.go*

```php
package requests

import (
    "fmt"
    "goblog/pkg/model"
    "strings"

    "github.com/thedevsaddam/govalidator"
)

// 此方法会在初始化时执行
func init() {
    // not_exists:users,email
    govalidator.AddCustomRule("not_exists", func(field string, rule string, message string, value interface{}) error {
        rng := strings.Split(strings.TrimPrefix(rule, "not_exists:"), ",")

        tableName := rng[0]
        dbFiled := rng[1]
        val := value.(string)

        var count int64
        model.DB.Table(tableName).Where(dbFiled+" = ?", val).Count(&count)

        if count != 0 {

            if message != "" {
                return errors.New(message)
            }

            return fmt.Errorf("%v 已被占用", val)
        }
        return nil
    })
}
```

这是我们第一次使用 `init()` 方法。在 Go 里面，`init()` 方法是特殊类型方法，他会在包被引入的时候执行。

请见下图：

![用户名和邮箱唯一](https://img.herrluk.icu/typoraPicture/2023-02-18-23:04:24-9CHNRH.png)

如上图，有以下须知：

- 假如 main 引入了 pkg1 最终依赖于 pkg3，pkg3 中的 `init()` 方法会优先被执行；
- 同一个包里，单文件的情况，`init()` 优先于其他方法执行，包括 `main()`；
- 同一个包里的常量和变量声明会优先于 `init()` 方法执行；
- 同一个文件里允许多个 `init()` 存在，会按照自上而下的顺序执行；
- 同一个包，多个文件里存在 `init()` 的情况，执行顺序是按文件名的字母排序执行。

Go 的官方标准库里很多包都使用 `init()` 来初始化数据。在这里我们利用此机制来优先执行注册自定义规则的代码。

### 使用认证规则

*app/requests/user_registration.go*

```php
.
.
.
// ValidateRegistrationForm 验证表单，返回 errs 长度等于零即通过
func ValidateRegistrationForm(data user.User) map[string][]string {

    // 1. 定制认证规则
    rules := govalidator.MapData{
        "name":             []string{"required", "alpha_num", "between:3,20", "not_exists:users,name"},
        "email":            []string{"required", "min:4", "max:30", "email", "not_exists:users,email"},
        .
        .
        .
    }
    .
    .
    .
}
```

在两个需要的字段后面新增了 `not_exists` 规则，当用户名或者 Email 被占用后，提交表单可见：

![用户名和邮箱唯一](https://img.herrluk.icu/typoraPicture/2023-02-18-23:04:24-haJQE9.png)

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "确保用户名和邮箱唯一"
```

## 登录和会话控制

### 说明

用户注册成功，接下来开发用户登录功能。

### 注册路由

首先我们来注册路由：

*routes/web.go*

```php
.
.
.
// RegisterWebRoutes 注册网页相关路由
func RegisterWebRoutes(r *mux.Router) {
    .
    .
    .
    r.HandleFunc("/auth/login", auc.Login).Methods("GET").Name("auth.login")
    r.HandleFunc("/auth/dologin", auc.DoLogin).Methods("POST").Name("auth.dologin")

    // 静态资源
    .
    .
    .
}
```

### 控制器方法

接下来创建控制器方法：

*app/http/controllers/auth_controller.go*

```php
.
.
.
// Login 显示登录表单
func (*AuthController) Login(w http.ResponseWriter, r *http.Request) {
    view.RenderSimple(w, view.D{}, "auth.login")
}

// DoLogin 处理登录表单提交
func (*AuthController) DoLogin(w http.ResponseWriter, r *http.Request) {
    //
}
```

DoLogin 的逻辑我们等会再写。先将显示登录表单跑通。

### 视图

接下来创建 `auth.login` 视图，将 register.gohtml 内容复制过来然后稍作修改：

*resources/views/auth/login.gohtml*

```php
{{define "title"}}
登录
{{end}}

{{define "main"}}
<div class="blog-post bg-white p-5 rounded shadow mb-4">

  <h3 class="mb-5 text-center">用户登录</h3>

  <form action="{{ RouteName2URL "auth.dologin" }}" method="post">

    <div class="form-group row mb-3">
      <label for="email" class="col-md-4 col-form-label text-md-right">E-mail</label>
      <div class="col-md-6">
        <input id="email" type="email" class="form-control {{if .Error }}is-invalid {{end}}" name="email" value="{{ .Email }}" required="">
        {{ with .Error }}
          <div class="invalid-feedback">
              <p>{{ . }}</p>
          </div>
        {{ end }}
      </div>
    </div>

    <div class="form-group row mb-3">
      <label for="password" class="col-md-4 col-form-label text-md-right">密码</label>
      <div class="col-md-6">
        <input id="password" type="password" class="form-control {{if .Errors.password }}is-invalid {{end}}" name="password" value="{{ .Password }}" required="">
      </div>
    </div>

    <div class="form-group row mb-3 mb-0 mt-4">
      <div class="col-md-6 offset-md-4">
        <button type="submit" class="btn btn-primary">
          登录
        </button>
      </div>
    </div>

  </form>

</div>


<div class="mb-3">
  <a href="/" class="text-sm text-muted"><small>返回首页</small></a>
  <a href="" class="text-sm text-muted float-right"><small>找回密码</small></a>
</div>

{{end}}
```

### 访问登录页面

浏览器打开： [localhost:3000/auth/login](http://localhost:3000/auth/login)

![用户登录](https://img.herrluk.icu/typoraPicture/2023-02-18-23:11:18-ZaNSwe.png)

### 什么是会话控制？

用户登录，技术上讲是叫**会话控制**。

HTTP 是无状态的，要保证会话控制，要利用 Cookie 来做。

一般做会话控制，有两种方式：

- 一种是不带后端存储
- 另一种是带后端存储

#### 全 Cookie 会话

不带后端存储的就是将会话数据存储于 Cookie 中。数据是加密过的，且一般设置 Cookie 时使用 HttpOnly 标示来防止 JS 读取。传输到服务端的时候，再重新解密。

主要好处是在多服务器时不需要配置，原生支持，因为数据都存储在客户端的 Cookie 中，只需要保证加密解密的钥匙是一样的即可。

坏处有两个：

- 一个是依赖于 HTTP **Cookie 有数据大小限制**，Cookie 的总大小不能超过 4KB，使用时要注意不能往会话里写入太多数据；
- 第二个，因为会话数据是放在客户端，在用户访问服务器之前，我们**无法对这些会话数据进行修改和管理**（例如说因为特殊情况需要重置所有会话，也就是说让所有用户重新登录）。

#### 带存储的会话

而带后端存储的会话控制，也同样使用 Cookie，不过只保存会话 ID，所有数据都放于存储器中。

常见的存储介质有：

- 文件
- MySQL
- Memcache
- Redis
- 等

这种做法最大的好处是可以**存储更多的会话数据**，但是坏处是当多机器部署时，需要注意使用同一个会话存储，以免造成混乱。多机部署的问题使用专业会话存储工具，如 Memcache 或者 Redis 很容易解决。

### gorilla/sessions 库

本项目中，我们将使用 [gorilla/sessions](https://github.com/gorilla/sessions) 来做会话管理。

gorilla/sessions 原生支持 Cookie 会话和文件会话两种方式，也有很多 [第三方的存储器](https://github.com/gorilla/sessions#store-implementations) 支持，MySQL/Memcache/Redis 应有尽有。

从易用性考虑，本项目我们将使用 Cookie 会话，其他会话存储器的使用大同小异，只是初始化时有所不同。

#### gorilla/sessions 库为我们做了什么？

gorilla/sessions 为我们提供了会话数据的**加密解密**，以及底层的 **Cookie 管理**。使用时，我们可以通过配置信息来更改其默认行为。

### 我们需要做什么？

我们先来规划一下。

gorilla/sessions 提供的接口比较简单，为了方便维护，我们需要将其封装到自己的 session 包里，目前能想到的有以下方法：

| 方法名称             | 作用                       |
| -------------------- | -------------------------- |
| session.StartSession | 初始化会话，在中间件中调用 |
| session.Put          | 写入键值对应的会话数据     |
| session.Get          | 获取会话数据               |
| session.Forget       | 删除某个会话项             |
| session.Flush        | 删除当前                   |
| session.Save         | 保存会话                   |

以上方法名称参考了知名的 Laravel 框架。

### session 包

聊了这么多，接下来开始写代码。

先安装 gorilla/sessions 包：

```php
$ go get github.com/gorilla/sessions
```

接下来我们会创建两个包，分别是：

- session —— 负责与 gorilla/sessions 交互的逻辑
- auth —— 负责用户认证相关逻辑，底层使用 session 包

这样设计的好处是，auth 认证逻辑（登录、退出等）与底层的 session 管理逻辑解耦。假如后面我们如果要换 session 驱动，或者使用不同的认证机制，都不用碰到应用里到处使用的 auth 代码。

因为 auth 包要依赖 session 包，优先创建底层包：

*pkg/session/session.go*

```php
package session

import (
    "goblog/pkg/logger"
    "net/http"

    "github.com/gorilla/sessions"
)

// Store gorilla sessions 的存储库
var Store = sessions.NewCookieStore([]byte("33446a9dcf9ea060a0a6532b166da32f304af0de"))

// Session 当前会话
var Session *sessions.Session

// Request 用以获取会话
var Request *http.Request

// Response 用以写入会话
var Response http.ResponseWriter

// StartSession 初始化会话，在中间件中调用
func StartSession(w http.ResponseWriter, r *http.Request) {
    var err error

    // Store.Get() 的第二个参数是 Cookie 的名称
    // gorilla/sessions 支持多会话，本项目我们只使用单一会话即可
    Session, err = Store.Get(r, "goblog-session")
    logger.LogError(err)

    Request = r
    Response = w
}

// Put 写入键值对应的会话数据
func Put(key string, value interface{}) {
    Session.Values[key] = value
    Save()
}

// Get 获取会话数据，获取数据时请做类型检测
func Get(key string) interface{} {
    return Session.Values[key]
}

// Forget 删除某个会话项
func Forget(key string) {
    delete(Session.Values, key)
    Save()
}

// Flush 删除当前会话
func Flush() {
    Session.Options.MaxAge = -1
    Save()
}

// Save 保持会话
func Save() {
    // 非 HTTPS 的链接无法使用 Secure 和 HttpOnly，浏览器会报错
    // Session.Options.Secure = true
    // Session.Options.HttpOnly = true
    err := Session.Save(Request, Response)
    logger.LogError(err)
}
```

上文已经把 session 的方法罗列出来，这里照着 [gorilla/sessions](https://godoc.org/github.com/gorilla/sessions) 的文档将调用方式填入进去。

> **注意：** 调用 `NewCookieStore` 时传参的是一串随机字符串，作为最佳实践，这个随机字串应该放置于配置中，并且随着程序的不同环境而不一致，这里我们先这么写着，后面再来统一处理配置信息的问题。

#### 使用会话

我们需要创建中间件来运行会话初始化方法 `session.StartSession()`：

*app/http/middlewares/start_session.go*

```php
package middlewares

import (
    "goblog/pkg/session"
    "net/http"
)

// StartSession 开启 session 会话控制
func StartSession(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

        // 1. 启动会话
        session.StartSession(w, r)

        // 2. . 继续处理接下去的请求
        next.ServeHTTP(w, r)
    })
}
```

还需要注册中间件：

*routes/web.go*

```php
.
.
.
// RegisterWebRoutes 注册网页相关路由
func RegisterWebRoutes(r *mux.Router) {
    .
    .
    .
    // --- 全局中间件 ---

    // 开始会话
    r.Use(middlewares.StartSession)
}
```

### 测试

接下来我们来测试一下，测试之前，为了方便查看 Cookie 请安装 [EditThisCookie](http://www.editthiscookie.com/) Chrome 插件（安装不上的同学没关系，下面会有详尽的截图，知道原理就行）。

就利用我们的登录页面，请访问 [localhost:3000/auth/login](http://localhost:3000/auth/login) ，打开 EditThisCookie 插件可以看到当前我们并无 Cookie：

![登录和会话控制](https://img.herrluk.icu/typoraPicture/2023-02-18-23:11:18-UgYEDM.png)

#### 新增会话数据

在控制器里我们新增个会话数据：

*app/http/controllers/auth_controller.go*

```php
.
.
.
// Login 显示登录表单
func (*AuthController) Login(w http.ResponseWriter, r *http.Request) {

    session.Put("uid", "1")

    view.RenderSimple(w, view.D{}, "auth.login")
}
.
.
.
```

浏览器刷新，再次查看 Cookie：

![登录和会话控制](https://img.herrluk.icu/typoraPicture/2023-02-18-23:11:18-hhucEt.png)

上图可以看到 Cookie 已经种上了，数据是加密的，且过期时间是距离现在一个月，这是 gorilla/sessions 的默认值，可以通过设置 `Session.Options.MaxAge` 来更改。

#### 读取会话数据

接下来我们尝试读出会话数据：

*app/http/controllers/auth_controller.go*

```php
.
.
.
// Login 显示登录表单
func (*AuthController) Login(w http.ResponseWriter, r *http.Request) {

    fmt.Fprint(w, session.Get("uid"))

    // view.RenderSimple(w, view.D{}, "auth.login")
}
.
.
.
```

刷新登录页面：

![登录和会话控制](https://img.herrluk.icu/typoraPicture/2023-02-18-23:11:18-YcuLuz.png)

可见数据被准确读出来。请注意，HTTP 是无状态的，**我们现已成功让两次不同的请求共享数据**。

#### 删除会话数据

接下来试下删除会话值：

*app/http/controllers/auth_controller.go*

```php
.
.
.
// Login 显示登录表单
func (*AuthController) Login(w http.ResponseWriter, r *http.Request) {

    session.Forget("uid")

    view.RenderSimple(w, view.D{},  "auth.login")
}
.
.
.
```

刷新一下 [localhost:3000/auth/login](http://localhost:3000/auth/login) ，然后再次读取：

*app/http/controllers/auth_controller.go*

```php
.
.
.
// Login 显示登录表单
func (*AuthController) Login(w http.ResponseWriter, r *http.Request) {

    fmt.Fprint(w, session.Get("uid"))

    // view.RenderSimple(w, view.D{}, "auth.login")
}
.
.
.
```

可以看到：

![登录和会话控制](https://img.herrluk.icu/typoraPicture/2023-02-18-23:11:18-NeDkzK.png)

#### 销毁整个会话

更改：

*app/http/controllers/auth_controller.go*

```php
.
.
.
// Login 显示登录表单
func (*AuthController) Login(w http.ResponseWriter, r *http.Request) {

    session.Flush()

    view.RenderSimple(w, view.D{},  "auth.login")
}
.
.
.
```

刷新一下 [localhost:3000/auth/login](http://localhost:3000/auth/login) ，点击 EditThisCookie 按钮查看 Cookie：

![登录和会话控制](https://img.herrluk.icu/typoraPicture/2023-02-18-23:11:18-qliB3q.png)

Cookie 已被清空，符合预期。

### 还原代码

请删除测试代码，为下一节做准备：

*app/http/controllers/auth_controller.go*

```php
.
.
.
// Login 显示登录表单
func (*AuthController) Login(w http.ResponseWriter, r *http.Request) {
    view.RenderSimple(w, view.D{},  "auth.login")
}
.
.
.
```

### 代码版本

开始下一节之前，我们先来为代码做下版本标记：

```php
$ git add .
$ git commit -m "登录表单和会话控制"
```
