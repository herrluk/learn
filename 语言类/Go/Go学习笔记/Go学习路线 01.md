# cobra库

## 安装和使用

使用命令安装 cobra 生成器`go install github.com/spf13/cobra-cli@latest`。Go 会自动将它安装在你的`$GOPATH/bin`目录中，该目录应该在你的 $PATH 中。

安装后，您应该可以使用该`cobra-cli`命令。`cobra-cli`通过在命令行中键入来确认。

Cobra 生成器目前只支持两种操作：

### cobra-cli 初始化

该`cobra-cli init [app]`命令将为您创建初始应用程序代码。这是一个非常强大的应用程序，可以用正确的结构填充您的程序，这样您就可以立即享受 Cobra 的所有好处。它还可以将您指定的许可证应用于您的应用程序。

随着 Go 模块的引入，Cobra 生成器已被简化以利用模块。Cobra 生成器在 Go 模块中工作。

#### 初始化模块

**如果您已有模块，请跳过此步骤。**

如果你想初始化一个新的 Go 模块：

1. 创建一个新目录
2. `cd`进入那个目录
3. 运行`go mod init <MODNAME>`

例如

```
cd $HOME/code 
mkdir myapp
cd myapp
go mod init github.com/spf13/myapp
```

#### 初始化 Cobra CLI 应用程序

从 Go 模块中运行`cobra-cli init`. 这将创建一个新的准系统项目供您编辑。

您应该能够立即运行您的新应用程序。尝试一下 `go run main.go`。

您需要打开并编辑“`cmd/root.go`”并提供您自己的描述和逻辑。

例如

```
cd $HOME/code/myapp
cobra-cli init
go run main.go
```

cobra-cli init 也可以从子目录运行，例如how the [cobra generator itself is organized](https://github.com/spf13/cobra-cli). 如果您想将应用程序代码与库代码分开，这将很有用。

#### 可选标志：

您可以为它提供您的作者姓名和`--author`标志。例如`cobra-cli init --author "Steve Francia spf@spf13.com"`

您可以提供使用许可，`--license` 例如`cobra-cli init --license apache`

使用`--viper`标志自动设置[viper](https://github.com/spf13/viper)

Viper 是 Cobra 的伴侣，旨在提供对环境变量和配置文件的轻松处理，并将它们无缝连接到应用程序标志。

### 向项目添加命令

初始化 Cobra 应用程序后，您可以继续使用 Cobra 生成器向您的应用程序添加其他命令。执行此操作的命令是`cobra-cli add`。

假设您创建了一个应用程序，并希望为它执行以下命令：

- 应用服务
- 应用配置
- 应用程序配置创建

在您的项目目录（您的 main.go 文件所在的位置）中，您将运行以下命令：

```
cobra-cli add serve
cobra-cli add config
cobra-cli add create -p 'configCmd'
```

`cobra-cli add``cobra-cli init`支持与（如上所述）相同的所有可选标志。

您会注意到这个最终命令有一个`-p`标志。这用于将父命令分配给新添加的命令。在这种情况下，我们要将“create”命令分配给“config”命令。如果未指定，所有命令都具有 rootCmd 的默认父级。

默认情况下`cobra-cli`将附加`Cmd`到提供的名称并将此名称用作内部变量名称。指定父级时，一定要与代码中使用的变量名相匹配。

*注意：命令名称使用驼峰命名法（不是 snake_case/kebab-case）。否则，您将遇到错误。例如，`cobra-cli add add-user`不正确，但`cobra-cli add addUser`有效。*

运行这三个命令后，您将拥有类似于以下的应用程序结构：

```
  ▾ app/
    ▾ cmd/
        config.go
        create.go
        serve.go
        root.go
      main.go
```

此时您可以运行`go run main.go`，它会运行您的应用程序。`go run main.go serve`, `go run main.go config`,`go run main.go config create`连同`go run main.go help serve`, 等都可以。

您现在已经启动并运行了一个基于 Cobra 的基本应用程序。下一步是在 cmd 中编辑文件并为您的应用程序自定义它们。

有关使用 Cobra 库的完整详细信息，请阅读[Cobra 用户指南](https://github.com/spf13/cobra/blob/master/user_guide.md#using-the-cobra-library)。

### 配置 Cobra 生成器

如果您提供一个简单的配置文件，Cobra 生成器将更易于使用，这将帮助您避免在标志中一遍又一遍地提供一堆重复信息。

示例 `~/.cobra.yaml` 文件：

```
author: Steve Francia <spf@spf13.com>
license: MIT
useViper: true
```

您还可以使用内置许可证。例如，**GPLv2**、**GPLv3**、**LGPL**、 **AGPL**、**MIT**、**2-Clause BSD**或**3-Clause BSD**。

您可以通过设置为不指定许可证`license`，`none`也可以指定自定义许可证：

```
author: Steve Francia <spf@spf13.com>
year: 2020
license:
  header: This file is part of CLI application foo.
  text: |
    {{ .copyright }}

    This is my license. There are many like it, but this one is mine.
    My license is my best friend. It is my life. I must master it as I must
    master my life.
```

在上面的自定义许可证配置中，`copyright`许可证文本中的行是从`author`和`year`属性生成的。该文件的内容 `LICENSE`是

```
Copyright © 2020 Steve Francia <spf@spf13.com>

This is my license. There are many like it, but this one is mine.
My license is my best friend. It is my life. I must master it as I must
master my life.
```

该`header`属性用作许可证头文件。不进行插值。这是go文件头的例子。

```
/*
Copyright © 2020 Steve Francia <spf@spf13.com>
This file is part of CLI application foo.
*/
```

使用cobra-cli初始化基础代码结构

```bash
# cobra-cli  init
Your Cobra application is ready at ...goProjectsPractice/cobra


#查看目录结构 需要在上一级目录查看 否则使用 tree .
# tree cobra
cobra
├── LICENSE
├── cmd
│   └── root.go
├── go.mod
├── go.sum
└── main.go

1 directory, 5 files
```

> 在mac的OS X系统中如果想使用tree这个命令，那么通过一句代码便可完成安装。 进入家目录，使用 homebrew 安装 tree 命令行。 在终端中输入如下代码：
>
> ```html
> brew install tree
> ```
>
> 安装完便可通过tree命令查看目录树

## 用户指南

虽然欢迎您提供自己的组织，但通常基于 Cobra 的应用程序将遵循以下组织结构：

```
  ▾ appName/
    ▾ cmd/
        add.go
        your.go
        commands.go
        here.go
      main.go
```

在 Cobra 应用程序中，通常 main.go 文件非常简单。它有一个目的：初始化 Cobra。

```
package main

import (
  "{pathToYourApp}/cmd"
)

func main() {
  cmd.Execute()
}
```

### 使用 Cobra 生成器

Cobra-CLI 是它自己的程序，它将创建您的应用程序并添加您想要的任何命令。这是将 Cobra 合并到您的应用程序中的最简单方法。

有关使用 Cobra 生成器的完整详细信息，请参阅[The Cobra-CLI Generator README](https://github.com/spf13/cobra-cli/blob/main/README.md)

### 使用 Cobra 库

要手动实施 Cobra，您需要创建一个裸 main.go 文件和一个 rootCmd 文件。您可以选择提供您认为合适的其他命令。

#### 创建 rootCmd

Cobra 不需要任何特殊的构造函数。只需创建您的命令。

理想情况下，您将它放在 app/cmd/root.go 中：

```go
var rootCmd = &cobra.Command{
  Use:   "hugo",
  Short: "Hugo is a very fast static site generator",
  Long: `A Fast and Flexible Static Site Generator built with
                love by spf13 and friends in Go.
                Complete documentation is available at https://gohugo.io/documentation/`,
  Run: func(cmd *cobra.Command, args []string) {
    // Do Stuff Here
  },
}

func Execute() {
  if err := rootCmd.Execute(); err != nil {
    fmt.Fprintln(os.Stderr, err)
    os.Exit(1)
  }
}
```

- Use：命令名
- Short & Long：帮助信息的 短/长 文字内容
- Run：运行命令的逻辑

您还将在 init() 函数中定义标志和处理配置。

例如cmd/root.go：

```go
package cmd

import (
	"fmt"
	"os"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var (
	// Used for flags.
	cfgFile     string
	userLicense string

	rootCmd = &cobra.Command{
		Use:   "cobra-cli",
		Short: "A generator for Cobra based Applications",
		Long: `Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.`,
	}
)

// Execute executes the root command.
func Execute() error {
	return rootCmd.Execute()
}

func init() {
	cobra.OnInitialize(initConfig)

	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", "config file (default is $HOME/.cobra.yaml)")
	rootCmd.PersistentFlags().StringP("author", "a", "YOUR NAME", "author name for copyright attribution")
	rootCmd.PersistentFlags().StringVarP(&userLicense, "license", "l", "", "name of license for the project")
	rootCmd.PersistentFlags().Bool("viper", true, "use Viper for configuration")
	viper.BindPFlag("author", rootCmd.PersistentFlags().Lookup("author"))
	viper.BindPFlag("useViper", rootCmd.PersistentFlags().Lookup("viper"))
	viper.SetDefault("author", "NAME HERE <EMAIL ADDRESS>")
	viper.SetDefault("license", "apache")

	rootCmd.AddCommand(addCmd)
	rootCmd.AddCommand(initCmd)
}

func initConfig() {
	if cfgFile != "" {
		// Use config file from the flag.
		viper.SetConfigFile(cfgFile)
	} else {
		// Find home directory.
		home, err := os.UserHomeDir()
		cobra.CheckErr(err)

		// Search config in home directory with name ".cobra" (without extension).
		viper.AddConfigPath(home)
		viper.SetConfigType("yaml")
		viper.SetConfigName(".cobra")
	}

	viper.AutomaticEnv()

	if err := viper.ReadInConfig(); err == nil {
		fmt.Println("Using config file:", viper.ConfigFileUsed())
	}
}
```

#### 创建你的 main.go

使用 root 命令，您需要让主函数执行它。为清楚起见，应在根目录上运行 Execute，尽管它可以在任何命令上调用。

在 Cobra 应用程序中，通常 main.go 文件非常简单。它有一个目的：初始化 Cobra。

```go
package main

import (
  "{pathToYourApp}/cmd"
)

func main() {
  cmd.Execute()
}
```

#### 创建附加命令

可以定义其他命令，通常每个命令在 cmd/ 目录中都有自己的文件。

如果你想创建一个版本命令，你可以创建 cmd/version.go 并用以下内容填充它：

```go
package cmd

import (
  "fmt"

  "github.com/spf13/cobra"
)

func init() {
  rootCmd.AddCommand(versionCmd)
}

var versionCmd = &cobra.Command{
  Use:   "version",
  Short: "Print the version number of Hugo",
  Long:  `All software has versions. This is Hugo's`,
  Run: func(cmd *cobra.Command, args []string) {
    fmt.Println("Hugo Static Site Generator v0.9 -- HEAD")
  },
}
```

#### 返回和处理错误

如果您希望向命令的调用者返回错误，`RunE`可以使用。

```
package cmd

import (
  "fmt"

  "github.com/spf13/cobra"
)

func init() {
  rootCmd.AddCommand(tryCmd)
}

var tryCmd = &cobra.Command{
  Use:   "try",
  Short: "Try and possibly fail at something",
  RunE: func(cmd *cobra.Command, args []string) error {
    if err := someFunc(); err != nil {
	return err
    }
    return nil
  },
}
```

然后可以在执行函数调用时捕获错误。

### 使用标志

标志提供修饰符来控制操作命令的操作方式。

#### 为命令分配标志

由于标志是在不同的位置定义和使用的，因此我们需要在外部定义一个具有正确范围的变量来分配要使用的标志。

```
var Verbose bool
var Source string
```

有两种不同的方法来分配标志。

#### 持久标志

标志可以是“持久的”，这意味着该标志将可用于分配给它的命令以及该命令下的每个命令。对于全局标志，将标志分配为根上的持久标志。

```
rootCmd.PersistentFlags().BoolVarP(&Verbose, "verbose", "v", false, "verbose output")
```

#### 本地标志

也可以在本地分配标志，这将仅适用于该特定命令。

```
localCmd.Flags().StringVarP(&Source, "source", "s", "", "Source directory to read from")
```

#### 父命令的本地标志

默认情况下，Cobra 仅解析目标命令上的本地标志，而忽略父命令上的任何本地标志。通过启用`Command.TraverseChildren`，Cobra 将在执行目标命令之前解析每个命令的本地标志。

```
command := cobra.Command{
  Use: "print [OPTIONS] [COMMANDS]",
  TraverseChildren: true,
}
```

#### 使用配置绑定标志

你也可以用[viper](https://github.com/spf13/viper)绑定你的标志：

```
var author string

func init() {
  rootCmd.PersistentFlags().StringVar(&author, "author", "YOUR NAME", "Author name for copyright attribution")
  viper.BindPFlag("author", rootCmd.PersistentFlags().Lookup("author"))
}
```

在此示例中，持久标志`author`与`viper`. **注意**：当用户提供标志时，变量`author`不会设置为配置中的值。`--author`

更多信息请参见[viper 文档](https://github.com/spf13/viper#working-with-flags)。

#### 必需的标志

默认情况下，标志是可选的。相反，如果您希望您的命令在未设置标志时报告错误，请将其标记为必需：

```
rootCmd.Flags().StringVarP(&Region, "region", "r", "", "AWS region (required)")
rootCmd.MarkFlagRequired("region")
```

或者，对于持久性标志：

```
rootCmd.PersistentFlags().StringVarP(&Region, "region", "r", "", "AWS region (required)")
rootCmd.MarkPersistentFlagRequired("region")
```

#### 标志组

如果你有不同的标志必须一起提供（例如，如果他们提供标志，他们也`--username`必须提供标志）那么 Cobra 可以强制执行该要求：`--password`

```
rootCmd.Flags().StringVarP(&u, "username", "u", "", "Username (required if password is set)")
rootCmd.Flags().StringVarP(&pw, "password", "p", "", "Password (required if username is set)")
rootCmd.MarkFlagsRequiredTogether("username", "password")
```

如果不同的标志代表相互排斥的选项，例如将输出格式指定为其中之一`--json`或`--yaml`但绝不是两者，您还可以防止一起提供不同的标志：

```
rootCmd.Flags().BoolVar(&ofJson, "json", false, "Output in JSON")
rootCmd.Flags().BoolVar(&ofYaml, "yaml", false, "Output in YAML")
rootCmd.MarkFlagsMutuallyExclusive("json", "yaml")
```

在这两种情况下：

- 本地和持久标志都可以使用
  - **注意：**该组仅对定义了每个标志的命令强制执行
- 一个标志可能出现在多个组中
- 一个组可以包含任意数量的标志

### 位置和自定义参数

可以使用 的`Args`字段指定位置参数的验证`Command`。内置了以下验证器：

- 参数数量：
  - `NoArgs`- 如果有任何位置参数则报告错误。
  - `ArbitraryArgs`- 接受任意数量的参数。
  - `MinimumNArgs(int)`- 如果提供的位置参数少于 N 个，则报告错误。
  - `MaximumNArgs(int)`- 如果提供了超过 N 个位置参数，则报告错误。
  - `ExactArgs(int)`- 如果不完全有 N 个位置参数，则报告错误。
  - `RangeArgs(min, max)`- 如果 args 的数量不在 和 之间，则报告`min`错误`max`。
- 论证内容：
  - `OnlyValidArgs``ValidArgs`- 如果在字段中没有指定任何位置参数，则报告错误`Command`，可以选择将其设置为位置参数的有效值列表。

如果`Args`是 undefined 或`nil`，则默认为`ArbitraryArgs`.

此外，`MatchAll(pargs ...PositionalArgs)`可以将现有检查与任意其他检查相结合。`ValidArgs`例如，如果你想在不正好有 N 个位置参数或者有任何位置参数不在的字段中时报错，`Command`你可以调用`MatchAll`and `ExactArgs`，`OnlyValidArgs`如下所示：

```
var cmd = &cobra.Command{
  Short: "hello",
  Args: cobra.MatchAll(cobra.ExactArgs(2), cobra.OnlyValidArgs),
  Run: func(cmd *cobra.Command, args []string) {
    fmt.Println("Hello, World!")
  },
}
```

可以设置任何满足`func(cmd *cobra.Command, args []string) error`. 例如：

```
var cmd = &cobra.Command{
  Short: "hello",
  Args: func(cmd *cobra.Command, args []string) error {
    // Optionally run one of the validators provided by cobra
    if err := cobra.MinimumNArgs(1)(cmd, args); err != nil {
        return err
    }
    // Run the custom validation logic
    if myapp.IsValidColor(args[0]) {
      return nil
    }
    return fmt.Errorf("invalid color specified: %s", args[0])
  },
  Run: func(cmd *cobra.Command, args []string) {
    fmt.Println("Hello, World!")
  },
}
```

### 例子

在下面的示例中，我们定义了三个命令。两个在顶层，一个 (cmdTimes) 是顶级命令之一的子级。在这种情况下，root 是不可执行的，这意味着需要一个子命令。这是通过不为“rootCmd”提供“运行”来实现的。

我们只为单个命令定义了一个标志。

有关标志的更多文档，请访问https://github.com/spf13/pflag

```
package main

import (
  "fmt"
  "strings"

  "github.com/spf13/cobra"
)

func main() {
  var echoTimes int

  var cmdPrint = &cobra.Command{
    Use:   "print [string to print]",
    Short: "Print anything to the screen",
    Long: `print is for printing anything back to the screen.
For many years people have printed back to the screen.`,
    Args: cobra.MinimumNArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
      fmt.Println("Print: " + strings.Join(args, " "))
    },
  }

  var cmdEcho = &cobra.Command{
    Use:   "echo [string to echo]",
    Short: "Echo anything to the screen",
    Long: `echo is for echoing anything back.
Echo works a lot like print, except it has a child command.`,
    Args: cobra.MinimumNArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
      fmt.Println("Echo: " + strings.Join(args, " "))
    },
  }

  var cmdTimes = &cobra.Command{
    Use:   "times [string to echo]",
    Short: "Echo anything to the screen more times",
    Long: `echo things multiple times back to the user by providing
a count and a string.`,
    Args: cobra.MinimumNArgs(1),
    Run: func(cmd *cobra.Command, args []string) {
      for i := 0; i < echoTimes; i++ {
        fmt.Println("Echo: " + strings.Join(args, " "))
      }
    },
  }

  cmdTimes.Flags().IntVarP(&echoTimes, "times", "t", 1, "times to echo the input")

  var rootCmd = &cobra.Command{Use: "app"}
  rootCmd.AddCommand(cmdPrint, cmdEcho)
  cmdEcho.AddCommand(cmdTimes)
  rootCmd.Execute()
}
```

有关更大应用程序的更完整示例，请查看[Hugo](https://gohugo.io/)。

### 帮助命令

当您有子命令时，Cobra 会自动向您的应用程序添加帮助命令。这将在用户运行“应用程序帮助”时调用。此外，帮助还将支持所有其他命令作为输入。比如说，你有一个名为“create”的命令，没有任何额外的配置；Cobra 将在调用“app help create”时工作。每个命令都会自动添加“--help”标志。

#### 例子

以下输出由 Cobra 自动生成。除了命令和标志定义之外，什么都不需要。

```
$ cobra-cli help

Cobra is a CLI library for Go that empowers applications.
This application is a tool to generate the needed files
to quickly create a Cobra application.

Usage:
  cobra-cli [command]

Available Commands:
  add         Add a command to a Cobra Application
  completion  Generate the autocompletion script for the specified shell
  help        Help about any command
  init        Initialize a Cobra Application

Flags:
  -a, --author string    author name for copyright attribution (default "YOUR NAME")
      --config string    config file (default is $HOME/.cobra.yaml)
  -h, --help             help for cobra-cli
  -l, --license string   name of license for the project
      --viper            use Viper for configuration

Use "cobra-cli [command] --help" for more information about a command.
```

帮助就像任何其他命令一样只是一个命令。它周围没有特殊的逻辑或行为。事实上，如果需要，您可以提供自己的。

#### 帮助中的分组命令

Cobra 支持在帮助输出中对可用命令进行分组。要对命令进行分组，必须使用`AddGroup()`父命令显式定义每个组。然后可以使用该子命令的元素将子命令添加到组中`GroupID`。这些组将以与使用对 的不同调用定义的顺序相同的顺序出现在帮助输出中`AddGroup()`。如果您使用生成的`help`或`completion`命令，您可以分别使用 `SetHelpCommandGroupId()`和`SetCompletionCommandGroupId()`在根命令上设置它们的组 ID。

#### 定义你自己的帮助

您可以为默认命令提供您自己的帮助命令或您自己的模板，以与以下功能一起使用：

```
cmd.SetHelpCommand(cmd *Command)
cmd.SetHelpFunc(f func(*Command, []string))
cmd.SetHelpTemplate(s string)
```

后两者也适用于任何子命令。

### 使用留言

当用户提供无效标志或无效命令时，Cobra 通过向用户显示“用法”来响应。

#### 例子

您可能会从上面的帮助中认识到这一点。这是因为默认帮助将用法作为其输出的一部分嵌入。

```
$ cobra-cli --invalid
Error: unknown flag: --invalid
Usage:
  cobra-cli [command]

Available Commands:
  add         Add a command to a Cobra Application
  completion  Generate the autocompletion script for the specified shell
  help        Help about any command
  init        Initialize a Cobra Application

Flags:
  -a, --author string    author name for copyright attribution (default "YOUR NAME")
      --config string    config file (default is $HOME/.cobra.yaml)
  -h, --help             help for cobra-cli
  -l, --license string   name of license for the project
      --viper            use Viper for configuration

Use "cobra [command] --help" for more information about a command.
```

#### 定义自己的用法

您可以提供自己的使用函数或模板供 Cobra 使用。像帮助一样，函数和模板可以通过公共方法覆盖：

```
cmd.SetUsageFunc(f func(*Command) error)
cmd.SetUsageTemplate(s string)
```

### 版本标志

如果在根命令上设置了 Version 字段，Cobra 会添加一个顶级“--version”标志。使用“--version”标志运行应用程序将使用版本模板将版本打印到标准输出。可以使用该 `cmd.SetVersionTemplate(s string)`功能自定义模板。

### PreRun 和 PostRun 挂钩

可以在`Run`命令的主要功能之前或之后运行功能。和功能将在之前执行`PersistentPreRun`。并将在 之后执行。如果他们不声明自己的功能，这些功能将由孩子继承。这些函数按以下顺序运行：`PreRun``Run``PersistentPostRun``PostRun``Run``Persistent*Run`

- `PersistentPreRun`
- `PreRun`
- `Run`
- `PostRun`
- `PersistentPostRun`

下面是使用所有这些功能的两个命令的示例。执行子命令时，它将运行根命令`PersistentPreRun`但不运行根命令`PersistentPostRun`：

```
package main

import (
  "fmt"

  "github.com/spf13/cobra"
)

func main() {

  var rootCmd = &cobra.Command{
    Use:   "root [sub]",
    Short: "My root command",
    PersistentPreRun: func(cmd *cobra.Command, args []string) {
      fmt.Printf("Inside rootCmd PersistentPreRun with args: %v\n", args)
    },
    PreRun: func(cmd *cobra.Command, args []string) {
      fmt.Printf("Inside rootCmd PreRun with args: %v\n", args)
    },
    Run: func(cmd *cobra.Command, args []string) {
      fmt.Printf("Inside rootCmd Run with args: %v\n", args)
    },
    PostRun: func(cmd *cobra.Command, args []string) {
      fmt.Printf("Inside rootCmd PostRun with args: %v\n", args)
    },
    PersistentPostRun: func(cmd *cobra.Command, args []string) {
      fmt.Printf("Inside rootCmd PersistentPostRun with args: %v\n", args)
    },
  }

  var subCmd = &cobra.Command{
    Use:   "sub [no options!]",
    Short: "My subcommand",
    PreRun: func(cmd *cobra.Command, args []string) {
      fmt.Printf("Inside subCmd PreRun with args: %v\n", args)
    },
    Run: func(cmd *cobra.Command, args []string) {
      fmt.Printf("Inside subCmd Run with args: %v\n", args)
    },
    PostRun: func(cmd *cobra.Command, args []string) {
      fmt.Printf("Inside subCmd PostRun with args: %v\n", args)
    },
    PersistentPostRun: func(cmd *cobra.Command, args []string) {
      fmt.Printf("Inside subCmd PersistentPostRun with args: %v\n", args)
    },
  }

  rootCmd.AddCommand(subCmd)

  rootCmd.SetArgs([]string{""})
  rootCmd.Execute()
  fmt.Println()
  rootCmd.SetArgs([]string{"sub", "arg1", "arg2"})
  rootCmd.Execute()
}
```

输出：

```
Inside rootCmd PersistentPreRun with args: []
Inside rootCmd PreRun with args: []
Inside rootCmd Run with args: []
Inside rootCmd PostRun with args: []
Inside rootCmd PersistentPostRun with args: []

Inside rootCmd PersistentPreRun with args: [arg1 arg2]
Inside subCmd PreRun with args: [arg1 arg2]
Inside subCmd Run with args: [arg1 arg2]
Inside subCmd PostRun with args: [arg1 arg2]
Inside subCmd PersistentPostRun with args: [arg1 arg2]
```

### 发生“未知命令”时的建议

当“未知命令”错误发生时，Cobra 将打印自动建议。`git`这允许 Cobra在发生拼写错误时表现得与命令相似。例如：

```
$ hugo srever
Error: unknown command "srever" for "hugo"

Did you mean this?
        server

Run 'hugo --help' for usage.
```

建议是根据现有子命令自动生成的，并使用[Levenshtein distance](https://en.wikipedia.org/wiki/Levenshtein_distance)的实现。每个匹配最小距离 2（忽略大小写）的注册命令都将显示为建议。

如果您需要禁用建议或调整命令中的字符串距离，请使用：

```
command.DisableSuggestions = true
```

或者

```
command.SuggestionsMinimumDistance = 1
```

您还可以使用该`SuggestFor`属性显式设置建议给定命令的名称。这允许对字符串距离的建议，这些字符串在字符串距离方面不接近，但在您的命令集中有意义但您不想要别名。例子：

```
$ kubectl remove
Error: unknown command "remove" for "kubectl"

Did you mean this?
        delete

Run 'kubectl help' for usage.
```

### 为您的命令生成文档

Cobra 可以根据子命令、标志等生成文档。在[文档生成文档](https://github.com/spf13/cobra/blob/main/doc/README.md)中阅读更多相关信息。

### 生成 shell 补全

Cobra 可以为以下 shell 生成 shell 完成文件：bash、zsh、fish、PowerShell。如果您向命令添加更多信息，这些补全功能会非常强大和灵活。[在Shell Completions](https://github.com/spf13/cobra/blob/main/shell_completions.md)中阅读更多相关信息。

### 提供积极帮助

Cobra 使用 shell 完成系统来定义一个框架，允许您向用户提供主动帮助。活动帮助是在使用程序时打印的消息（提示、警告等）。[在Active Help](https://github.com/spf13/cobra/blob/main/active_help.md)中阅读更多相关信息。

## 学习

### 为命令添加一个选项

```go
var versionCmd = &cobra.Command{
	Use:   "version",
	Short: "版本信息",
	Long:  `关于版本的长信息`,
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("0.0.1")
		author, err := cmd.Flags().GetString("author")

		if err != nil {
			fmt.Println("请输入正确的作者信息")
			return
		}
		fmt.Println("作者是：", author)
	},
}
```

添加 version 信息，使用 stringP 函数添加string 类型的选项

```go
func init() {
	rootCmd.AddCommand(versionCmd)

	versionCmd.Flags().StringP("author", "a", "绿巨人", "作者名称")
}
```



```go
// StringP is like String, but accepts a shorthand letter that can be used after a single dash.
func StringP(name, shorthand string, value string, usage string) *string {
	return CommandLine.StringP(name, shorthand, value, usage)
}
```

### 选项的接受与处理

#### 为 Command 添加选项(flags)

选项(flags)用来控制 Command 的具体行为。根据选项的作用范围，可以把选项分为两类：persistent和local
对于 persistent 类型的选项，既可以设置给该 Command，又可以设置给该 Command 的子 Command。对于一些全局性的选项，比较适合设置为 persistent 类型，比如控制输出的 verbose 选项：

```go
var Verbose bool
rootCmd.PersistentFlags().BoolVarP(&Verbose, "verbose", "v", false, "verbose output")
12
```

local 类型的选项只能设置给指定的 Command，比如下面定义的 source 选项：

```go
var Source string
rootCmd.Flags().StringVarP(&Source, "source", "s", "", "Source directory to read from")
12
```

该选项不能指定给 rootCmd 之外的其它 Command。
默认情况下的选项都是可选的，但一些用例要求用户必须设置某些选项，这种情况 cobra 也是支持的，通过 Command 的 MarkFlagRequired 方法标记该选项即可：

```go
var Name string
rootCmd.Flags().StringVarP(&Name, "name", "n", "", "user name (required)")
rootCmd.MarkFlagRequired("name")
```



# ini库

Package ini provides INI file read and write functionality in Go.

在 ini 文件中，每个键值对占用一行，中间使用`=`隔开。以`#`开头的内容为注释。ini 文件是以分区（section）组织的。 分区以`[name]`开始，在下一个分区前结束。所有分区前的内容属于默认分区，如`my.ini`文件中的`app_name`和`log_level`。

使用`go-ini`读取配置文件的步骤如下：

- 首先调用`ini.Load`加载文件，得到配置对象`cfg`；
- 然后以分区名调用配置对象的`Section`方法得到对应的分区对象`section`，默认分区的名字为`""`，也可以使用`ini.DefaultSection`；
- 以键名调用分区对象的`Key`方法得到对应的配置项`key`对象；
- 由于文件中读取出来的都是字符串，`key`对象需根据类型调用对应的方法返回具体类型的值使用，如上面的`String`、`MustInt`方法。

## Installation

The minimum requirement of Go is **1.13**.

```
$ go get gopkg.in/ini.v1
```

Please add `-u` flag to update in the future.

## 从数据源加载

就像之前说的，从多个数据源加载配置是基本操作。

那么，到底什么是 **数据源** 呢？

一个 **数据源** 可以是 `[]byte` 类型的原始数据，`string` 类型的文件路径或 `io.ReadCloser`。您可以加载 **任意多个** 数据源。如果您传递其它类型的数据源，则会直接返回错误。

```go
cfg, err := ini.Load(
    []byte("raw data"), // 原始数据
    "filename",         // 文件路径
    ioutil.NopCloser(bytes.NewReader([]byte("some other data"))),
)
```

或者从一个空白的文件开始：

```go
cfg := ini.Empty()
```

当您在一开始无法决定需要加载哪些数据源时，仍可以使用 [Append()](https://gowalker.org/gopkg.in/ini.v1#File_Append) 在需要的时候加载它们。

```go
err := cfg.Append("other file", []byte("other raw data"))
```

当您想要加载一系列文件，但是不能够确定其中哪些文件是不存在的，可以通过调用函数 [LooseLoad()](https://gowalker.org/gopkg.in/ini.v1#LooseLoad) 来忽略它们。

```go
cfg, err := ini.LooseLoad("filename", "filename_404")
```

更牛逼的是，当那些之前不存在的文件在重新调用 [Reload()](https://gowalker.org/gopkg.in/ini.v1#File_Reload) 方法的时候突然出现了，那么它们会被正常加载。

### 数据覆写

在加载多个数据源时，如果某一个键在一个或多个数据源中出现，则会出现数据覆写。该键从前一个数据源读取的值会被下一个数据源覆写。

举例来说，如果加载两个配置文件 `my.ini` 和 `my.ini.local`（[ 开始使用](https://ini.unknwon.io/docs/intro/getting_started) 中的输入和输出文件），`app_mode` 的值会是 `production` 而不是 `development`。

```go
cfg, err := ini.Load("my.ini", "my.ini.local")
...

cfg.Section("").Key("app_mode").String() // production
```

数据覆写只有在一种情况下不会触发，即使用 [ShadowLoad](https://ini.unknwon.io/docs/howto/work_with_keys#same-key-with-multiple-values) 加载数据源。

### 跳过无法识别的数据行

某些情况下，您的配置文件可能包含非键值对的数据行，解析器默认会报错并终止解析。如果您希望解析器能够忽略并它们完成剩余内容的解析，则可以通过如下方法实现：

```go
cfg, err := ini.LoadSources(ini.LoadOptions{
    SkipUnrecognizableLines: true,
}, "other.ini")
```

### 留意非法数值

配置文件中存储的都是字符串，所以类型为字符串的配置项不会出现类型转换失败的，故`String()`方法只返回一个值。 但如果类型为`Int/Uint/Float64`这些时，转换可能失败。所以`Int()/Uint()/Float64()`返回一个值和一个错误。

要留意这种不一致！如果我们将配置中 redis 端口改成非法的数字 x6381，那么运行程序将报错：

```
2020/01/14 22:43:13 strconv.ParseInt: parsing "x6381": invalid syntax
```



### 保存配置

终于到了这个时刻，是时候保存一下配置了。

比较原始的做法是输出配置到某个文件：

```go
// ...
err = cfg.SaveTo("my.ini")
err = cfg.SaveToIndent("my.ini", "\t")
```

另一个比较高级的做法是写入到任何实现 `io.Writer` 接口的对象中：

```go
// ...
cfg.WriteTo(writer)
cfg.WriteToIndent(writer, "\t")
```

下面我们通过程序生成前面使用的配置文件`my.ini`并保存：

```
package main

import (
  "fmt"
  "os"

  "gopkg.in/ini.v1"
)

func main() {
  cfg := ini.Empty()

  defaultSection := cfg.Section("")
  defaultSection.NewKey("app_name", "awesome web")
  defaultSection.NewKey("log_level", "DEBUG")

  mysqlSection, err := cfg.NewSection("mysql")
  if err != nil {
    fmt.Println("new mysql section failed:", err)
    return
  }
  mysqlSection.NewKey("ip", "127.0.0.1")
  mysqlSection.NewKey("port", "3306")
  mysqlSection.NewKey("user", "root")
  mysqlSection.NewKey("password", "123456")
  mysqlSection.NewKey("database", "awesome")

  redisSection, err := cfg.NewSection("redis")
  if err != nil {
    fmt.Println("new redis section failed:", err)
    return
  }
  redisSection.NewKey("ip", "127.0.0.1")
  redisSection.NewKey("port", "6381")

  err = cfg.SaveTo("my.ini")
  if err != nil {
    fmt.Println("SaveTo failed: ", err)
  }

  err = cfg.SaveToIndent("my-pretty.ini", "\t")
  if err != nil {
    fmt.Println("SaveToIndent failed: ", err)
  }

  cfg.WriteTo(os.Stdout)
  fmt.Println()
  cfg.WriteToIndent(os.Stdout, "\t")
}
```

运行程序，生成两个文件`my.ini`和`my-pretty.ini`，同时控制台输出文件内容。

`my.ini`：

```
app_name  = awesome web
log_level = DEBUG

[mysql]
ip       = 127.0.0.1
port     = 3306
user     = root
password = 123456
database = awesome

[redis]
ip   = 127.0.0.1
port = 6381
```

`my-pretty.ini`：

```
app_name  = awesome web
log_level = DEBUG

[mysql]
	ip       = 127.0.0.1
	port     = 3306
	user     = root
	password = 123456
	database = awesome

[redis]
	ip   = 127.0.0.1
	port = 6381
```

`XXXIndent`方法会对子分区下的键增加缩进，看起来美观一点。

默认情况下，空格将被用于对齐键值之间的等号以美化输出结果，以下代码可以禁用该功能：

```go
ini.PrettyFormat = false
```

## 操作分区（Section）

获取指定分区：

```go
sec, err := cfg.GetSection("section name")
```

如果您想要获取默认分区，则可以用空字符串代替分区名：

```go
sec, err := cfg.GetSection("")
```

相对应的，还可以使用 `ini.DEFAULT_SECTION` 来获取默认分区：

```go
sec, err := cfg.GetSection(ini.DEFAULT_SECTION)
```

当您非常确定某个分区是存在的，可以使用以下简便方法：

```go
sec := cfg.Section("section name")
```

如果不小心判断错了，要获取的分区其实是不存在的，那会发生什么呢？没事的，它会自动创建并返回一个对应的分区对象给您。

创建一个分区：

```go
err := cfg.NewSection("new section")
```

获取所有分区对象或名称：

```go
secs := cfg.Sections()
names := cfg.SectionStrings()
```

### 读取父子分区

在配置文件中，可以使用占位符`%(name)s`表示用之前已定义的键`name`的值来替换，这里的`s`表示值为字符串类型

```ini
NAME = ini
VERSION = v1
IMPORT_PATH = gopkg.in/%(NAME)s.%(VERSION)s

[package]
CLONE_URL = https://%(IMPORT_PATH)s

[package.sub]
cfg.Section("package.sub").Key("CLONE_URL").String()    // https://gopkg.in/ini.v1
```

上面在默认分区中设置`IMPORT_PATH`的值时，使用了前面定义的`NAME`和`VERSION`。 在`package`分区中设置`CLONE_URL`的值时，使用了默认分区中定义的`IMPORT_PATH`。

我们还可以在分区名中使用`.`表示两个或多个分区之间的父子关系，例如`package.sub`的父分区为`package`，`package`的父分区为默认分区。 如果某个键在子分区中不存在，则会在它的父分区中再次查找，直到没有父分区为止：

```go
cfg, err := ini.Load("parent_child.ini")
if err != nil {
  fmt.Println("Fail to read file: ", err)
  return
}

fmt.Println("Clone url from package.sub:", cfg.Section("package.sub").Key("CLONE_URL").String())
```

输出：

```
Clone url from package.sub: https://gopkg.in/ini.v1
```

子分区中`package.sub`中没有键`CLONE_URL`，返回了父分区`package`中的值。

### 无法解析的分区

如果遇到一些比较特殊的分区，它们不包含常见的键值对，而是没有固定格式的纯文本，则可以使用 `LoadOptions.UnparsableSections` 进行处理：

```go
cfg, err := ini.LoadSources(ini.LoadOptions{
    UnparseableSections: []string{"COMMENTS"},
}, `[COMMENTS]
<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>`)

body := cfg.Section("COMMENTS").Body()

/* --- start ---
<1><L.Slide#2> This slide has the fuel listed in the wrong units <e.1>
------  end  --- */
```

## 操作键（Key）

获取某个分区下的键：

```go
key, err := cfg.Section("").GetKey("key name")
```

和分区一样，您也可以直接获取键而忽略错误处理：

```go
key := cfg.Section("").Key("key name")
```

判断某个键是否存在：

```go
yes := cfg.Section("").HasKey("key name")
```

创建一个新的键：

```go
err := cfg.Section("").NewKey("name", "value")
```

获取分区下的所有键或键名：

```go
keys := cfg.Section("").Keys()
names := cfg.Section("").KeyStrings()
```

获取分区下的所有键值对的克隆：

```go
hash := cfg.Section("").KeysHash()
```

#### 忽略键名的大小写

有时候分区和键的名称大小写混合非常烦人，这个时候就可以通过 [InsensitiveLoad](https://gowalker.org/gopkg.in/ini.v1#InsensitiveLoad) 将所有分区和键名在读取里强制转换为小写：

```go
cfg, err := ini.InsensitiveLoad("filename")
//...

// sec1 和 sec2 指向同一个分区对象
sec1, err := cfg.GetSection("Section")
sec2, err := cfg.GetSection("SecTIOn")

// key1 和 key2 指向同一个键对象
key1, err := sec1.GetKey("Key")
key2, err := sec2.GetKey("KeY")
```

#### 类似 MySQL 配置中的布尔值键

MySQL 的配置文件中会出现没有具体值的布尔类型的键：

```ini
[mysqld]
...
skip-host-cache
skip-name-resolve
```

默认情况下这被认为是缺失值而无法完成解析，但可以通过高级的加载选项对它们进行处理：

```go
cfg, err := ini.LoadSources(ini.LoadOptions{
    AllowBooleanKeys: true,
}, "my.cnf")
```

这些键的值永远为 `true`，且在保存到文件时也只会输出键名。

如果您想要通过程序来生成此类键，则可以使用 `NewBooleanKey`：

```go
key, err := sec.NewBooleanKey("skip-host-cache")
```

### 同个键名包含多个值

你是否也曾被下面的配置文件所困扰？

```ini
[remote "origin"]
url = https://github.com/Antergone/test1.git
url = https://github.com/Antergone/test2.git
fetch = +refs/heads/*:refs/remotes/origin/*
```

没错！默认情况下，只有最后一次出现的值会被保存到 `url` 中，可我就是想要保留所有的值怎么办啊？不要紧，用 [ShadowLoad](https://gowalker.org/gopkg.in/ini.v1#ShadowLoad) 轻松解决你的烦恼：

```go
cfg, err := ini.ShadowLoad(".gitconfig")
// ...

f.Section(`remote "origin"`).Key("url").String() 
// Result: https://github.com/Antergone/test1.git

f.Section(`remote "origin"`).Key("url").ValueWithShadows()
// Result:  []string{
//              "https://github.com/Antergone/test1.git",
//              "https://github.com/Antergone/test2.git",
//          }
```

### 读取自增键名

如果数据源中的键名为 `-`，则认为该键使用了自增键名的特殊语法。计数器从 1 开始，并且分区之间是相互独立的。

```ini
[features]
-: Support read/write comments of keys and sections
-: Support auto-increment of key names
-: Support load multiple files to overwrite key values
cfg.Section("features").KeyStrings()    // []{"#1", "#2", "#3"}
```

### 获取上级父分区下的所有键名

```go
cfg.Section("package.sub").ParentKeys() // ["CLONE_URL"]
```

## 操作键值（Value）

获取一个类型为字符串（string）的值：

```go
val := cfg.Section("").Key("key name").String()
```

获取值的同时通过自定义函数进行处理验证：

```go
val := cfg.Section("").Key("key name").Validate(func(in string) string {
    if len(in) == 0 {
        return "default"
    }
    return in
})
```

如果您不需要任何对值的自动转变功能（例如递归读取），可以直接获取原值（这种方式性能最佳）：

```go
val := cfg.Section("").Key("key name").Value()
```

判断某个原值是否存在：

```go
yes := cfg.Section("").HasValue("test value")
```

获取其它类型的值：

```go
// 布尔值的规则：
// true 当值为：1, t, T, TRUE, true, True, YES, yes, Yes, y, ON, on, On
// false 当值为：0, f, F, FALSE, false, False, NO, no, No, n, OFF, off, Off
v, err = cfg.Section("").Key("BOOL").Bool()
v, err = cfg.Section("").Key("FLOAT64").Float64()
v, err = cfg.Section("").Key("INT").Int()
v, err = cfg.Section("").Key("INT64").Int64()
v, err = cfg.Section("").Key("UINT").Uint()
v, err = cfg.Section("").Key("UINT64").Uint64()
v, err = cfg.Section("").Key("TIME").TimeFormat(time.RFC3339)
v, err = cfg.Section("").Key("TIME").Time() // RFC3339

v = cfg.Section("").Key("BOOL").MustBool()
v = cfg.Section("").Key("FLOAT64").MustFloat64()
v = cfg.Section("").Key("INT").MustInt()
v = cfg.Section("").Key("INT64").MustInt64()
v = cfg.Section("").Key("UINT").MustUint()
v = cfg.Section("").Key("UINT64").MustUint64()
v = cfg.Section("").Key("TIME").MustTimeFormat(time.RFC3339)
v = cfg.Section("").Key("TIME").MustTime() // RFC3339

// 由 Must 开头的方法名允许接收一个相同类型的参数来作为默认值，
// 当键不存在或者转换失败时，则会直接返回该默认值。
// 但是，MustString 方法必须传递一个默认值。

v = cfg.Section("").Key("String").MustString("default")
v = cfg.Section("").Key("BOOL").MustBool(true)
v = cfg.Section("").Key("FLOAT64").MustFloat64(1.25)
v = cfg.Section("").Key("INT").MustInt(10)
v = cfg.Section("").Key("INT64").MustInt64(99)
v = cfg.Section("").Key("UINT").MustUint(3)
v = cfg.Section("").Key("UINT64").MustUint64(6)
v = cfg.Section("").Key("TIME").MustTimeFormat(time.RFC3339, time.Now())
v = cfg.Section("").Key("TIME").MustTime(time.Now()) // RFC3339
```

如果我的值有好多行怎么办？

```ini
[advance]
ADDRESS = """404 road,
NotFound, State, 5000
Earth"""
```

嗯哼？小 case！

```go
cfg.Section("advance").Key("ADDRESS").String()

/* --- start ---
404 road,
NotFound, State, 5000
Earth
------  end  --- */
```

赞爆了！那要是我属于一行的内容写不下想要写到第二行怎么办？

```ini
[advance]
two_lines = how about \
    continuation lines?
lots_of_lines = 1 \
    2 \
    3 \
    4
```

简直是小菜一碟！

```go
cfg.Section("advance").Key("two_lines").String() // how about continuation lines?
cfg.Section("advance").Key("lots_of_lines").String() // 1 2 3 4
```

可是我有时候觉得两行连在一起特别没劲，怎么才能不自动连接两行呢？

```go
cfg, err := ini.LoadSources(ini.LoadOptions{
    IgnoreContinuation: true,
}, "filename")
```

哇靠给力啊！

需要注意的是，值两侧的单引号会被自动剔除：

```ini
foo = "some value" // foo: some value
bar = 'some value' // bar: some value
```

有时您会获得像从 [Crowdin](https://crowdin.com/) 网站下载的文件那样具有特殊格式的值（值使用双引号括起来，内部的双引号被转义）：

```ini
create_repo="created repository <a href=\"%s\">%s</a>"
```

那么，怎么自动地将这类值进行处理呢？

```go
cfg, err := ini.LoadSources(ini.LoadOptions{UnescapeValueDoubleQuotes: true}, "en-US.ini"))
cfg.Section("<name of your section>").Key("create_repo").String()
// You got: created repository <a href="%s">%s</a>
```

这就是全部了？哈哈，当然不是。

#### 操作键值的辅助方法

获取键值时设定候选值：

```go
v = cfg.Section("").Key("STRING").In("default", []string{"str", "arr", "types"})
v = cfg.Section("").Key("FLOAT64").InFloat64(1.1, []float64{1.25, 2.5, 3.75})
v = cfg.Section("").Key("INT").InInt(5, []int{10, 20, 30})
v = cfg.Section("").Key("INT64").InInt64(10, []int64{10, 20, 30})
v = cfg.Section("").Key("UINT").InUint(4, []int{3, 6, 9})
v = cfg.Section("").Key("UINT64").InUint64(8, []int64{3, 6, 9})
v = cfg.Section("").Key("TIME").InTimeFormat(time.RFC3339, time.Now(), []time.Time{time1, time2, time3})
v = cfg.Section("").Key("TIME").InTime(time.Now(), []time.Time{time1, time2, time3}) // RFC3339
```

如果获取到的值不是候选值的任意一个，则会返回默认值，而默认值不需要是候选值中的一员。

验证获取的值是否在指定范围内：

```go
vals = cfg.Section("").Key("FLOAT64").RangeFloat64(0.0, 1.1, 2.2)
vals = cfg.Section("").Key("INT").RangeInt(0, 10, 20)
vals = cfg.Section("").Key("INT64").RangeInt64(0, 10, 20)
vals = cfg.Section("").Key("UINT").RangeUint(0, 3, 9)
vals = cfg.Section("").Key("UINT64").RangeUint64(0, 3, 9)
vals = cfg.Section("").Key("TIME").RangeTimeFormat(time.RFC3339, time.Now(), minTime, maxTime)
vals = cfg.Section("").Key("TIME").RangeTime(time.Now(), minTime, maxTime) // RFC3339
```

##### 自动分割键值到切片（slice）

当存在无效输入时，使用零值代替：

```go
// Input: 1.1, 2.2, 3.3, 4.4 -> [1.1 2.2 3.3 4.4]
// Input: how, 2.2, are, you -> [0.0 2.2 0.0 0.0]
vals = cfg.Section("").Key("STRINGS").Strings(",")
vals = cfg.Section("").Key("FLOAT64S").Float64s(",")
vals = cfg.Section("").Key("INTS").Ints(",")
vals = cfg.Section("").Key("INT64S").Int64s(",")
vals = cfg.Section("").Key("UINTS").Uints(",")
vals = cfg.Section("").Key("UINT64S").Uint64s(",")
vals = cfg.Section("").Key("TIMES").Times(",")
```

从结果切片中剔除无效输入：

```go
// Input: 1.1, 2.2, 3.3, 4.4 -> [1.1 2.2 3.3 4.4]
// Input: how, 2.2, are, you -> [2.2]
vals = cfg.Section("").Key("FLOAT64S").ValidFloat64s(",")
vals = cfg.Section("").Key("INTS").ValidInts(",")
vals = cfg.Section("").Key("INT64S").ValidInt64s(",")
vals = cfg.Section("").Key("UINTS").ValidUints(",")
vals = cfg.Section("").Key("UINT64S").ValidUint64s(",")
vals = cfg.Section("").Key("TIMES").ValidTimes(",")
```

当存在无效输入时，直接返回错误：

```go
// Input: 1.1, 2.2, 3.3, 4.4 -> [1.1 2.2 3.3 4.4]
// Input: how, 2.2, are, you -> error
vals = cfg.Section("").Key("FLOAT64S").StrictFloat64s(",")
vals = cfg.Section("").Key("INTS").StrictInts(",")
vals = cfg.Section("").Key("INT64S").StrictInt64s(",")
vals = cfg.Section("").Key("UINTS").StrictUints(",")
vals = cfg.Section("").Key("UINT64S").StrictUint64s(",")
vals = cfg.Section("").Key("TIMES").StrictTimes(",")
```

### 递归读取键值

在获取所有键值的过程中，特殊语法 `%(<name>)s` 会被应用，其中 `<name>` 可以是相同分区或者默认分区下的键名。字符串 `%(<name>)s` 会被相应的键值所替代，如果指定的键不存在，则会用空字符串替代。您可以最多使用 99 层的递归嵌套。

```ini
NAME = ini

[author]
NAME = Unknwon
GITHUB = https://github.com/%(NAME)s

[package]
FULL_NAME = github.com/go-ini/%(NAME)s
cfg.Section("author").Key("GITHUB").String()        // https://github.com/Unknwon
cfg.Section("package").Key("FULL_NAME").String()    // github.com/go-ini/ini
```

### `Must*`便捷方法

如果每次取值都需要进行错误判断，那么代码写起来会非常繁琐。为此，`go-ini`也提供对应的`MustType`（Type 为`Init/Uint/Float64`等）方法，这个方法只返回一个值。 同时它接受可变参数，如果类型无法转换，取参数中第一个值返回，并且该参数设置为这个配置的值，下次调用返回这个值：

```go
package main

import (
  "fmt"
  "log"

  "gopkg.in/ini.v1"
)

func main() {
  cfg, err := ini.Load("my.ini")
  if err != nil {
    log.Fatal("Fail to read file: ", err)
  }

  redisPort, err := cfg.Section("redis").Key("port").Int()
  if err != nil {
    fmt.Println("before must, get redis port error:", err)
  } else {
    fmt.Println("before must, get redis port:", redisPort)
  }

  fmt.Println("redis Port:", cfg.Section("redis").Key("port").MustInt(6381))

  redisPort, err = cfg.Section("redis").Key("port").Int()
  if err != nil {
    fmt.Println("after must, get redis port error:", err)
  } else {
    fmt.Println("after must, get redis port:", redisPort)
  }
}
```

配置文件还是 redis 端口为非数字 x6381 时的状态，运行程序：

```
before must, get redis port error: strconv.ParseInt: parsing "x6381": invalid syntax
redis Port: 6381
after must, get redis port: 6381
```

我们看到第一次调用`Int`返回错误，以 6381 为参数调用`MustInt`之后，再次调用`Int`，成功返回 6381。`MustInt`源码也比较简单：

```
// gopkg.in/ini.v1/key.go
func (k *Key) MustInt(defaultVal ...int) int {
  val, err := k.Int()
  if len(defaultVal) > 0 && err != nil {
    k.value = strconv.FormatInt(int64(defaultVal[0]), 10)
    return defaultVal[0]
  }
  return val
}
```



### Python 多行值

如果您刚将服务从 Python 迁移过来，可能会遇到一些使用旧语法的配置文件，别慌！

```go
cfg, err := ini.LoadSources(ini.LoadOptions{
    AllowPythonMultilineValues: true,
}, []byte(`
[long]
long_rsa_private_key = -----BEGIN RSA PRIVATE KEY-----
   foo
   bar
   foobar
   barfoo
   -----END RSA PRIVATE KEY-----
`)

/*
-----BEGIN RSA PRIVATE KEY-----
foo
bar
foobar
barfoo 
-----END RSA PRIVATE KEY-----
*/
```

## 操作注释（Comment）

下述几种情况的内容将被视为注释：

1. 所有以 `#` 或 `;` 开头的行
2. 所有在 `#` 或 `;` 之后的内容
3. 分区标签后的文字 (即 `[分区名]` 之后的内容)

如果你希望使用包含 `#` 或 `;` 的值，请使用 ``` 或 `"""` 进行包覆。

除此之外，您还可以通过 [LoadOptions](https://gowalker.org/gopkg.in/ini.v1#LoadOptions) 完全忽略行内注释：

```go
cfg, err := ini.LoadSources(ini.LoadOptions{
    IgnoreInlineComment: true,
}, "app.ini")
```

或要求注释符号前必须带有一个空格：

```go
cfg, err := ini.LoadSources(ini.LoadOptions{
    SpaceBeforeInlineComment: true,
}, "app.ini")
```

## 结构体与分区双向映射

### 映射到结构

定义结构变量，加载完配置文件后，调用`MapTo`将配置项赋值到结构变量的对应字段中。

```go
package main

import (
  "fmt"

  "gopkg.in/ini.v1"
)

type Config struct {
  AppName   string `ini:"app_name"`
  LogLevel  string `ini:"log_level"`

  MySQL     MySQLConfig `ini:"mysql"`
  Redis     RedisConfig `ini:"redis"`
}

type MySQLConfig struct {
  IP        string `ini:"ip"`
  Port      int `ini:"port"`
  User      string `ini:"user"`
  Password  string `ini:"password"`
  Database  string `ini:"database"`
}

type RedisConfig struct {
  IP      string `ini:"ip"`
  Port    int `ini:"port"`
}

func main() {
  cfg, err := ini.Load("my.ini")
  if err != nil {
    fmt.Println("load my.ini failed: ", err)
  }

  c := Config{}
  cfg.MapTo(&c)

  fmt.Println(c)
}
```

`MapTo`内部使用了反射，**所以结构体字段必须都是导出的**。如果键名与字段名不相同，那么需要在结构标签中指定对应的键名。 这一点与 Go 标准库`encoding/json`和`encoding/xml`不同。标准库`json/xml`解析时可以将键名`app_name`对应到字段名`AppName`。 或许这是`go-ini`库可以优化的点？

先加载，再映射有点繁琐，直接使用`ini.MapTo`将两步合并：

```go
err = ini.MapTo(&c, "my.ini")
```

也可以只映射一个分区：

```go
mysqlCfg := MySQLConfig{}
err = cfg.Section("mysql").MapTo(&mysqlCfg)
```

还可以通过结构体生成配置：

```go
cfg := ini.Empty()

c := Config {
  AppName: 	"awesome web",
  LogLevel: 	"DEBUG",
  MySQL: MySQLConfig {
    IP: 	"127.0.0.1",
    Port:	3306,
    User:	"root",
    Password:"123456",
    Database:"awesome",
  },
  Redis: RedisConfig {
    IP:		"127.0.0.1",
    Port:	6381,
  },
}

err := ini.ReflectFrom(cfg, &c)
if err != nil {
  fmt.Println("ReflectFrom failed: ", err)
  return
}

err = cfg.SaveTo("my-copy.ini")
if err != nil {
  fmt.Println("SaveTo failed: ", err)
  return
}
```

### 从结构反射

```go
type Embeded struct {
    Dates  []time.Time `delim:"|" comment:"Time data"`
    Places []string    `ini:"places,omitempty"`
    None   []int       `ini:",omitempty"`
}

type Author struct {
    Name      string `ini:"NAME"`
    Male      bool
    Age       int `comment:"Author's age"`
    GPA       float64
    NeverMind string `ini:"-"`
    *Embeded `comment:"Embeded section"`
}

func main() {
    a := &Author{"Unknwon", true, 21, 2.8, "",
        &Embeded{
            []time.Time{time.Now(), time.Now()},
            []string{"HangZhou", "Boston"},
            []int{},
        }}
    cfg := ini.Empty()
    err = ini.ReflectFrom(cfg, a)
    // ...
}
```

瞧瞧，奇迹发生了。

```ini
NAME = Unknwon
Male = true
; Author's age
Age = 21
GPA = 2.8

; Embeded section
[Embeded]
; Time data
Dates = 2015-08-07T22:14:22+08:00|2015-08-07T22:14:22+08:00
places = HangZhou,Boston
```

### 配合 ShadowLoad 进行映射

如果您希望配合 [ShadowLoad](https://ini.unknwon.io/docs/howto/work_with_keys#same-key-with-multiple-values) 将某个分区映射到结构体，则需要指定 `allowshadow` 标签。

假设您有以下配置文件：

```ini
[IP]
value = 192.168.31.201
value = 192.168.31.211
value = 192.168.31.221
```

您应当通过如下方式定义对应的结构体：

```go
type IP struct {
   Value    []string `ini:"value,omitempty,allowshadow"`
}
```

如果您不需要前两个标签规则，可以使用 `ini:",,allowshadow"` 进行简写。

### 映射/反射的其它说明

任何嵌入的结构都会被默认认作一个不同的分区，并且不会自动产生所谓的父子分区关联：

```go
type Child struct {
    Age string
}

type Parent struct {
    Name string
    Child
}

type Config struct {
    City string
    Parent
}
```

示例配置文件：

```ini
City = Boston

[Parent]
Name = Unknwon

[Child]
Age = 21
```

很好，但是，我就是要嵌入结构也在同一个分区。好吧，你爹是李刚！

```go
type Child struct {
    Age string
}

type Parent struct {
    Name string
    Child `ini:"Parent"`
}

type Config struct {
    City string
    Parent
}
```

示例配置文件：

```ini
City = Boston

[Parent]
Name = Unknwon
Age = 21
```

另请查看 [ 自定义键名和键值映射器](https://ini.unknwon.io/docs/advanced/name_and_value_mapper) 的有关用法。

## 自定义键名和键值映射器

### 键名映射器（Name Mapper）

为了节省您的时间并简化代码，本库支持类型为 [`NameMapper`](https://gowalker.org/gopkg.in/ini.v1#NameMapper) 的名称映射器，该映射器负责结构字段名与分区名和键名之间的映射。

目前有 2 款内置的映射器：

- `AllCapsUnderscore`：该映射器将字段名转换至格式 `ALL_CAPS_UNDERSCORE` 后再去匹配分区名和键名。
- `TitleUnderscore`：该映射器将字段名转换至格式 `title_underscore` 后再去匹配分区名和键名。

使用方法：

```go
type Info struct {
    PackageName string
}

func main() {
    err = ini.MapToWithMapper(&Info{}, ini.TitleUnderscore, []byte("package_name=ini"))
    // ...

    cfg, err := ini.Load([]byte("PACKAGE_NAME=ini"))
    // ...
    info := new(Info)
    cfg.NameMapper = ini.AllCapsUnderscore
    err = cfg.MapTo(info)
    // ...
}
```

使用函数 `ini.ReflectFromWithMapper` 时也可应用相同的规则。

### 键值映射器（Value Mapper）

值映射器允许使用一个自定义函数自动展开值的具体内容，例如在运行时获取环境变量：

```go
type Env struct {
    Foo string `ini:"foo"`
}

func main() {
    cfg, err := ini.Load([]byte("[env]\nfoo = ${MY_VAR}\n"))
    cfg.ValueMapper = os.ExpandEnv
    // ...
    env := &Env{}
    err = cfg.Section("env").MapTo(env)
}
```

本例中，`env.Foo` 将会是运行时所获取到环境变量 `MY_VAR` 的值。

# viper 库

viper 是一个配置解决方案，拥有丰富的特性：

- 支持 JSON/TOML/YAML/HCL/envfile/Java properties 等多种格式的配置文件；
- 可以设置监听配置文件的修改，修改时自动加载新的配置；
- 从环境变量、命令行选项和`io.Reader`中读取配置；
- 从远程配置系统中读取和监听修改，如 etcd/Consul；
- 代码逻辑中显示设置键值。

##### 安装：

```
go get github.com/spf13/viper
```

##### 使用

```go
使用：

package main

import (
  "fmt"
  "log"

  "github.com/spf13/viper"
)

func main() {
  viper.SetConfigName("config")
  viper.SetConfigType("toml")
  viper.AddConfigPath(".")
  viper.SetDefault("redis.port", 6381)
  err := viper.ReadInConfig()
  if err != nil {
    log.Fatal("read config failed: %v", err)
  }

  fmt.Println(viper.Get("app_name"))
  fmt.Println(viper.Get("log_level"))

  fmt.Println("mysql ip: ", viper.Get("mysql.ip"))
  fmt.Println("mysql port: ", viper.Get("mysql.port"))
  fmt.Println("mysql user: ", viper.Get("mysql.user"))
  fmt.Println("mysql password: ", viper.Get("mysql.password"))
  fmt.Println("mysql database: ", viper.Get("mysql.database"))

  fmt.Println("redis ip: ", viper.Get("redis.ip"))
  fmt.Println("redis port: ", viper.Get("redis.port"))
}
```

我们使用之前[Go 每日一库之 go-ini](https://darjun.github.io/2020/01/15/godailylib/go-ini/)一文中使用的配置，不过改为 toml 格式。
toml 的语法很简单，快速入门请看[learn X in Y minutes](https://learnxinyminutes.com/docs/toml/)。

```toml
app_name = "awesome web"

# possible values: DEBUG, INFO, WARNING, ERROR, FATAL
log_level = "DEBUG"

[mysql]
ip = "127.0.0.1"
port = 3306
user = "dj"
password = 123456
database = "awesome"

[redis]
ip = "127.0.0.1"
port = 7381
```

viper 的使用非常简单，它需要很少的设置。设置文件名（`SetConfigName`）、配置类型（`SetConfigType`）和搜索路径（`AddConfigPath`），然后调用`ReadInConfig`。
viper会自动根据类型来读取配置。使用时调用`viper.Get`方法获取键值。

编译、运行程序：

```toml
awesome web
DEBUG
mysql ip:  127.0.0.1
mysql port:  3306
mysql user:  dj
mysql password:  123456
mysql database:  awesome
redis ip:  127.0.0.1
redis port:  7381
```

有几点需要注意：

- 设置文件名时不要带后缀；
- 搜索路径可以设置多个，viper 会根据设置顺序依次查找；
- viper 获取值时使用`section.key`的形式，即传入嵌套的键名；
- 默认值可以调用`viper.SetDefault`设置。

## 读取键

viper 提供了多种形式的读取方法。在上面的例子中，我们看到了`Get`方法的用法。`Get`方法返回一个`interface{}`的值，使用有所不便。

`GetType`系列方法可以返回指定类型的值。
其中，Type 可以为`Bool/Float64/Int/String/Time/Duration/IntSlice/StringSlice`。
但是请注意，**如果指定的键不存在或类型不正确，`GetType`方法返回对应类型的零值**。

如果要判断某个键是否存在，使用`IsSet`方法。
另外，`GetStringMap`和`GetStringMapString`直接以 map 返回某个键下面所有的键值对，前者返回`map[string]interface{}`，后者返回`map[string]string`。
`AllSettings`以`map[string]interface{}`返回所有设置。

```go
// 省略包名和 import 部分

func main() {
  viper.SetConfigName("config")
  viper.SetConfigType("toml")
  viper.AddConfigPath(".")
  err := viper.ReadInConfig()
  if err != nil {
    log.Fatal("read config failed: %v", err)
  }

  fmt.Println("protocols: ", viper.GetStringSlice("server.protocols"))
  fmt.Println("ports: ", viper.GetIntSlice("server.ports"))
  fmt.Println("timeout: ", viper.GetDuration("server.timeout"))

  fmt.Println("mysql ip: ", viper.GetString("mysql.ip"))
  fmt.Println("mysql port: ", viper.GetInt("mysql.port"))

  if viper.IsSet("redis.port") {
    fmt.Println("redis.port is set")
  } else {
    fmt.Println("redis.port is not set")
  }

  fmt.Println("mysql settings: ", viper.GetStringMap("mysql"))
  fmt.Println("redis settings: ", viper.GetStringMap("redis"))
  fmt.Println("all settings: ", viper.AllSettings())
}
```

我们在配置文件 config.toml 中添加`protocols`和`ports`配置：

```
[server]
protocols = ["http", "https", "port"]
ports = [10000, 10001, 10002]
timeout = 3s
```

编译、运行程序，输出：

```
protocols:  [http https port]
ports:  [10000 10001 10002]
timeout:  3s
mysql ip:  127.0.0.1
mysql port:  3306
redis.port is set
mysql settings:  map[database:awesome ip:127.0.0.1 password:123456 port:3306 user:dj]
redis settings:  map[ip:127.0.0.1 port:7381]
all settings:  map[app_name:awesome web log_level:DEBUG mysql:map[database:awesome ip:127.0.0.1 password:123456 port:3306 user:dj] redis:map[ip:127.0.0.1 port:7381] server:map[ports:[10000 10001 10002] protocols:[http https port]]]
```

如果将配置中的`redis.port`注释掉，将输出`redis.port is not set`。

上面的示例中还演示了如何使用`time.Duration`类型，只要是`time.ParseDuration`接受的格式都可以，例如`3s`、`2min`、`1min30s`等。

## 设置键值

viper 支持在多个地方设置，使用下面的顺序依次读取：

- 调用`Set`显示设置的；
- 命令行选项；
- 环境变量；
- 配置文件；
- 默认值。

### `viper.Set`

如果某个键通过`viper.Set`设置了值，那么这个值的优先级最高。

```
viper.Set("redis.port", 5381)
```

如果将上面这行代码放到程序中，运行程序，输出的`redis.port`将是 5381。

### 命令行选项

如果一个键没有通过`viper.Set`显示设置值，那么获取时将尝试从命令行选项中读取。
如果有，优先使用。viper 使用 pflag 库来解析选项。
我们首先在`init`方法中定义选项，并且调用`viper.BindPFlags`绑定选项到配置中：

```
func init() {
  pflag.Int("redis.port", 8381, "Redis port to connect")

  // 绑定命令行
  viper.BindPFlags(pflag.CommandLine)
}
```

然后，在`main`方法开头处调用`pflag.Parse`解析选项。

编译、运行程序：

```
$ ./main.exe --redis.port 9381
awesome web
DEBUG
mysql ip:  127.0.0.1
mysql port:  3306
mysql user:  dj
mysql password:  123456
mysql database:  awesome
redis ip:  127.0.0.1
redis port:  9381
```

如何不传入选项：

```
$ ./main.exe
awesome web
DEBUG
mysql ip:  127.0.0.1
mysql port:  3306
mysql user:  dj
mysql password:  123456
mysql database:  awesome
redis ip:  127.0.0.1
redis port:  7381
```

注意，这里并不会使用选项`redis.port`的默认值。

但是，如果通过下面的方法都无法获得键值，那么返回选项默认值（如果有）。试试注释掉配置文件中`redis.port`看看效果。

### 环境变量

如果前面都没有获取到键值，将尝试从环境变量中读取。我们既可以一个个绑定，也可以自动全部绑定。

在`init`方法中调用`AutomaticEnv`方法绑定全部环境变量：

```
func init() {
  // 绑定环境变量
  viper.AutomaticEnv()
}
```

为了验证是否绑定成功，我们在`main`方法中将环境变量 GOPATH 打印出来：

```
func main() {
  // 省略部分代码

  fmt.Println("GOPATH: ", viper.Get("GOPATH"))
}
```

通过 系统 -> 高级设置 -> 新建 创建一个名为`redis.port`的环境变量，值为 10381。
运行程序，输出的`redis.port`值为 10381，并且输出中有 GOPATH 信息。

也可以单独绑定环境变量：

```
func init() {
  // 绑定环境变量
  viper.BindEnv("redis.port")
  viper.BindEnv("go.path", "GOPATH")
}

func main() {
  // 省略部分代码
  fmt.Println("go path: ", viper.Get("go.path"))
}
```

调用`BindEnv`方法，如果只传入一个参数，则这个参数既表示键名，又表示环境变量名。
如果传入两个参数，则第一个参数表示键名，第二个参数表示环境变量名。

还可以通过`viper.SetEnvPrefix`方法设置环境变量前缀，这样一来，通过`AutomaticEnv`和一个参数的`BindEnv`绑定的环境变量，
在使用`Get`的时候，viper 会自动加上这个前缀再从环境变量中查找。

如果对应的环境变量不存在，viper 会自动将键名全部转为大写再查找一次。所以，使用键名`gopath`也能读取环境变量`GOPATH`的值。

### 配置文件

如果经过前面的途径都没能找到该键，viper 接下来会尝试从配置文件中查找。
为了避免环境变量的影响，需要删除`redis.port`这个环境变量。

看[快速使用](https://studygolang.com/articles/26215?fr=sidebar#快速使用)中的示例。

### 默认值

在上面的[快速使用](https://studygolang.com/articles/26215?fr=sidebar#快速使用)一节，我们已经看到了如何设置默认值，这里就不赘述了。

## 读取配置

### 从`io.Reader`中读取

viper 支持从`io.Reader`中读取配置。这种形式很灵活，来源可以是文件，也可以是程序中生成的字符串，甚至可以从网络连接中读取的字节流。

```
package main

import (
  "bytes"
  "fmt"
  "log"

  "github.com/spf13/viper"
)

func main() {
  viper.SetConfigType("toml")
  tomlConfig := []byte(`
app_name = "awesome web"

# possible values: DEBUG, INFO, WARNING, ERROR, FATAL
log_level = "DEBUG"

[mysql]
ip = "127.0.0.1"
port = 3306
user = "dj"
password = 123456
database = "awesome"

[redis]
ip = "127.0.0.1"
port = 7381
`)
  err := viper.ReadConfig(bytes.NewBuffer(tomlConfig))
  if err != nil {
    log.Fatal("read config failed: %v", err)
  }

  fmt.Println("redis port: ", viper.GetInt("redis.port"))
}
```

### `Unmarshal`

viper 支持将配置`Unmarshal`到一个结构体中，为结构体中的对应字段赋值。

```
package main

import (
  "fmt"
  "log"

  "github.com/spf13/viper"
)

type Config struct {
  AppName  string
  LogLevel string

  MySQL    MySQLConfig
  Redis    RedisConfig
}

type MySQLConfig struct {
  IP       string
  Port     int
  User     string
  Password string
  Database string
}

type RedisConfig struct {
  IP   string
  Port int
}

func main() {
  viper.SetConfigName("config")
  viper.SetConfigType("toml")
  viper.AddConfigPath(".")
  err := viper.ReadInConfig()
  if err != nil {
    log.Fatal("read config failed: %v", err)
  }

  var c Config
  viper.Unmarshal(&c)

  fmt.Println(c.MySQL)
}
```

编译，运行程序，输出：

```
{127.0.0.1 3306 dj 123456 awesome}
```

## 保存配置

有时候，我们想要将程序中生成的配置，或者所做的修改保存下来。viper 提供了接口！

- `WriteConfig`：将当前的 viper 配置写到预定义路径，如果没有预定义路径，返回错误。将会覆盖当前配置；
- `SafeWriteConfig`：与上面功能一样，但是如果配置文件存在，则不覆盖；
- `WriteConfigAs`：保存配置到指定路径，如果文件存在，则覆盖；
- `SafeWriteConfig`：与上面功能一样，但是入股配置文件存在，则不覆盖。

下面我们通过程序生成一个`config.toml`配置：

```
package main

import (
  "log"

  "github.com/spf13/viper"
)

func main() {
  viper.SetConfigName("config")
  viper.SetConfigType("toml")
  viper.AddConfigPath(".")

  viper.Set("app_name", "awesome web")
  viper.Set("log_level", "DEBUG")
  viper.Set("mysql.ip", "127.0.0.1")
  viper.Set("mysql.port", 3306)
  viper.Set("mysql.user", "root")
  viper.Set("mysql.password", "123456")
  viper.Set("mysql.database", "awesome")

  viper.Set("redis.ip", "127.0.0.1")
  viper.Set("redis.port", 6381)

  err := viper.SafeWriteConfig()
  if err != nil {
    log.Fatal("write config failed: ", err)
  }
}
```

编译、运行程序，生成的文件如下：

```
app_name = "awesome web"
log_level = "DEBUG"

[mysql]
  database = "awesome"
  ip = "127.0.0.1"
  password = "123456"
  port = 3306
  user = "root"

[redis]
  ip = "127.0.0.1"
  port = 6381
```

## 监听文件修改

viper 可以监听文件修改，热加载配置。因此不需要重启服务器，就能让配置生效。

```
package main

import (
  "fmt"
  "log"
  "time"

  "github.com/spf13/viper"
)

func main() {
  viper.SetConfigName("config")
  viper.SetConfigType("toml")
  viper.AddConfigPath(".")
  err := viper.ReadInConfig()
  if err != nil {
    log.Fatal("read config failed: %v", err)
  }

  viper.WatchConfig()

  fmt.Println("redis port before sleep: ", viper.Get("redis.port"))
  time.Sleep(time.Second * 10)
  fmt.Println("redis port after sleep: ", viper.Get("redis.port"))
}
```

只需要调用`viper.WatchConfig`，viper 会自动监听配置修改。如果有修改，重新加载的配置。

上面程序中，我们先打印`redis.port`的值，然后`Sleep` 10s。在这期间修改配置中`redis.port`的值，`Sleep`结束后再次打印。
发现打印出修改后的值：

```
redis port before sleep:  7381
redis port after sleep:  73810
```

另外，还可以为配置修改增加一个回调：

```
viper.OnConfigChange(func(e fsnotify.Event) {
  fmt.Printf("Config file:%s Op:%s\n", e.Name, e.Op)
})
```

这样文件修改时会执行这个回调。

viper 使用[fsnotify](https://github.com/fsnotify/fsnotify)这个库来实现监听文件修改的功能。

完整示例代码见 [GitHub](https://github.com/darjun/go-daily-lib/tree/master/viper)。

# TOML

全称：Tom 的（语义）明显、（配置）最小化的语言。（Tom's Obvious, Minimal Language）

官网：https://toml.io/cn

它是 YAML 和 JSON 的替代品。它的目标是比 JSON 更人性化，比 YAML 更简单。TOML 旨在明确映射到哈希表。TOML 应该很容易解析为多种语言的数据结构。

- TOML 是大小写敏感的。
- TOML 文件必须是合法的 UTF-8 编码的 Unicode 文档。
- 空白是指制表符（0x09）或空格（0x20）。
- 换行是指 LF（0x0A）或 CRLF（0x0D 0x0A）。

## 基础

### 注释

`#`字符将该行余下的部分标记为注释，除非它在字符串中。

```
# 这是一个全行注释
key = "value"  # 这是一个行末注释
another = "# 这不是一个注释"
```

除制表符以外的控制字符（U+0000 至 U+0008，U+000A 至 U+001F，U+007F）不允许出现在注释中。

### 键值对

TOML 文档最基本的构成区块是键值对。

键名在等号的左边而值在右边。
键名和键值周围的空白会被忽略。
键、等号和值必须在同一行（不过有些值可以跨多行）。

```
key = "value"
```

值必须是下述类型之一。

- [字符串](https://toml.io/cn/v1.0.0#字符串)
- [整数](https://toml.io/cn/v1.0.0#整数)
- [浮点数](https://toml.io/cn/v1.0.0#浮点数)
- [布尔值](https://toml.io/cn/v1.0.0#布尔值)
- [坐标日期时刻](https://toml.io/cn/v1.0.0#坐标日期时刻)
- [各地日期时刻](https://toml.io/cn/v1.0.0#各地日期时刻)
- [各地日期](https://toml.io/cn/v1.0.0#各地日期)
- [各地时刻](https://toml.io/cn/v1.0.0#各地时刻)
- [数组](https://toml.io/cn/v1.0.0#数组)
- [内联表](https://toml.io/cn/v1.0.0#内联表)

不指定值是非法的。

```toml
key = # 非法
```

键值对后必须换行（或结束文件）。
（例外见[内联表](https://toml.io/cn/v1.0.0#内联表)）

```toml
first = "Tom" last = "Preston-Werner" # 非法
```

### 键名

键名可以是*裸露*的，*引号引起来*的，或*点分隔*的。

**裸键**只能包含 ASCII 字母，ASCII 数字，下划线和短横线（`A-Za-z0-9_-`）。
注意裸键允许仅由纯 ASCII 数字构成，例如 `1234`，但总是被解释为字符串。

```toml
key = "value"
bare_key = "value"
bare-key = "value"
1234 = "value"
```

**引号键**遵循与基本字符串或字面量字符串相同的规则并允许你使用更为广泛的键名。

> *除非明显必要，**使用裸键方为最佳实践**。*

```toml
"127.0.0.1" = "value"
"character encoding" = "value"
"ʎǝʞ" = "value"
'key2' = "value"
'quoted "value"' = "value"
```

裸键不能为空，但空引号键是允许的（虽然不建议如此）。

```toml
= "no key name"  # 非法
"" = "blank"     # 合法但不鼓励
'' = 'blank'     # 合法但不鼓励
```

**点分隔键**是一系列通过点相连的裸键或引号键。
这允许了你将相近属性放在一起：

```toml
name = "Orange"
physical.color = "orange"
physical.shape = "round"
site."google.com" = true
```

等价于 JSON 的如下结构：

```json
{
  "name": "Orange",
  "physical": {
    "color": "orange",
    "shape": "round"
  },
  "site": {
    "google.com": true
  }
}
```

有关点分隔键定义表的详细信息，请参阅后文[表](https://toml.io/cn/v1.0.0#表)一节。

点分隔符周围的空白会被忽略。
不过，最佳实践是不要使用任何不必要的空白。

```toml
fruit.name = "banana"     # 这是最佳实践
fruit. color = "yellow"    # 等同于 fruit.color
fruit . flavor = "banana"   # 等同于 fruit.flavor
```

缩进被作为空白对待而被忽略。

多次定义同一个键是非法的。

```toml
# 不要这样做
name = "Tom"
name = "Pradyun"
```

注意裸键和引号键是等价的：

```toml
# 这是不可行的
spelling = "favorite"
"spelling" = "favourite"
```

**只要一个键还没有被直接定义过，你就仍可以对它和它下属的键名赋值**。

```toml
# 这使“fruit”键作为表存在。
fruit.apple.smooth = true

# 所以接下来你可以像中这样对“fruit”表添加内容：
fruit.orange = 2
# 以下是非法的

# 这将 fruit.apple 的值定义为一个整数。
fruit.apple = 1

# 但接下来这将 fruit.apple 像表一样对待了。
# 整数不能变成表。
fruit.apple.smooth = true
```

不鼓励跳跃式地定义点分隔键。

```toml
# 合法但不鼓励

apple.type = "水果"
orange.type = "水果"

apple.skin = "薄"
orange.skin = "厚"

apple.color = "红"
orange.color = "橙"
# 建议

apple.type = "水果"
apple.skin = "薄"
apple.color = "红"

orange.type = "水果"
orange.skin = "厚"
orange.color = "红"
```

由于裸键可以仅由 ASCII 整数组成，所以可能写出看起来像浮点数、但实际上是两部分的点分隔键。
除非你有充分的理由（基本不太会），否则不要这样做。

```toml
3.14159 = "派"
```

上面的 TOML 对应以下 JSON。

```json
{ "3": { "14159": "派" } }
```

## 数据类型

### 字符串

共有四种方式来表示字符串：基本字符串、多行基本字符串、字面量和多行字面量。所有字符串都只能包含有效的 UTF-8 字符。

**基本字符串**由引号（`"`）包裹。
任何 Unicode 字符都可以使用，除了那些必须转义的：引号，反斜杠，以及除制表符外的控制字符（U+0000 至 U+0008，U+000A 至 U+001F，U+007F）。

```toml
str = "我是一个字符串。\"你可以把我引起来\"。姓名\tJos\u00E9\n位置\t旧金山。"
```

为了方便，一些流行的字符有其简便转义写法。

```toml
\b         - backspace       (U+0008)
\t         - tab             (U+0009)
\n         - linefeed        (U+000A)
\f         - form feed       (U+000C)
\r         - carriage return (U+000D)
\"         - quote           (U+0022)
\\         - backslash       (U+005C)
\uXXXX     - unicode         (U+XXXX)
\UXXXXXXXX - unicode         (U+XXXXXXXX)
```

任何 Unicode 字符都可以用 `\uXXXX` 或 `\UXXXXXXXX` 的形式来转义。
转义码必须是有效的 Unicode [标量值](https://unicode.org/glossary/#unicode_scalar_value)。

所有上面未列出的其它转义序列都是保留的；如果用了，TOML 应当产生错误。

有时你需要表示一小篇文本（例如译文）或者想要对非常长的字符串进行折行。
TOML 对此进行了简化。

> **多行基本字符串**由三个引号包裹，允许折行。
>
> 紧随开头引号的那个换行会被去除。
>
> 其它空白和换行会被原样保留。

```toml
str1 = """
Roses are red
Violets are blue"""
```

TOML 解析器可以相对灵活地解析成对所在平台有效的换行字符。

```toml
# 在 Unix 系统，上面的多行字符串可能等同于：
str2 = "Roses are red\nViolets are blue"

# 在 Windows 系统，它可能等价于：
str3 = "Roses are red\r\nViolets are blue"
```

> 想书写长字符串却不想引入无关空白，可以用**“行末反斜杠”**。
> 当一行的最后一个非空白字符是未被转义的 `\` 时，它会连同它后面的所有空白（包括换行）一起被去除，直到下一个非空白字符或结束引号为止。
> 所有对基本字符串有效的转义序列，对多行基本字符串也同样适用。

```toml
# 下列字符串的每一个字节都完全相同：
str1 = "The quick brown fox jumps over the lazy dog."

str2 = """
The quick brown \


  fox jumps over \
    the lazy dog."""

str3 = """\
       The quick brown \
       fox jumps over \
       the lazy dog.\
       """
```

任何 Unicode 字符都可以使用，除了那些必须被转义的：反斜杠和除制表符、换行符、回车符外的控制字符（U+0000 至 U+0008，U+000B，U+000C，U+000E 至 U+001F，U+007F）。

你可以在多行基本字符串内的任何地方写一个引号或两个毗连的引号。
它们也可以写在紧邻界分符内的位置。

```toml
str4 = """这有两个引号：""。够简单。"""
# str5 = """这有两个引号："""。"""  # 非法
str5 = """这有三个引号：""\"。"""
str6 = """这有十五个引号：""\"""\"""\"""\"""\"。"""

# "这，"她说，"只是个无意义的条款。"
str7 = """"这，"她说，"只是个无意义的条款。""""
```

如果你常常要指定 Windows 路径或正则表达式，那么必须转义反斜杠就马上成为啰嗦而易错的了。
为了帮助搞定这点，TOML 支持字面量字符串，它完全不允许转义。

**字面量字符串**由单引号包裹。
类似于基本字符串，他们只能表现为单行：

```toml
# 所见即所得。
winpath  = 'C:\Users\nodejs\templates'
winpath2 = '\\ServerX\admin$\system32\'
quoted   = 'Tom "Dubs" Preston-Werner'
regex    = '<\i\c*\s*>'
```

由于没有转义，无法在由单引号包裹的字面量字符串中写入单引号。
万幸，TOML 支持一种多行版本的字面量字符串来解决这个问题。

**多行字面量字符串**两侧各有三个单引号来包裹，允许换行。
类似于字面量字符串，无论任何转义都不存在。
紧随开始标记的那个换行会被剔除。
开始结束标记之间的所有其它内容会原样对待。

```toml
regex2 = '''I [dw]on't need \d{2} apples'''
lines  = '''
原始字符串中的
第一个换行被剔除了。
   所有其它空白
   都保留了。
'''
```

你可以在多行字面量字符串中的任何位置写一个或两个单引号，但三个以上的单引号序列不可以。

```toml
quot15 = '''这有十五个引号："""""""""""""""'''

# apos15 = '''这有十五个撇号：''''''''''''''''''  # 非法
apos15 = "这有十五个撇号：'''''''''''''''"

# '那，'她说，'仍然没有意义。'
str = ''''那，'她说，'仍然没有意义。''''
```

除制表符以外的所有控制字符都不允许出现在字面量字符串中。
因此，对于二进制数据，建议你使用 Base64 或其它合适的 ASCII 或 UTF-8 编码。
对那些编码的处理方式，将交由应用程序自己来确定。

### 整数

整数是纯数字。
正数可以以加号为前缀。
负数以减号为前缀。

```toml
int1 = +99
int2 = 42
int3 = 0
int4 = -17
```

对于大数，你可以在数字之间用下划线来增强可读性。
每个下划线两侧必须至少有一个数字。

```toml
int5 = 1_000
int6 = 5_349_221
int7 = 53_49_221  # 印度记数体系分组
int8 = 1_2_3_4_5  # 合法但不鼓励
```

前导零是不允许的。
整数值 `-0` 与 `+0` 是有效的，并等同于无前缀的零。

非负整数值也可以用十六进制、八进制或二进制来表示。
在这些格式中，`+` 不被允许，而（前缀后的）前导零是允许的。
十六进制值大小写不敏感。
数字间的下划线是允许的（但不能存在于前缀和值之间）。

```toml
# 带有 `0x` 前缀的十六进制
hex1 = 0xDEADBEEF
hex2 = 0xdeadbeef
hex3 = 0xdead_beef

# 带有 `0o` 前缀的八进制
oct1 = 0o01234567
oct2 = 0o755 # 对于表示 Unix 文件权限很有用

# 带有 `0b` 前缀的二进制
bin1 = 0b11010110
```

任何 64 位有符号整数（从 −2^63 到 2^63−1）都应当被接受并无损处理。
如果无法无损表现某个整数，则必须抛出错误。

### 浮点数

浮点数应当被实现为 IEEE 754 binary64 值。

一个浮点数由一个整数部分（遵从与十进制整数值相同的规则）后跟上一个小数部分和/或一个指数部分组成。
如果小数部分和指数部分兼有，那小数部分必须在指数部分前面。

```toml
# 小数
flt1 = +1.0
flt2 = 3.1415
flt3 = -0.01

# 指数
flt4 = 5e+22
flt5 = 1e06
flt6 = -2E-2

# 都有
flt7 = 6.626e-34
```

小数部分是一个小数点后跟一个或多个数字。

一个指数部分是一个 E（大小写均可）后跟一个整数部分（遵从与十进制整数值相同的规则，但可以包含前导零）。

小数点，如果有用到的话，每侧必须紧邻至少一个数字。

```toml
# 非法的浮点数
invalid_float_1 = .7
invalid_float_2 = 7.
invalid_float_3 = 3.e+20
```

与整数相似，你可以使用下划线来增强可读性。
每个下划线必须被至少一个数字围绕。

```toml
flt8 = 224_617.445_991_228
```

浮点数值 `-0.0` 与 `+0.0` 是有效的，并且应当遵从 IEEE 754。

特殊浮点值也能够表示。
它们是小写的。

```toml
# 无穷
sf1 = inf  # 正无穷
sf2 = +inf # 正无穷
sf3 = -inf # 负无穷

# 非数
sf4 = nan  # 实际上对应信号非数码还是静默非数码，取决于实现
sf5 = +nan # 等同于 `nan`
sf6 = -nan # 有效，实际码取决于实现
```

### 布尔值

布尔值就是你所惯用的那样。
要小写。

```toml
bool1 = true
bool2 = false
```

### 坐标日期时刻

要准确地表示世上的一个特定时间，你可以使用指定了时区偏移量的 [RFC 3339](https://tools.ietf.org/html/rfc3339) 格式的日期时刻。

```toml
odt1 = 1979-05-27T07:32:00Z
odt2 = 1979-05-27T00:32:00-07:00
odt3 = 1979-05-27T00:32:00.999999-07:00
```

出于可读性的目的，你可以用一个空格字符替代日期和时刻之间的 T（RFC 3339 的第 5.6 节中允许了这样做）。

```toml
odt4 = 1979-05-27 07:32:00Z
```

毫秒级的精度是必须的。
更高精度的小数秒取决于实现。
如果它的值超出了实现所支持的精度，那超出的部分必须被舍弃，而不能四舍五入。

### 各地日期时刻

如果你省略了 [RFC 3339](https://tools.ietf.org/html/rfc3339) 日期时刻中的时区偏移量，这表示该日期时刻的使用并不涉及时区偏移。
在没有其它信息的情况下，并不知道它究竟该被转化成世上的哪一刻。
如果仍被要求转化，那结果将取决于实现。

```toml
ldt1 = 1979-05-27T07:32:00
ldt2 = 1979-05-27T00:32:00.999999
```

毫秒级的精度是必须的。
更高精度的小数秒取决于实现。
如果它的值超出了实现所支持的精度，那多余的部分必须被舍弃，而不能四舍五入。

### 各地日期

如果你只写了 [RFC 3339](https://tools.ietf.org/html/rfc3339) 日期时刻中的日期部分，那它表示一整天，同时也不涉及时区偏移。

```toml
ld1 = 1979-05-27
```

### 各地时刻

如果你只写了 [RFC 3339](https://tools.ietf.org/html/rfc3339) 日期时刻中的时刻部分，它将只表示一天之中的那个时刻，而与任何特定的日期无关、亦不涉及时区偏移。

```toml
lt1 = 07:32:00
lt2 = 00:32:00.999999
```

毫秒级的精度是必须的。
更高精度的小数秒取决于实现。
如果它的值超出了实现所支持的精度，那多余的部分必须被舍弃，而不能四舍五入。

### 数组

数组是内含值的方括号。
空白会被忽略。
子元素由逗号分隔。
数组可以包含与键值对所允许的相同数据类型的值。
可以混合不同类型的值。

```toml
integers = [ 1, 2, 3 ]
colors = [ "红", "黄", "绿" ]
nested_array_of_ints = [ [ 1, 2 ], [3, 4, 5] ]
nested_mixed_array = [ [ 1, 2 ], ["a", "b", "c"] ]
string_array = [ "所有的", '字符串', """是相同的""", '''类型''' ]

# 允许混合类型的数组
numbers = [ 0.1, 0.2, 0.5, 1, 2, 5 ]
contributors = [
  "Foo Bar <foo@example.com>",
  { name = "Baz Qux", email = "bazqux@example.com", url = "https://example.com/bazqux" }
]
```

数组可以跨行。
数组的最后一个值后面可以有终逗号（也称为尾逗号）。
值、逗号、结束括号前可以存在任意数量的换行和注释。
数组值和逗号之间的缩进被作为空白对待而被忽略。

```toml
integers2 = [
  1, 2, 3
]

integers3 = [
  1,
  2, # 这是可以的
]
```

### 表

表（也被称为哈希表或字典）是键值对的集合。
它们由表头定义，连同方括号作为单独的行出现。
看得出表头不同于数组，因为数组只有值。

```toml
[table]
```

在它下方，直至下一个表头或文件结束，都是这个表的键值对。
表不保证保持键值对的指定顺序。

```toml
[table-1]
key1 = "some string"
key2 = 123

[table-2]
key1 = "another string"
key2 = 456
```

表名的规则与键名相同（见前文[键名](https://toml.io/cn/v1.0.0#键名)定义）。

```toml
[dog."tater.man"]
type.name = "pug"
```

等价于 JSON 的如下结构：

```json
{ "dog": { "tater.man": { "type": { "name": "pug" } } } }
```

键名周围的空格会被忽略。
然而，最佳实践还是不要有任何多余的空白。

```toml
[a.b.c]            # 这是最佳实践
[ d.e.f ]          # 等同于 [d.e.f]
[ g .  h  . i ]    # 等同于 [g.h.i]
[ j . "ʞ" . 'l' ]  # 等同于 [j."ʞ".'l']
```

缩进被作为空白对待而被忽略。

你不必层层完整地写出你不想写的所有途径的父表。
TOML 知道该怎么办。

```toml
# [x] 你
# [x.y] 不
# [x.y.z] 需要这些
[x.y.z.w] # 来让这生效

[x] # 后置父表定义是可以的
```

空表是允许的，只要里面没有键值对就行了。

类似于键名，你不能重复定义一个表。
这样做是非法的。

```toml
# 不要这样做

[fruit]
apple = "红"

[fruit]
orange = "橙"
# 也不要这样做

[fruit]
apple = "红"

[fruit.apple]
texture = "光滑"
```

不鼓励无序地定义表。

```toml
# 有效但不鼓励
[fruit.apple]
[animal]
[fruit.orange]
# 推荐
[fruit.apple]
[fruit.orange]
[animal]
```

顶层表，又被称为根表，于文档开始处开始并在第一个表头（或文件结束处）前结束。
不同于其它表，它没有名字且无法后置。

```toml
# 顶层表开始。
name = "Fido"
breed = "pug"

# 顶层表结束。
[owner]
name = "Regina Dogman"
member_since = 1999-08-04
```

点分隔键为最后一个键名前的每个键名创建并定义一个表，倘若这些表尚未被创建的话。

```toml
fruit.apple.color = "red"
# 定义一个名为 fruit 的表
# 定义一个名为 fruit.apple 的表

fruit.apple.taste.sweet = true
# 定义一个名为 fruit.apple.taste 的表
# fruit 和 fruit.apple 已经创建过了
```

由于表不能定义多于一次，不允许使用 `[table]` 头重定义这样的表。
同样地，使用点分隔键来重定义已经以 `[table]` 形式定义过的表也是不允许的。
不过，`[table]` 形式可以被用来定义通过点分隔键定义的表中的子表。

```toml
[fruit]
apple.color = "红"
apple.taste.sweet = true

# [fruit.apple]  # 非法
# [fruit.apple.taste]  # 非法

[fruit.apple.texture]  # 你可以添加子表
smooth = true
```

### 内联表

内联表提供了一种更为紧凑的语法来表示表。
它们对于分组数据特别有用，否则这些数据很快就会变得冗长。
内联表被完整地定义在花括号之中：`{` 和 `}`。 括号中，可以出现零或更多个以逗号分隔的键值对。
键值对采取与标准表中的键值对相同的形式。
什么类型的值都可以，包括内联表。

内联表得出现在同一行内。
内联表中，最后一对键值对后不允许终逗号（也称为尾逗号）。
不允许花括号中出现任何换行，除非在值中它们合法。
即便如此，也强烈不建议把一个内联表搞成纵跨多行的样子。
如果你发现自己真的需要，那意味着你应该使用标准表。

```toml
name = { first = "Tom", last = "Preston-Werner" }
point = { x = 1, y = 2 }
animal = { type.name = "pug" }
```

上述内联表等同于下面的标准表定义：

```toml
[name]
first = "Tom"
last = "Preston-Werner"

[point]
x = 1
y = 2

[animal]
type.name = "pug"
```

内联表是独立自足的，在内部定义全部的键与子表。
不能在括号以外的地方，再添加键与子表。

```toml
[product]
type = { name = "Nail" }
# type.edible = false  # 非法
```

类似地，内联表不能被用于向一个已定义的表添加键或子表。

```toml
[product]
type.name = "Nail"
# type = { edible = false }  # 非法
```

### 表数组

最后一个还没讲到的语法允许你写表数组。
这可以通过把表名写在双方括号里的表头来表示。
表头的第一例定义了这个数组及其首个表元素，而后续的每个则在该数组中创建并定义一个新的表元素。
这些表按出现顺序插入该数组。

```toml
[[products]]
name = "Hammer"
sku = 738594937

[[products]]  # 数组里的空表

[[products]]
name = "Nail"
sku = 284758393

color = "gray"
```

等价于 JSON 的如下结构。

```json
{
  "products": [
    { "name": "Hammer", "sku": 738594937 },
    { },
    { "name": "Nail", "sku": 284758393, "color": "gray" }
  ]
}
```

任何对表数组的引用都指向该数组里最近定义的表元素。
这允许你在最近的表内定义子表，甚至子表数组。

```toml
[[fruits]]
name = "apple"

[fruits.physical]  # 子表
color = "red"
shape = "round"

[[fruits.varieties]]  # 嵌套表数组
name = "red delicious"

[[fruits.varieties]]
name = "granny smith"

[[fruits]]
name = "banana"

[[fruits.varieties]]
name = "plantain"
```

上述 TOML 等价于 JSON 的如下结构。

```json
{
  "fruits": [
    {
      "name": "apple",
      "physical": {
        "color": "red",
        "shape": "round"
      },
      "varieties": [
        { "name": "red delicious" },
        { "name": "granny smith" }
      ]
    },
    {
      "name": "banana",
      "varieties": [
        { "name": "plantain" }
      ]
    }
  ]
}
```

如果一个表或表数组的父级是一个数组元素，该元素必须在定义子级前先定义。
顺序颠倒的行为，必须在解析时报错。

```toml
# 非法的 TOML 文档
[fruit.physical]  # 子表，但它应该隶属于哪个父元素？
color = "red"
shape = "round"

[[fruit]]  # 解析器必须在发现“fruit”是数组而非表时抛出错误
name = "apple"
```

若试图向一个静态定义的数组追加内容，即便数组尚且为空，也必须在解析时报错。

```toml
# 非法的 TOML 文档
fruits = []

[[fruits]] # 不允许
```

若试图用已经确定为数组的名称定义表，必须在解析时报错。
将数组重定义为普通表的行为，也必须在解析时报错。

```toml
# 非法的 TOML 文档
[[fruits]]
name = "apple"

[[fruits.varieties]]
name = "red delicious"

# 非法：该表与之前的表数组相冲突
[fruits.varieties]
name = "granny smith"

[fruits.physical]
color = "red"
shape = "round"

# 非法：该表数组与之前的表相冲突
[[fruits.physical]]
color = "green"
```

你也可以适当使用内联表：

```toml
points = [ { x = 1, y = 2, z = 3 },
           { x = 7, y = 8, z = 9 },
           { x = 2, y = 4, z = 8 } ]
```

## 文件扩展名

TOML 文件应当使用 `.toml` 扩展名。

## MIME 类型

在互联网上传输 TOML 文件时，恰当的 MIME 类型是 `application/toml`。

## ABNF 语法

TOML 语法的严谨说明，由一个 [ABNF 文件](https://github.com/toml-lang/toml/blob/1.0.0/toml.abnf)另行提供。